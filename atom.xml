<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOEL-T99</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-15T01:19:30.142Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JOEL-T99</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Seaborn Multi-plot grids</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Multi-plot-grids/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Multi-plot-grids/</id>
    <published>2021-06-14T04:36:42.000Z</published>
    <updated>2021-06-15T01:19:30.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Facet-grids"><a href="#Facet-grids" class="headerlink" title="Facet grids"></a>Facet grids</h1><h2 id="seaborn-FacetGrid"><a href="#seaborn-FacetGrid" class="headerlink" title="seaborn.FacetGrid"></a>seaborn.FacetGrid</h2><p><em>类</em><code>seaborn.``FacetGrid</code>( *** kwargs* ) </p><p>用于绘制条件关系的多图网格。</p><p>初始化 matplotlib 图和 FacetGrid 对象。</p><p>此类将数据集映射到多个轴，这些轴排列在与数据集中变量<em>级别</em>相对应的行和列网格中。它生成的图通常被称为“格子”、“格子”或“小多重”图形。</p><p>它还可以用<code>hue</code> 参数表示第三个变量的水平，该参数以不同的颜色绘制不同的数据子集。这使用颜色来解析第三维上的元素，但仅在彼此之上绘制子集，并且不会像<code>hue</code> 接受的轴级函数那样为特定可视化定制参数<code>hue</code>。</p><p>基本工作流程是<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>使用数据集和用于构建网格的变量来初始化对象。然后可以通过调用<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map.html#seaborn.FacetGrid.map"><code>FacetGrid.map()</code></a>或将一个或多个绘图函数应用于每个子集 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map_dataframe.html#seaborn.FacetGrid.map_dataframe"><code>FacetGrid.map_dataframe()</code></a>。最后，可以使用其他方法调整绘图以执行更改轴标签、使用不同刻度或添加图例等操作。有关更多信息，请参阅下面的详细代码示例。</p><div class="note orange no-icon flat"><p>警告</p><p>当使用从数据集推断语义映射的 seaborn 函数时，必须注意跨方面同步这些映射（例如，通过<code>hue</code>使用调色板字典定义映射或将变量的数据类型设置为<code>category</code>）。在大多数情况下，使用图形级函数（例如<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a> 或<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>）比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>直接使用更好。</p></div><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a></p><p>用于绘制成对关系的子图网格</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot</code></a></p><p>结合一个关系图和一个 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot"><code>displot</code></a></p><p>结合分布图和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot</code></a></p><p>结合一个分类图和一个 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.lmplot.html#seaborn.lmplot"><code>lmplot</code></a></p><p>结合回归图和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p></li></ul></div><p>这些示例使用 seaborn 函数来演示该类的一些高级功能，但在大多数情况下，您将希望使用图形级别的函数（例如<a href="http://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot"><code>displot()</code></a>、<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>）来制作此处显示的图。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  DataFrame</p><p>整洁（“长格式”）数据框，其中每一列都是一个变量，每一行都是一个观察值。</p><p><strong>row, col, hue</strong>  strings</p><p>定义数据子集的变量，这些数据将被绘制在网格中的不同方面。请参阅<code>{var}_order</code>参数以控制此变量的级别顺序。</p><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p><p><strong>share{x,y}</strong>  bool, ‘col’, or ‘row’ optional</p><p>如果为 true，则构面将跨列共享 y 轴和/或跨行共享 x 轴。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p><p><strong>palette</strong>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>{row,col,hue}_order</strong>  lists</p><p>分面变量级别的顺序。默认情况下，这将是级别出现的顺序，<code>data</code>或者，如果变量是大熊猫分类，则是类别顺序。</p><p><strong>hue_kws</strong>  dictionary of param -&gt; list of values mapping</p><p>插入绘图调用的其他关键字参数，以让其他绘图属性随色调变量的级别而变化（例如散点图中的标记）。</p><p><strong>legend_out</strong>  bool</p><p>如果<code>True</code>，图形大小将被扩展，并且图例将绘制在中间右侧的绘图之外。</p><p><strong>despine</strong>  boolean</p><p>从图中删除顶部和右侧的刺。</p><p><strong>margin_titles</strong>  bool</p><p>如果<code>True</code>，则行变量的标题绘制在最后一列的右侧。此选项是实验性的，可能不适用于所有情况。</p><p><strong>{x, y}lim: tuples</strong></p><p>每个方面的每个轴的限制（仅当 share{x, y} 为 True 时才相关）。</p><p><strong>subplot_kws</strong>  dict</p><p>传递给 matplotlib subplot(s) 方法的关键字参数字典。</p><p><strong>gridspec_kws</strong>  dict</p><p>传递给matplotlib.gridspec.GridSpec (via matplotlib.pyplot.subplots())的关键字参数字典 。如果col_wrap不是，则忽略None。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>调用构造函数需要一个长格式的数据对象。这会初始化网格，但不会在其上绘制任何内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips &#x3D; sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">sns.FacetGrid(tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_1_0.png"></p><p>分配列和/或行变量以向图中添加更多子图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.FacetGrid(tips, col&#x3D;&quot;time&quot;, row&#x3D;&quot;sex&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_3_0.png"></p><p>要在每个方面绘制图，请将函数和数据框中一个或多个列的名称传递给<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map.html#seaborn.FacetGrid.map"><code>FacetGrid.map()</code></a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;,  row&#x3D;&quot;sex&quot;)</span><br><span class="line">g.map(sns.scatterplot, &quot;total_bill&quot;, &quot;tip&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_5_0.png"></p><p>中的变量规范<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map.html#seaborn.FacetGrid.map"><code>FacetGrid.map()</code></a>需要位置参数映射，但如果函数有<code>data</code>参数并接受命名变量赋值，您还可以使用<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map_dataframe.html#seaborn.FacetGrid.map_dataframe"><code>FacetGrid.map_dataframe()</code></a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;,  row&#x3D;&quot;sex&quot;)</span><br><span class="line">g.map_dataframe(sns.histplot, x&#x3D;&quot;total_bill&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_7_0.png"></p><p>两种方法的区别之一是<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map_dataframe.html#seaborn.FacetGrid.map_dataframe"><code>FacetGrid.map_dataframe()</code></a>不添加轴标签。有一种专门的方法可以做到这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;,  row&#x3D;&quot;sex&quot;)</span><br><span class="line">g.map_dataframe(sns.histplot, x&#x3D;&quot;total_bill&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Count&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_9_0.png"></p><p>请注意 bin 在每个方面的宽度如何不同。每个方面都绘制了一个单独的图，因此如果绘图函数从数据中导出任何参数，则它们可能不会跨方面共享。您可以传递额外的关键字参数来同步它们。但是如果可能，使用像这样的图形级函数<a href="http://seaborn.pydata.org/generated/seaborn.displot.html#seaborn.displot"><code>displot()</code></a>将为您处理这种簿记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;, row&#x3D;&quot;sex&quot;)</span><br><span class="line">g.map_dataframe(sns.histplot, x&#x3D;&quot;total_bill&quot;, binwidth&#x3D;2)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Count&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_11_0.png"></p><p>该<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>构造函数接受一个<code>hue</code>参数。设置此项将根据另一个变量调整数据，并以不同颜色绘制多个图。在可能的情况下，跟踪标签信息以便可以绘制单个图例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;, hue&#x3D;&quot;sex&quot;)</span><br><span class="line">g.map_dataframe(sns.scatterplot, x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Tip&quot;)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_13_0.png"></p><p>但是，当在<code>hue</code>上设置 时<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>，将为变量的每个水平绘制单独的图。如果绘图函数理解<code>hue</code>，最好让它处理该逻辑。但是，确保每个面都使用相同的色调映射很重要。在示例<code>tips</code>数据中，该<code>sex</code>列具有分类数据类型，可确保：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;)</span><br><span class="line">g.map_dataframe(sns.scatterplot, x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, hue&#x3D;&quot;sex&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Tip&quot;)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_15_0.png"></p><p>使用<code>height</code>和<code>aspect</code>参数在每个子图的级别指定图的大小和形状：</p><p>改变每个面的高度和纵横比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;day&quot;, height&#x3D;3.5, aspect&#x3D;.65)</span><br><span class="line">g.map(sns.histplot, &quot;total_bill&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_18_0.png"></p><p>如果分配给的变量<code>col</code>有多个级别，则可以“包装”它以跨越多行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;size&quot;, height&#x3D;2, col_wrap&#x3D;3)</span><br><span class="line">g.map(sns.histplot, &quot;total_bill&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_20_0.png"></p><p>您可以传递自定义函数来绘制或注释每个方面。您的自定义函数必须使用 matplotlib 状态机接口在“当前”轴上绘图，并且应该捕获其他关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">def annotate(data, **kws):</span><br><span class="line">    n &#x3D; len(data)</span><br><span class="line">    ax &#x3D; plt.gca()</span><br><span class="line">    ax.text(.1, .6, f&quot;N &#x3D; &#123;n&#125;&quot;, transform&#x3D;ax.transAxes)</span><br><span class="line"></span><br><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;time&quot;)</span><br><span class="line">g.map_dataframe(sns.scatterplot, x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Tip&quot;)</span><br><span class="line">g.map_dataframe(annotate)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_22_0.png"></p><p>该<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>对象还有一些其他有用的参数和方法来调整绘图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;sex&quot;, row&#x3D;&quot;time&quot;, margin_titles&#x3D;True)</span><br><span class="line">g.map_dataframe(sns.scatterplot, x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Tip&quot;)</span><br><span class="line">g.set_titles(col_template&#x3D;&quot;&#123;col_name&#125; patrons&quot;, row_template&#x3D;&quot;&#123;row_name&#125;&quot;)</span><br><span class="line">g.set(xlim&#x3D;(0, 60), ylim&#x3D;(0, 12), xticks&#x3D;[10, 30, 50], yticks&#x3D;[2, 6, 10])</span><br><span class="line">g.tight_layout()</span><br><span class="line">g.savefig(&quot;facet_plot.png&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_24_0.png"></p><p>您还可以访问底层的 matplotlib 对象以进行额外的调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.FacetGrid(tips, col&#x3D;&quot;sex&quot;, row&#x3D;&quot;time&quot;, margin_titles&#x3D;True, despine&#x3D;False)</span><br><span class="line">g.map_dataframe(sns.scatterplot, x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;)</span><br><span class="line">g.set_axis_labels(&quot;Total bill&quot;, &quot;Tip&quot;)</span><br><span class="line">g.fig.subplots_adjust(wspace&#x3D;0, hspace&#x3D;0)</span><br><span class="line">for (row_val, col_val), ax in g.axes_dict.items():</span><br><span class="line">    if row_val &#x3D;&#x3D; &quot;Lunch&quot; and col_val &#x3D;&#x3D; &quot;Female&quot;:</span><br><span class="line">        ax.set_facecolor(&quot;.95&quot;)</span><br><span class="line">    else:</span><br><span class="line">        ax.set_facecolor((0, 0, 0, 0))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/FacetGrid_26_0.png"></p><h3 id="方法-amp-属性"><a href="#方法-amp-属性" class="headerlink" title="方法&amp;属性"></a>方法&amp;属性</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid.__init__"><code>__init__</code></a>(self, data, *[, row, col, hue, …])</td><td>初始化 matplotlib 图和 FacetGrid 对象。</td></tr><tr><td><code>add_legend</code>(self[, legend_data, title, …])</td><td>绘制一个图例，可能将其放置在轴外并调整图形大小。</td></tr><tr><td><code>despine</code>(self, **kwargs)</td><td>从刻面上移除轴脊。</td></tr><tr><td><code>facet_axis</code>(self, row_i, col_j[, modify_state])</td><td>激活由这些索引标识的轴并返回它。</td></tr><tr><td><code>facet_data</code>(self)</td><td>每个方面的名称索引和数据子集的生成器。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map.html#seaborn.FacetGrid.map"><code>map</code></a>(self, func, *args, **kwargs)</td><td>将绘图函数应用于数据的每个方面的子集。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.map_dataframe.html#seaborn.FacetGrid.map_dataframe"><code>map_dataframe</code></a>(self, func, *args, **kwargs)</td><td>Like <code>.map</code>but 将 args 作为字符串传递并在 kwargs 中插入数据。</td></tr><tr><td><code>savefig</code>(self, *args, **kwargs)</td><td>保存图。</td></tr><tr><td><code>set</code>(self, **kwargs)</td><td>在每个子图轴上设置属性。</td></tr><tr><td><code>set_axis_labels</code>(self[, x_var, y_var, …])</td><td>在网格的左列和底行上设置轴标签。</td></tr><tr><td><code>set_titles</code>(self[, template, row_template, …])</td><td>在每个面上方或网格边距上绘制标题。</td></tr><tr><td><code>set_xlabels</code>(self[, label, clear_inner])</td><td>在网格的底行标记 x 轴。</td></tr><tr><td><code>set_xticklabels</code>(self[, labels, step])</td><td>设置网格的 x 轴刻度标签。</td></tr><tr><td><code>set_ylabels</code>(self[, label, clear_inner])</td><td>在网格的左列上标记 y 轴。</td></tr><tr><td><code>set_yticklabels</code>(self[, labels])</td><td>在网格的左列上设置 y 轴刻度标签。</td></tr><tr><td><code>tight_layout</code>(self, *args, **kwargs)</td><td>在排除图例的矩形内调用 fig.tight_layout 。</td></tr></tbody></table><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>属性说明</th></tr></thead><tbody><tr><td><code>ax</code></td><td>在<a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a>当没有小面的变量分配。</td></tr><tr><td><code>axes</code></td><td><a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a>网格中的对象数组。</td></tr><tr><td><code>axes_dict</code></td><td>构面名称到相应<a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a>.</td></tr><tr><td><code>fig</code></td><td>在<a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>同积。</td></tr><tr><td><code>legend</code></td><td>的<a href="https://matplotlib.org/api/legend_api.html#matplotlib.legend.Legend"><code>matplotlib.legend.Legend</code></a>对象，如果存在的话。</td></tr></tbody></table><p>&nbsp;</p><h2 id="seaborn-FacetGrid-map"><a href="#seaborn-FacetGrid-map" class="headerlink" title="seaborn.FacetGrid.map"></a>seaborn.FacetGrid.map</h2><p>将绘图函数应用于数据的每个方面的子集。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>func</strong>  callable</p><p>一个采用数据和关键字参数的绘图函数。它必须绘制到当前活动的 matplotlib Axes 并采用 <code>color</code>关键字参数。如果在<code>hue</code>维度上进行分面，它还必须采用<code>label</code>关键字参数。</p><p><strong>args</strong>  strings</p><p>self.data 中的列名，用于标识带有要绘制的数据的变量。每个变量的数据<code>func</code>按照调用中指定变量的顺序传递。</p><p><strong>kwargs</strong>  keyword arguments</p><p>所有关键字参数都传递给绘图函数。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&nbsp;</p><h2 id="seaborn-FacetGrid-map-dataframe"><a href="#seaborn-FacetGrid-map-dataframe" class="headerlink" title="seaborn.FacetGrid.map_dataframe"></a>seaborn.FacetGrid.map_dataframe</h2><p>Like <code>.map</code>but 将 args 作为字符串传递并在 kwargs 中插入数据。</p><p>此方法适用于使用接受长格式 DataFrame 作为<code>data</code>关键字参数并使用字符串变量名称访问该 DataFrame 中的数据的函数进行绘图。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>func</strong>  callable</p><p>一个采用数据和关键字参数的绘图函数。与<code>map</code>方法不同的是，这里使用的函数必须“理解”Pandas 对象。它还必须绘制到当前活动的 matplotlib Axes 并采用<code>color</code>关键字参数。如果在<code>hue</code> 维度上进行分面，它还必须采用<code>label</code>关键字参数。</p><p><strong>args</strong>  strings</p><p>self.data 中的列名，用于标识带有要绘制的数据的变量。每个变量的数据<code>func</code>按照调用中指定变量的顺序传递。</p><p><strong>kwargs</strong> keyword arguments</p><p>所有关键字参数都传递给绘图函数。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&nbsp;</p><h1 id="Pair-grids"><a href="#Pair-grids" class="headerlink" title="Pair grids"></a>Pair grids</h1><h2 id="seaborn-pairplot"><a href="#seaborn-pairplot" class="headerlink" title="seaborn.pairplot"></a>seaborn.pairplot</h2><p>在数据集中绘制成对关系。</p><p>默认情况下，此函数将创建一个 Axes 网格，以便在<code>data</code>单行的 y 轴和单列的 x 轴之间共享每个数值变量。对角线图的处理方式不同：绘制单变量分布图以显示每列中数据的边际分布。</p><p>还可以在行和列上显示变量的子集或绘制不同的变量。</p><div class="note blue no-icon flat"><p>也可以看看</p><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a></p><p>子图网格用于更灵活地绘制成对关系。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.JointGrid.html#seaborn.JointGrid"><code>JointGrid</code></a></p><p>用于绘制两个变量的联合分布和边际分布的网格。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  <code>pandas.DataFrame</code></p><p>整洁（长格式）数据框，其中每一列都是一个变量，每一行都是一个观察值。</p><p><strong>hue</strong>  name of variable in <code>data</code></p><p>变量 in<code>data</code>将绘图方面映射到不同的颜色。</p><p><strong>hue_order</strong>  list of strings</p><p>调色板中色调变量的级别顺序</p><p><strong>palette</strong>  dict or seaborn color palette</p><p>用于映射<code>hue</code>变量的颜色集。如果是字典，键应该是<code>hue</code>变量中的值。</p><p><strong>vars</strong>  list of variable names</p><p><code>data</code>要使用的变量，否则使用数字数据类型的每一列。</p><p><strong>{x, y}_vars</strong>  lists of variable names</p><p>内部变量<code>data</code>分别用于图形的行和列；即制作非方形图。</p><p><strong>kind</strong>  {‘scatter’, ‘kde’, ‘hist’, ‘reg’}</p><p>要制作的情节。</p><p><strong>diag_kind</strong>  {‘auto’, ‘hist’, ‘kde’, None}</p><p>对角线子图的一种图。如果是“自动”，则根据是否<code>hue</code>使用进行选择。</p><p><strong>markers</strong>  single matplotlib marker code or list</p><p>用于所有散点图点的标记或长度与色调变量中的级别数相同的标记列表，以便不同颜色的点也将具有不同的散点图标记。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。</p><p><strong>aspect</strong>  scalar</p><p>Aspect * height 给出了每个面的宽度（以英寸为单位）。</p><p><strong>corner</strong>  bool</p><p>如果为 True，则不要将轴添加到网格的上（非对角线）三角形，使其成为“角”图。</p><p><strong>dropna</strong>  boolean</p><p>在绘图之前从数据中删除缺失值。</p><p><strong>{plot, diag, grid}_kws</strong>  dicts</p><p>关键字参数字典。plot_kws传递给二元绘图函数，diag_kws传递给单变量绘图函数，然后grid_kws传递给PairGrid 构造函数。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>最简单的调用<a href="http://seaborn.pydata.org/generated/seaborn.scatterplot.html#seaborn.scatterplot"><code>scatterplot()</code></a>用于每对变量和<a href="http://seaborn.pydata.org/generated/seaborn.histplot.html#seaborn.histplot"><code>histplot()</code></a>沿对角线的边际图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penguins &#x3D; sns.load_dataset(&quot;penguins&quot;)</span><br><span class="line">sns.pairplot(penguins)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_1_0.png"></p><p>分配<code>hue</code>变量会添加语义映射并将默认边缘图更改为分层内核密度估计 (KDE)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, hue&#x3D;&quot;species&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_3_0.png"></p><p>可以强制边缘直方图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, hue&#x3D;&quot;species&quot;, diag_kind&#x3D;&quot;hist&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_5_0.png"></p><p>该<code>kind</code>参数决定了对角线和非对角线绘图风格。有几个选项可用，包括<a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>kdeplot()</code></a>用于绘制 KDE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, kind&#x3D;&quot;kde&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_7_0.png"></p><p>或者<a href="http://seaborn.pydata.org/generated/seaborn.histplot.html#seaborn.histplot"><code>histplot()</code></a>绘制双变量和单变量直方图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, kind&#x3D;&quot;hist&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_9_0.png"></p><p>该<code>markers</code>参数在非对角轴上应用样式映射。目前，它将与<code>hue</code>变量冗余：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, hue&#x3D;&quot;species&quot;, markers&#x3D;[&quot;o&quot;, &quot;s&quot;, &quot;D&quot;])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_11_0.png"></p><p>与其他图形级函数一样，图形的大小是通过设置<code>height</code>每个子图的 来控制的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, height&#x3D;1.5)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_13_0.png"></p><p>使用<code>vars</code>或<code>x_vars</code>和<code>y_vars</code>选择要绘制的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(</span><br><span class="line">    penguins,</span><br><span class="line">    x_vars&#x3D;[&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;],</span><br><span class="line">    y_vars&#x3D;[&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_15_0.png"></p><p>设置<code>corner=True</code>为仅绘制下三角形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(penguins, corner&#x3D;True)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_17_0.png"></p><p>在<code>plot_kws</code>和<code>diag_kws</code>参数接受的关键字参数类型的字典定制的非对角和对角地块，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(</span><br><span class="line">    penguins,</span><br><span class="line">    plot_kws&#x3D;dict(marker&#x3D;&quot;+&quot;, linewidth&#x3D;1),</span><br><span class="line">    diag_kws&#x3D;dict(fill&#x3D;False),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_19_0.png"></p><p>返回对象是底层<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>，可用于进一步自定义绘图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.pairplot(penguins, diag_kind&#x3D;&quot;kde&quot;)</span><br><span class="line">g.map_lower(sns.kdeplot, levels&#x3D;4, color&#x3D;&quot;.2&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/pairplot_21_0.png"></p><p>&nbsp;</p><h2 id="seaborn-PairGrid"><a href="#seaborn-PairGrid" class="headerlink" title="seaborn.PairGrid"></a>seaborn.PairGrid</h2><p>用于在数据集中绘制成对关系的子图网格。</p><p>此对象将数据集中的每个变量映射到多轴网格中的列和行。可以使用不同的轴级绘图函数在上下三角形中绘制双变量图，并且可以在对角线上显示每个变量的边缘分布。</p><p>使用 可以在一行中生成几个不同的常见图 <a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot"><code>pairplot()</code></a>。<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>当您需要更大的灵活性时使用。</p><div class="note blue no-icon flat"><p>也可以看看</p><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot"><code>pairplot</code></a></p><p>轻松绘制<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>.</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p><p>用于绘制条件关系的子图网格。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>DataFrame</p><p>整洁（长格式）数据框，其中每一列都是一个变量，每一行都是一个观察值。</p><p><strong>hue</strong>  string (variable name)</p><p>变量 in<code>data</code>将绘图方面映射到不同的颜色。此变量将从默认的 x 和 y 变量中排除。</p><p><strong>hue_order</strong>  list of strings</p><p>调色板中色调变量的级别顺序</p><p><strong>palette</strong>  dict or seaborn color palette</p><p>用于映射<code>hue</code>变量的颜色集。如果是字典，键应该是<code>hue</code>变量中的值。</p><p><strong>hue_kws</strong>  dictionary of param -&gt; list of values mapping</p><p>插入绘图调用的其他关键字参数，以让其他绘图属性随色调变量的级别而变化（例如散点图中的标记）。</p><p><strong>vars</strong>  list of variable names</p><p><code>data</code>要使用的变量，否则使用数字数据类型的每一列。</p><p><strong>{x, y}_vars</strong>  lists of variable names</p><p>内部变量<code>data</code>分别用于图形的行和列；即制作非方形图。</p><p><strong>corner</strong>  bool</p><p>如果为 True，则不要将轴添加到网格的上（非对角线）三角形，使其成为“角”图。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。</p><p><strong>aspect</strong>  scalar</p><p>Aspect * height 给出了每个面的宽度（以英寸为单位）。</p><p><strong>layout_pad</strong>  scalar</p><p>轴之间的填充；传递给<code>fig.tight_layout</code>.</p><p><strong>despine</strong>  boolean</p><p>从图中删除顶部和右侧的刺。</p><p><strong>dropna</strong>  boolean</p><p>在绘图之前从数据中删除缺失值。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><p>调用构造函数设置一个空白的子图网格，每一行和一列对应于数据集中的一个数值变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penguins &#x3D; sns.load_dataset(&quot;penguins&quot;)</span><br><span class="line">g &#x3D; sns.PairGrid(penguins)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_1_0.png"></p><p>传递一个二元函数<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map.html#seaborn.PairGrid.map"><code>PairGrid.map()</code></a>将在每个轴上绘制一个二元图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins)</span><br><span class="line">g.map(sns.scatterplot)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_3_0.png"></p><p>通过独立的功能<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_diag.html#seaborn.PairGrid.map_diag"><code>PairGrid.map_diag()</code></a>，并<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_offdiag.html#seaborn.PairGrid.map_offdiag"><code>PairGrid.map_offdiag()</code></a>会显示每个变量的对角线上的边缘分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins)</span><br><span class="line">g.map_diag(sns.histplot)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_5_0.png"></p><p>也可以在绘图的上下三角形上使用不同的函数（否则是多余的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, diag_sharey&#x3D;False)</span><br><span class="line">g.map_upper(sns.scatterplot)</span><br><span class="line">g.map_lower(sns.kdeplot)</span><br><span class="line">g.map_diag(sns.kdeplot)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_7_0.png"></p><p>或者完全避免冗余：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, diag_sharey&#x3D;False, corner&#x3D;True)</span><br><span class="line">g.map_lower(sns.scatterplot)</span><br><span class="line">g.map_diag(sns.kdeplot)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_9_0.png"></p><p>所述<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>构造函数接受一个<code>hue</code>变量。这个变量直接传递给理解它的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;species&quot;)</span><br><span class="line">g.map_diag(sns.histplot)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_11_0.png"></p><p>但是您也可以传递 matplotlib 函数，在这种情况下，在内部执行 groupby 并为每个级别绘制单独的图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;species&quot;)</span><br><span class="line">g.map_diag(plt.hist)</span><br><span class="line">g.map_offdiag(plt.scatter)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_13_0.png"></p><p>可以通过在映射函数时直接传递数据向量来分配额外的语义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;species&quot;)</span><br><span class="line">g.map_diag(sns.histplot)</span><br><span class="line">g.map_offdiag(sns.scatterplot, size&#x3D;penguins[&quot;sex&quot;])</span><br><span class="line">g.add_legend(title&#x3D;&quot;&quot;, adjust_subtitles&#x3D;True)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_15_0.png"></p><p>当使用可以实现数字色调映射的 seaborn 函数时，您将需要禁用对角轴上的变量映射。请注意，该<code>hue</code>变量被排除在默认显示的变量列表之外：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;body_mass_g&quot;)</span><br><span class="line">g.map_diag(sns.histplot, hue&#x3D;None, color&#x3D;&quot;.3&quot;)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_17_0.png"></p><p>该<code>vars</code>参数可用于精确控制使用哪些变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variables &#x3D; [&quot;body_mass_g&quot;, &quot;bill_length_mm&quot;, &quot;flipper_length_mm&quot;]</span><br><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;body_mass_g&quot;, vars&#x3D;variables)</span><br><span class="line">g.map_diag(sns.histplot, hue&#x3D;None, color&#x3D;&quot;.3&quot;)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_19_0.png"></p><p>该图不必是方形的：可以使用单独的变量来定义行和列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x_vars &#x3D; [&quot;body_mass_g&quot;, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;]</span><br><span class="line">y_vars &#x3D; [&quot;body_mass_g&quot;]</span><br><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;species&quot;, x_vars&#x3D;x_vars, y_vars&#x3D;y_vars)</span><br><span class="line">g.map_diag(sns.histplot, color&#x3D;&quot;.3&quot;)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_21_0.png"></p><p>探索解决对角轴上多个分布的不同方法会很有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; sns.PairGrid(penguins, hue&#x3D;&quot;species&quot;)</span><br><span class="line">g.map_diag(sns.histplot, multiple&#x3D;&quot;stack&quot;, element&#x3D;&quot;step&quot;)</span><br><span class="line">g.map_offdiag(sns.scatterplot)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/PairGrid_23_0.png"></p><h3 id="方法-amp-属性-1"><a href="#方法-amp-属性-1" class="headerlink" title="方法&amp;属性"></a>方法&amp;属性</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid.__init__"><code>__init__</code></a>(self, data, *[, hue, hue_order, …])</td><td>初始化绘图图形和 PairGrid 对象。</td></tr><tr><td><code>add_legend</code>(self[, legend_data, title, …])</td><td>绘制一个图例，可能将其放置在轴外并调整图形大小。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map.html#seaborn.PairGrid.map"><code>map</code></a>(self, func, **kwargs)</td><td>在每个子图中使用相同的函数绘图。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_diag.html#seaborn.PairGrid.map_diag"><code>map_diag</code></a>(self, func, **kwargs)</td><td>在每个对角子图上使用单变量函数绘图。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_lower.html#seaborn.PairGrid.map_lower"><code>map_lower</code></a>(self, func, **kwargs)</td><td>在下对角子图上使用二元函数绘图。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_offdiag.html#seaborn.PairGrid.map_offdiag"><code>map_offdiag</code></a>(self, func, **kwargs)</td><td>在非对角子图上使用二元函数绘图。</td></tr><tr><td><a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.map_upper.html#seaborn.PairGrid.map_upper"><code>map_upper</code></a>(self, func, **kwargs)</td><td>在上对角子图上使用二元函数绘图。</td></tr><tr><td><code>savefig</code>(self, *args, **kwargs)</td><td>保存图。</td></tr><tr><td><code>set</code>(self, **kwargs)</td><td>在每个子图轴上设置属性。</td></tr><tr><td><code>tight_layout</code>(self, *args, **kwargs)</td><td>在排除图例的矩形内调用 fig.tight_layout 。</td></tr></tbody></table><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>属性说明</th></tr></thead><tbody><tr><td><code>legend</code></td><td>的<a href="https://matplotlib.org/api/legend_api.html#matplotlib.legend.Legend"><code>matplotlib.legend.Legend</code></a>对象，如果存在的话。</td></tr></tbody></table><h2 id="seaborn-PairGrid-map"><a href="#seaborn-PairGrid-map" class="headerlink" title="seaborn.PairGrid.map"></a>seaborn.PairGrid.map</h2><p>在每个子图中使用相同的函数绘图。</p><p><strong>属性说明</strong></p><p><strong>func</strong>  callable plotting function</p><p>必须将 x、y 数组作为位置参数并绘制到“当前活动”的 matplotlib 轴上。还需要接受称为<code>color</code>and 的kwargs <code>label</code>。</p><h2 id="seaborn-PairGrid-map-diag"><a href="#seaborn-PairGrid-map-diag" class="headerlink" title="seaborn.PairGrid.map_diag"></a>seaborn.PairGrid.map_diag</h2><p>在每个子图中使用相同的函数绘图。</p><p><strong>属性说明</strong></p><p><strong>func</strong>  callable plotting function</p><p>必须将 x、y 数组作为位置参数并绘制到“当前活动”的 matplotlib 轴上。还需要接受称为<code>color</code>and 的kwargs <code>label</code>。</p><h2 id="seaborn-PairGrid-map-offdiag"><a href="#seaborn-PairGrid-map-offdiag" class="headerlink" title="seaborn.PairGrid.map_offdiag"></a>seaborn.PairGrid.map_offdiag</h2><p>在非对角子图上使用二元函数绘图。</p><p><strong>属性说明</strong></p><p><strong>func</strong>  callable plotting function</p><p>必须将 x、y 数组作为位置参数并绘制到“当前活动”的 matplotlib 轴上。还需要接受称为colorand 的kwargs label。</p><h2 id="seaborn-PairGrid-map-lower"><a href="#seaborn-PairGrid-map-lower" class="headerlink" title="seaborn.PairGrid.map_lower"></a>seaborn.PairGrid.map_lower</h2><p>在下对角子图上使用二元函数绘图。</p><p><strong>属性说明</strong></p><p><strong>func</strong>  callable plotting function</p><p>必须将 x、y 数组作为位置参数并绘制到“当前活动”的 matplotlib 轴上。还需要接受称为<code>color</code>and 的kwargs <code>label</code>。</p><h2 id="seaborn-PairGrid-map-upper"><a href="#seaborn-PairGrid-map-upper" class="headerlink" title="seaborn.PairGrid.map_upper"></a>seaborn.PairGrid.map_upper</h2><p>在上对角子图上使用二元函数绘图。</p><p><strong>属性说明</strong></p><p><strong>func</strong>  callable plotting function</p><p>必须将 x、y 数组作为位置参数并绘制到“当前活动”的 matplotlib 轴上。还需要接受称为<code>color</code>and 的kwargs <code>label</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn Matrix plots</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Matrix-plots/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Matrix-plots/</id>
    <published>2021-06-14T04:36:21.000Z</published>
    <updated>2021-06-14T14:23:00.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Matrix-plots"><a href="#Matrix-plots" class="headerlink" title="Matrix plots"></a>Matrix plots</h1><h2 id="seaborn-heatmap"><a href="#seaborn-heatmap" class="headerlink" title="seaborn.heatmap"></a>seaborn.heatmap</h2><p>将矩形数据绘制为颜色编码矩阵。</p><p>这是一个 Axes 级函数，如果没有提供给<code>ax</code>参数，则会将热图绘制到当前活动的 Axes 中。将使用此 Axes 空间的一部分并用于绘制颜色图，除非<code>cbar</code> 为 False 或向 提供了单独的 Axes <code>cbar_ax</code>。</p><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap"><code>clustermap</code></a></p><p>使用分层聚类绘制矩阵以排列行和列。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  rectangular dataset</p><p>可以强制转换为 ndarray 的二维数据集。如果提供了 Pandas DataFrame，索引/列信息将用于标记列和行。</p><p><strong>vmin, vmax</strong>  floats, optional</p><p>锚定颜色图的值，否则它们是从数据和其他关键字参数推断出来的。</p><p><strong>cmap</strong>  matplotlib colormap name or object, or list of colors, optional</p><p>从数据值到颜色空间的映射。如果未提供，默认值将取决于是否<code>center</code>设置。</p><p><strong>center</strong>  float, optional</p><p>绘制发散数据时使颜色图居中的值。<code>cmap</code>如果未指定，则使用此参数将更改默认值。</p><p><strong>robust</strong>  bool, optional</p><p>如果 True 和<code>vmin</code>或<code>vmax</code>不存在，则使用稳健的分位数而不是极值来计算颜色图范围。</p><p><strong>annot</strong>  bool or rectangular dataset, optional</p><p>如果为 True，则在每个单元格中写入数据值。如果与 具有相同形状的类似数组<code>data</code>，则使用它来注释热图而不是数据。请注意，DataFrames 将匹配位置，而不是索引。</p><p><strong>fmt</strong>  str, optional</p><p>添加注释时使用的字符串格式化代码。</p><p><strong>annot_kws</strong>  dict of key, value mappings, optional</p><p><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.text.html#matplotlib.axes.Axes.text"><code>matplotlib.axes.Axes.text()</code></a>when 的关键字参数为<code>annot</code> True。</p><p><strong>linewidths</strong>  float, optional</p><p>将划分每个单元格的线的宽度。</p><p><strong>linecolor</strong>  color, optional</p><p>将划分每个单元格的线条的颜色。</p><p><strong>cbar</strong>  bool, optional</p><p>是否绘制颜色条。</p><p><strong>cbar_kws</strong>  dict of key, value mappings, optional</p><p>的关键字参数<a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.colorbar"><code>matplotlib.figure.Figure.colorbar()</code></a>。</p><p><strong>cbar_ax</strong>  matplotlib Axes, optional</p><p>绘制颜色条的轴，否则占用主轴的空间。</p><p><strong>square</strong>  bool, optional</p><p>如果为 True，请将 Axes 方面设置为“相等”，以便每个单元格都为方形。</p><p><strong>xticklabels, yticklabels</strong>  “auto”, bool, list-like, or int, optional</p><p>如果为 True，则绘制数据框的列名。如果为 False，则不要绘制列名称。如果类似列表，则将这些替代标签绘制为 xticklabels。如果是整数，则使用列名但只绘制每 n 个标签。如果为“自动”，请尝试密集绘制非重叠标签。</p><p><strong>mask</strong>  bool array or DataFrame, optional</p><p>如果通过，数据将不会显示在<code>mask</code>True 的单元格中。带有缺失值的单元格会被自动屏蔽。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>在其中绘制绘图的轴，否则使用当前活动的轴。</p><p><strong>kwargs</strong>  other keyword arguments</p><p>所有其他关键字参数都传递给 matplotlib.axes.Axes.pcolormesh().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>为 numpy 数组绘制热图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np; np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.set_theme()</span><br><span class="line">uniform_data = np.random.rand(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line">ax = sns.heatmap(uniform_data)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-1.png"></p><p>更改颜色图的限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(uniform_data, vmin=<span class="number">0</span>, vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-2.png"></p><p>使用发散的颜色图绘制以 0 为中心的数据的热图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">normal_data = np.random.randn(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line">ax = sns.heatmap(normal_data, center=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-3.png"></p><p>用有意义的行和列标签绘制数据框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(<span class="string">&quot;flights&quot;</span>)</span><br><span class="line">flights = flights.pivot(<span class="string">&quot;month&quot;</span>, <span class="string">&quot;year&quot;</span>, <span class="string">&quot;passengers&quot;</span>)</span><br><span class="line">ax = sns.heatmap(flights)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-4.png"></p><p>使用整数格式用数值注释每个单元格：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(flights, annot=<span class="literal">True</span>, fmt=<span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-5.png"></p><p>在每个单元格之间添加线条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(flights, linewidths=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-6.png"></p><p>使用不同的颜色图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(flights, cmap=<span class="string">&quot;YlGnBu&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-7.png"></p><p>将颜色图以特定值居中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(flights, center=flights.loc[<span class="string">&quot;Jan&quot;</span>, <span class="number">1955</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-8.png"></p><p>绘制每隔一个列标签，不绘制行标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line">ax = sns.heatmap(data, xticklabels=<span class="number">2</span>, yticklabels=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-9.png"></p><p>不要绘制颜色条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.heatmap(flights, cbar=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-10.png"></p><p>对颜色条使用不同的轴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grid_kws = &#123;<span class="string">&quot;height_ratios&quot;</span>: (<span class="number">.9</span>, <span class="number">.05</span>), <span class="string">&quot;hspace&quot;</span>: <span class="number">.3</span>&#125;</span><br><span class="line">f, (ax, cbar_ax) = plt.subplots(<span class="number">2</span>, gridspec_kw=grid_kws)</span><br><span class="line">ax = sns.heatmap(flights, ax=ax,</span><br><span class="line"><span class="meta">... </span>                 cbar_ax=cbar_ax,</span><br><span class="line"><span class="meta">... </span>                 cbar_kws=&#123;<span class="string">&quot;orientation&quot;</span>: <span class="string">&quot;horizontal&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-111.png"></p><p>使用掩码仅绘制矩阵的一部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corr = np.corrcoef(np.random.randn(<span class="number">10</span>, <span class="number">200</span>))</span><br><span class="line">mask = np.zeros_like(corr)</span><br><span class="line">mask[np.triu_indices_from(mask)] = <span class="literal">True</span></span><br><span class="line"><span class="keyword">with</span> sns.axes_style(<span class="string">&quot;white&quot;</span>):</span><br><span class="line"><span class="meta">... </span>    f, ax = plt.subplots(figsize=(<span class="number">7</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">... </span>    ax = sns.heatmap(corr, mask=mask, vmax=<span class="number">.3</span>, square=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-heatmap-12.png"></p><p>&nbsp;</p><h2 id="seaborn-clustermap"><a href="#seaborn-clustermap" class="headerlink" title="seaborn.clustermap"></a>seaborn.clustermap</h2><p>将矩阵数据集绘制为分层聚类的热图。</p><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.heatmap.html#seaborn.heatmap"><code>heatmap</code></a></p><p>将矩形数据绘制为颜色编码矩阵。</p></li></ul></div><p><code>savefig</code>如果您想保存图形对象而不剪切树状图，则返回的对象有一个应该使用的方法。</p><p>要访问重新排序的行索引，请使用： <code>clustergrid.dendrogram_row.reordered_ind</code></p><p>列索引，使用： <code>clustergrid.dendrogram_col.reordered_ind</code></p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  2D array-like</p><p>用于聚类的矩形数据。不能包含 NA。</p><p><strong>pivot_kws</strong>  dict, optional</p><p>如果<code>data</code>是一个整洁的数据框，可以为pivot提供关键字参数来创建一个矩形数据框。</p><p><strong>method</strong>  str, optional</p><p>用于计算聚类的链接方法。有关<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html#scipy.cluster.hierarchy.linkage"><code>scipy.cluster.hierarchy.linkage()</code></a>更多信息，请参阅 文档。</p><p><strong>metric</strong>  str, optional</p><p>用于数据的距离度量。有关<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist"><code>scipy.spatial.distance.pdist()</code></a>更多选项，请参阅 文档。要对行和列使用不同的度量（或方法），您可以自己构建每个链接矩阵并将它们提供为 <code>{row,col}_linkage</code>.</p><p><strong>z_score</strong>  int or None, optional</p><p>0（行）或 1（列）。是否计算行或列的 z 分数。Z 分数为：z = (x - mean)/std，因此每行（列）中的值将减去行（列）的平均值，然后除以行（列）的标准偏差。这确保了每一行（列）的均值为 0，方差为 1。</p><p><strong>standard_scale</strong>  int or None, optional</p><p>0（行）或 1（列）。是否标准化该维度，即每行或每列，减去最小值并将每个除以其最大值。</p><p><strong>figsize</strong>  tuple of (width, height), optional</p><p>图的整体尺寸。</p><p><strong>cbar_kws</strong>  dict, optional</p><p>传递给<code>cbar_kws</code>in 的关键字参数<a href="http://seaborn.pydata.org/generated/seaborn.heatmap.html#seaborn.heatmap"><code>heatmap()</code></a>，例如向颜色条添加标签。</p><p><strong>{row,col}_cluster</strong>  bool, optional</p><p>如果<code>True</code>，聚类{行，列}。</p><p><strong>{row,col}_linkage</strong>  <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, optional</p><p>行或列的预计算链接矩阵。<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html#scipy.cluster.hierarchy.linkage"><code>scipy.cluster.hierarchy.linkage()</code></a>具体格式见 。</p><p><strong>{row,col}_colors</strong>  list-like or pandas DataFrame/Series, optional</p><p>要为行或列标记的颜色列表。用于评估组内的样本是否聚集在一起。可以将嵌套列表或 DataFrame 用于多种颜色级别的标签。如果以 a<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>或 形式给出 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series"><code>pandas.Series</code></a>，则颜色标签将从 DataFrames 列名称或系列名称中提取。DataFrame/Series 颜色也通过它们的索引与数据匹配，确保以正确的顺序绘制颜色。</p><p><strong>mask</strong>  bool array or DataFrame, optional</p><p>如果通过，数据将不会显示在<code>mask</code>True 的单元格中。带有缺失值的单元格会被自动屏蔽。仅用于可视化，不用于计算。</p><p><strong>{dendrogram,colors}_ratio</strong>  float, or pair of floats, optional</p><p>用于两个边缘元素的图形大小的比例。如果给出一对，它们对应于 (row, col) 比率。</p><p><strong>cbar_pos</strong>  tuple of (left, bottom, width, height), optional</p><p>图中颜色条轴的位置。设置为<code>None</code>将禁用颜色栏。</p><p><strong>tree_kws</strong>  dict, optional</p><p><a href="https://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection"><code>matplotlib.collections.LineCollection</code></a> 用于绘制树状图树线的参数。</p><p><strong>kwargs</strong>  other keyword arguments</p><p>所有其他关键字参数都传递给heatmap().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>绘制聚类热图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.set_theme(color_codes=<span class="literal">True</span>)</span><br><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line">species = iris.pop(<span class="string">&quot;species&quot;</span>)</span><br><span class="line">g = sns.clustermap(iris)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-1.png"></p><p>更改图形的大小和布局：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = sns.clustermap(iris,</span><br><span class="line"><span class="meta">... </span>                   figsize=(<span class="number">7</span>, <span class="number">5</span>),</span><br><span class="line"><span class="meta">... </span>                   row_cluster=<span class="literal">False</span>,</span><br><span class="line"><span class="meta">... </span>                   dendrogram_ratio=(<span class="number">.1</span>, <span class="number">.2</span>),</span><br><span class="line"><span class="meta">... </span>                   cbar_pos=(<span class="number">0</span>, <span class="number">.2</span>, <span class="number">.03</span>, <span class="number">.4</span>))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-2.png"></p><p>添加彩色标签以识别观察结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lut = <span class="built_in">dict</span>(<span class="built_in">zip</span>(species.unique(), <span class="string">&quot;rbg&quot;</span>))</span><br><span class="line">row_colors = species.<span class="built_in">map</span>(lut)</span><br><span class="line">g = sns.clustermap(iris, row_colors=row_colors)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-3.png"></p><p>使用不同的颜色图并调整颜色范围的限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.clustermap(iris, cmap=<span class="string">&quot;mako&quot;</span>, vmin=<span class="number">0</span>, vmax=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-4.png"></p><p>使用不同的相似度度量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.clustermap(iris, metric=<span class="string">&quot;correlation&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-5.png"></p><p>使用不同的聚类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.clustermap(iris, method=<span class="string">&quot;single&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-6.png"></p><p>标准化列内的数据：</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns<span class="variable">.clustermap</span>(iris, standard_scale=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-7.png"></p><p>规范化行内的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.clustermap(iris, z_score=<span class="number">0</span>, cmap=<span class="string">&quot;vlag&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-clustermap-8.png"></p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn Regression plots</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Regression-plots/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Regression-plots/</id>
    <published>2021-06-14T04:36:07.000Z</published>
    <updated>2021-06-14T14:17:38.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Regression-plots"><a href="#Regression-plots" class="headerlink" title="Regression plots"></a>Regression plots</h1><h2 id="seaborn-lmplot"><a href="#seaborn-lmplot" class="headerlink" title="seaborn.lmplot"></a>seaborn.lmplot</h2><p>绘制数据和回归模型适合 FacetGrid。</p><p>该函数结合了<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。它旨在作为一个方便的接口来拟合数据集的条件子集的回归模型。</p><p>该<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.lmplot.html#seaborn.lmplot"><code>lmplot()</code></a>功能密切相关，但前者的轴级别的功能，而后者是一个数字级别的功能，结合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。</p><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot</code></a></p><p>绘制数据和条件模型拟合。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a></p><p>用于绘制条件关系的子图网格。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot"><code>pairplot</code></a></p><p>组合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>（与 一起使用时<code>kind=&quot;reg&quot;</code>）。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">lmplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>x, y</strong>  strings, optional</p><p>输入变量；这些应该是<code>data</code>.</p><p><strong>data</strong>  DataFrame</p><p>整洁（“长格式”）数据框，其中每一列都是一个变量，每一行都是一个观察值。</p><p><strong>hue, col, row</strong>  strings</p><p>定义数据子集的变量，这些数据将被绘制在网格中的不同方面。请参阅<code>*_order</code>参数以控制此变量的级别顺序。</p><p><strong>palette</strong>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p><p><strong>markers</strong>  matplotlib marker code or list of marker codes, optional</p><p>散点图的标记。如果是列表，则列表中的每个标记都将用于<code>hue</code>变量的每个级别。</p><p><strong>share{x,y}</strong>  bool, ‘col’, or ‘row’ optional</p><p>如果为 true，则构面将跨列共享 y 轴和/或跨行共享 x 轴。</p><p><strong>{hue,col,row}_order</strong>  lists, optional</p><p>分面变量级别的顺序。默认情况下，这将是级别出现的顺序，<code>data</code>或者，如果变量是大熊猫分类，则是类别顺序。</p><p><strong>legend</strong>  bool, optional</p><p>如果<code>True</code>存在<code>hue</code>变量，则添加图例。</p><p><strong>legend_out</strong>  bool</p><p>如果<code>True</code>，图形大小将被扩展，并且图例将绘制在中间右侧的绘图之外。</p><p><strong>x_estimator</strong>  callable that maps vector -&gt; scalar, optional</p><p>将此函数应用于 的每个唯一值<code>x</code>并绘制结果估计值。当<code>x</code>是离散变量时，这很有用。如果<code>x_ci</code>给出，则此估计将被引导并绘制置信区间。</p><p><strong>x_bins</strong>  int or vector, optional</p><p>将<code>x</code>变量分箱为离散分箱，然后估计集中趋势和置信区间。这种分箱只影响散点图的绘制方式；回归仍然适合原始数据。此参数被解释为大小均匀（不需要间隔）的 bin 数量或 bin 中心的位置。使用此参数时，表示默认 <code>x_estimator</code>为<code>numpy.mean</code>。</p><p><strong>x_ci</strong>  “ci”, “sd”, int in [0, 100] or None, optional</p><p>绘制 的离散值的集中趋势时使用的置信区间的大小<code>x</code>。如果<code>&quot;ci&quot;</code>，则遵循<code>ci</code>参数的值 。如果<code>&quot;sd&quot;</code>，则跳过引导并显示每个 bin 中观测值的标准偏差。</p><p><strong>scatter</strong>  bool, optional</p><p>如果<code>True</code>，绘制带有基础观测值（或<code>x_estimator</code>值）的散点图。</p><p><strong>fit_reg</strong>  bool, optional</p><p>如果<code>True</code>，估计并绘制一个与<code>x</code> 和<code>y</code>变量相关的回归模型。</p><p><strong>ci</strong>  int in [0, 100] or None, optional</p><p>回归估计的置信区间的大小。这将使用回归线周围的半透明带绘制。使用自举法估计置信区间；对于大型数据集，建议将此参数设置为 None 来避免该计算。</p><p><strong>n_boot</strong>  int, optional</p><p>用于估计<code>ci</code>. 默认值试图平衡时间和稳定性；您可能希望为绘图的“最终”版本增加此值。</p><p><strong>units</strong>  variable name in <code>data</code>, optional</p><p>如果<code>x</code>和<code>y</code>观测值嵌套在抽样单位内，则可以在此处指定。在通过执行对单元和观察值（在单元内）重新采样的多级引导程序来计算置信区间时，将考虑到这一点。这不会影响回归的估计或绘制方式。</p><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState, optional</p><p>用于可重复引导的种子或随机数生成器。</p><p><strong>order</strong>  int, optional</p><p>如果<code>order</code>大于 1，则用于<code>numpy.polyfit</code>估计多项式回归。</p><p><strong>logistic</strong>  bool, optional</p><p>如果<code>True</code>，假设它<code>y</code>是一个二元变量并用于 <code>statsmodels</code>估计逻辑回归模型。请注意，这比线性回归在计算上要密集得多，因此您可能希望减少引导重新采样的数量 ( <code>n_boot</code>) 或设置<code>ci</code>为无。</p><p><strong>lowess</strong>  bool, optional</p><p>如果<code>True</code>，用于<code>statsmodels</code>估计非参数 Lowess 模型（局部加权线性回归）。请注意，目前无法为此类模型绘制置信区间。</p><p><strong>robust</strong>  bool, optional</p><p>如果<code>True</code>，用于<code>statsmodels</code>估计稳健回归。这将减轻异常值的权重。请注意，这比标准线性回归在计算上更加密集，因此您可能希望减少引导重新采样的数量 ( <code>n_boot</code>) 或设置 <code>ci</code>为无。</p><p><strong>logx</strong>  bool, optional</p><p>如果<code>True</code>，估计形式为 y ~ log(x) 的线性回归，但在输入空间中绘制散点图和回归模型。请注意， <code>x</code>必须为正数才能使其正常工作。</p><p><strong>{x,y}_partial</strong>  strings in <code>data</code> or matrices</p><p>在绘图之前混淆变量以从<code>x</code>或<code>y</code>变量中回归。</p><p><strong>truncate</strong>  bool, optional</p><p>如果<code>True</code>，则回归线受数据限制的限制。如果 <code>False</code>，则扩展到<code>x</code>轴限制。</p><p><strong>{x,y}_jitter</strong>  floats, optional</p><p>将这种大小的均匀随机噪声添加到<code>x</code>或<code>y</code> 变量中。噪声在拟合回归后被添加到数据的副本中，并且仅影响散点图的外观。这在绘制采用离散值的变量时会很有帮助。</p><p><strong>{scatter,line}_kws</strong>  dictionaries</p><p>传递给plt.scatterand 的 其他关键字参数plt.plot。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>这些示例侧重于展示各种分面选项的基本回归模型图；<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>有关绘制数据和模型的其他选项的演示，请参阅文档。还有其他示例说明如何使用<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>文档上的返回对象操作绘图。</p><p>绘制两个变量之间的简单线性关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import seaborn as sns; sns.set_theme(color_codes&#x3D;True)</span><br><span class="line">&gt;&gt;&gt; tips &#x3D; sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, data&#x3D;tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-1.png"></p><p>以第三个变量为条件并以不同颜色绘制水平：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, hue&#x3D;&quot;smoker&quot;, data&#x3D;tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-2.png"></p><p>使用不同的标记和颜色，使情节更容易再现为黑白：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, hue&#x3D;&quot;smoker&quot;, data&#x3D;tips,</span><br><span class="line">...                markers&#x3D;[&quot;o&quot;, &quot;x&quot;])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-3.png"></p><p>使用不同的调色板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, hue&#x3D;&quot;smoker&quot;, data&#x3D;tips,</span><br><span class="line">...                palette&#x3D;&quot;Set1&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-4.png"></p><p><code>hue</code>使用字典将级别映射到颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, hue&#x3D;&quot;smoker&quot;, data&#x3D;tips,</span><br><span class="line">...                palette&#x3D;dict(Yes&#x3D;&quot;g&quot;, No&#x3D;&quot;m&quot;))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-5.png"></p><p>绘制跨不同列的第三个变量的水平：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, col&#x3D;&quot;smoker&quot;, data&#x3D;tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-6.png"></p><p>更改面的高度和纵横比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;size&quot;, y&#x3D;&quot;total_bill&quot;, hue&#x3D;&quot;day&quot;, col&#x3D;&quot;day&quot;,</span><br><span class="line">...                data&#x3D;tips, height&#x3D;6, aspect&#x3D;.4, x_jitter&#x3D;.1)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-7.png"></p><p>将列变量的级别包装成多行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, col&#x3D;&quot;day&quot;, hue&#x3D;&quot;day&quot;,</span><br><span class="line">...                data&#x3D;tips, col_wrap&#x3D;2, height&#x3D;3)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-8.png"></p><p>以两个变量为条件以制作完整网格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, row&#x3D;&quot;sex&quot;, col&#x3D;&quot;time&quot;,</span><br><span class="line">...                data&#x3D;tips, height&#x3D;3)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-9.png"></p><p>在返回的<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>实例上使用方法来进一步调整绘图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; sns.lmplot(x&#x3D;&quot;total_bill&quot;, y&#x3D;&quot;tip&quot;, row&#x3D;&quot;sex&quot;, col&#x3D;&quot;time&quot;,</span><br><span class="line">...                data&#x3D;tips, height&#x3D;3)</span><br><span class="line">&gt;&gt;&gt; g &#x3D; (g.set_axis_labels(&quot;Total bill (US Dollars)&quot;, &quot;Tip&quot;)</span><br><span class="line">...       .set(xlim&#x3D;(0, 60), ylim&#x3D;(0, 12),</span><br><span class="line">...            xticks&#x3D;[10, 30, 50], yticks&#x3D;[2, 6, 10])</span><br><span class="line">...       .fig.subplots_adjust(wspace&#x3D;.02))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-lmplot-10.png"></p><p>&nbsp;</p><h2 id="seaborn-regplot"><a href="#seaborn-regplot" class="headerlink" title="seaborn.regplot"></a>seaborn.regplot</h2><p>绘制数据和线性回归模型拟合。</p><p>该<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.lmplot.html#seaborn.lmplot"><code>lmplot()</code></a>功能密切相关，但前者的轴级别的功能，而后者是一个数字级别的功能，结合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。</p><p>通过和 函数组合 combine <a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>and<a href="http://seaborn.pydata.org/generated/seaborn.JointGrid.html#seaborn.JointGrid"><code>JointGrid</code></a>或 函数也很容易，尽管它们不直接接受所有的参数。<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a><a href="http://seaborn.pydata.org/generated/seaborn.jointplot.html#seaborn.jointplot"><code>jointplot()</code></a><a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot"><code>pairplot()</code></a><a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a></p><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.lmplot.html#seaborn.lmplot"><code>lmplot</code></a></p><p>组合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>并<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>绘制数据集中的多个线性关系。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.jointplot.html#seaborn.jointplot"><code>jointplot</code></a></p><p>组合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.JointGrid.html#seaborn.JointGrid"><code>JointGrid</code></a>（与 一起使用时<code>kind=&quot;reg&quot;</code>）。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn.pairplot"><code>pairplot</code></a></p><p>组合<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.PairGrid.html#seaborn.PairGrid"><code>PairGrid</code></a>（与 一起使用时<code>kind=&quot;reg&quot;</code>）。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.residplot.html#seaborn.residplot"><code>residplot</code></a></p><p>绘制线性回归模型的残差。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">regplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>x, y: string, series, or vector array</strong></p><p>输入变量。如果是字符串，它们应该与<code>data</code>. 使用 pandas 对象时，轴将标有系列名称。</p><p><strong>data</strong>  DataFrame</p><p>整洁（“长格式”）数据框，其中每一列都是一个变量，每一行都是一个观察值。</p><p><strong>x_estimator</strong>  callable that maps vector -&gt; scalar, optional</p><p>将此函数应用于 的每个唯一值<code>x</code>并绘制结果估计值。当<code>x</code>是离散变量时，这很有用。如果<code>x_ci</code>给出，则此估计将被引导并绘制置信区间。</p><p><strong>x_bins</strong>  int or vector, optional</p><p>将<code>x</code>变量分箱为离散分箱，然后估计集中趋势和置信区间。这种分箱只影响散点图的绘制方式；回归仍然适合原始数据。此参数被解释为大小均匀（不需要间隔）的 bin 数量或 bin 中心的位置。使用此参数时，表示默认 <code>x_estimator</code>为<code>numpy.mean</code>。</p><p><strong>x_ci</strong>  “ci”, “sd”, int in [0, 100] or None, optional</p><p>绘制 的离散值的集中趋势时使用的置信区间的大小<code>x</code>。如果<code>&quot;ci&quot;</code>，则遵循<code>ci</code>参数的值 。如果<code>&quot;sd&quot;</code>，则跳过引导并显示每个 bin 中观测值的标准偏差。</p><p><strong>scatter</strong>  bool, optional</p><p>如果<code>True</code>，绘制带有基础观测值（或<code>x_estimator</code>值）的散点图。</p><p><strong>fit_reg</strong>  bool, optional</p><p>如果<code>True</code>，估计并绘制一个与<code>x</code> 和<code>y</code>变量相关的回归模型。</p><p><strong>ci</strong>  int in [0, 100] or None, optional</p><p>回归估计的置信区间的大小。这将使用回归线周围的半透明带绘制。使用自举法估计置信区间；对于大型数据集，建议将此参数设置为 None 来避免该计算。</p><p><strong>n_boot</strong>  int, optional</p><p>用于估计<code>ci</code>. 默认值试图平衡时间和稳定性；您可能希望为绘图的“最终”版本增加此值。</p><p><strong>units</strong>  variable name in <code>data</code>, optional</p><p>如果<code>x</code>和<code>y</code>观测值嵌套在抽样单位内，则可以在此处指定。在通过执行对单元和观察值（在单元内）重新采样的多级引导程序来计算置信区间时，将考虑到这一点。这不会影响回归的估计或绘制方式。</p><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState, optional</p><p>用于可重复引导的种子或随机数生成器。</p><p><strong>order</strong>  int, optional</p><p>如果<code>order</code>大于 1，则用于<code>numpy.polyfit</code>估计多项式回归。</p><p><strong>logistic</strong>  bool, optional</p><p>如果<code>True</code>，假设它<code>y</code>是一个二元变量并用于 <code>statsmodels</code>估计逻辑回归模型。请注意，这比线性回归在计算上要密集得多，因此您可能希望减少引导重新采样的数量 ( <code>n_boot</code>) 或设置<code>ci</code>为无。</p><p><strong>lowess</strong>  bool, optional</p><p>如果<code>True</code>，用于<code>statsmodels</code>估计非参数 Lowess 模型（局部加权线性回归）。请注意，目前无法为此类模型绘制置信区间。</p><p><strong>robust</strong>  bool, optional</p><p>如果<code>True</code>，用于<code>statsmodels</code>估计稳健回归。这将减轻异常值的权重。请注意，这比标准线性回归在计算上更加密集，因此您可能希望减少引导重新采样的数量 ( <code>n_boot</code>) 或设置 <code>ci</code>为无。</p><p><strong>logx</strong> bool, optional</p><p>如果<code>True</code>，估计形式为 y ~ log(x) 的线性回归，但在输入空间中绘制散点图和回归模型。请注意， <code>x</code>必须为正数才能使其正常工作。</p><p><strong>{x,y}_partial</strong>  strings in <code>data</code> or matrices</p><p>在绘图之前混淆变量以从<code>x</code>或<code>y</code>变量中回归。</p><p><strong>truncate</strong>  bool, optional</p><p>如果<code>True</code>，则回归线受数据限制的限制。如果 <code>False</code>，则扩展到<code>x</code>轴限制。</p><p><strong>{x,y}_jitter</strong>  floats, optional</p><p>将这种大小的均匀随机噪声添加到<code>x</code>或<code>y</code> 变量中。噪声在拟合回归后被添加到数据的副本中，并且仅影响散点图的外观。这在绘制采用离散值的变量时会很有帮助。</p><p><strong>label</strong>  string</p><p>应用于散点图或回归线（如果<code>scatter</code>是<code>False</code>）以在图例中使用的标签 。</p><p><strong>color</strong>  matplotlib color</p><p>应用于所有绘图元素的颜色；将被传入<code>scatter_kws</code>或的颜色取代<code>line_kws</code>。</p><p><strong>marker</strong>  matplotlib marker code</p><p>用于散点图字形的标记。</p><p><strong>{scatter,line}_kws</strong>  dictionaries</p><p>传递给<code>plt.scatter</code>and 的 其他关键字参数<code>plt.plot</code>。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>绘制 DataFrame 中两个变量之间的关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.set_theme(color_codes=<span class="literal">True</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">ax = sns.regplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-1.png"></p><p>绘制两个变量定义为 numpy 数组；使用不同的颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np; np.random.seed(<span class="number">8</span>)</span><br><span class="line">mean, cov = [<span class="number">4</span>, <span class="number">6</span>], [(<span class="number">1.5</span>, <span class="number">.7</span>), (<span class="number">.7</span>, <span class="number">1</span>)]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">80</span>).T</span><br><span class="line">ax = sns.regplot(x=x, y=y, color=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-2.png"></p><p>绘制两个变量定义为熊猫系列；使用不同的标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">x, y = pd.Series(x, name=<span class="string">&quot;x_var&quot;</span>), pd.Series(y, name=<span class="string">&quot;y_var&quot;</span>)</span><br><span class="line">ax = sns.regplot(x=x, y=y, marker=<span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-3.png"></p><p>使用 68% 置信区间，它对应于估计的标准误差，并将回归线扩展到轴限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=x, y=y, ci=<span class="number">68</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-4.png"></p><p>用离散<code>x</code>变量绘图并添加一些抖动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=<span class="string">&quot;size&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips, x_jitter=<span class="number">.1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-5.png"></p><p>用离散<code>x</code>变量绘图，显示唯一值的均值和置信区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=<span class="string">&quot;size&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,</span><br><span class="line"><span class="meta">... </span>                 x_estimator=np.mean)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-6.png"></p><p>将连续变量划分为离散区间的绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=x, y=y, x_bins=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-7.png"></p><p>拟合高阶多项式回归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans = sns.load_dataset(<span class="string">&quot;anscombe&quot;</span>)</span><br><span class="line">ax = sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=ans.loc[ans.dataset == <span class="string">&quot;II&quot;</span>],</span><br><span class="line"><span class="meta">... </span>                 scatter_kws=&#123;<span class="string">&quot;s&quot;</span>: <span class="number">80</span>&#125;,</span><br><span class="line"><span class="meta">... </span>                 order=<span class="number">2</span>, ci=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-8.png"></p><p>拟合稳健回归并且不绘制置信区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=ans.loc[ans.dataset == <span class="string">&quot;III&quot;</span>],</span><br><span class="line"><span class="meta">... </span>                 scatter_kws=&#123;<span class="string">&quot;s&quot;</span>: <span class="number">80</span>&#125;,</span><br><span class="line"><span class="meta">... </span>                 robust=<span class="literal">True</span>, ci=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-9.png"></p><p>拟合逻辑回归；抖动 y 变量并使用更少的引导迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips[<span class="string">&quot;big_tip&quot;</span>] = (tips.tip / tips.total_bill) &gt; <span class="number">.175</span></span><br><span class="line">ax = sns.regplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;big_tip&quot;</span>, data=tips,</span><br><span class="line"><span class="meta">... </span>                 logistic=<span class="literal">True</span>, n_boot=<span class="number">500</span>, y_jitter=<span class="number">.03</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-10.png"></p><p>使用 log(x) 拟合回归模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.regplot(x=<span class="string">&quot;size&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,</span><br><span class="line"><span class="meta">... </span>                 x_estimator=np.mean, logx=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-regplot-111.png"></p><p>&nbsp;</p><h2 id="seaborn-residplot"><a href="#seaborn-residplot" class="headerlink" title="seaborn.residplot"></a>seaborn.residplot</h2><p>绘制线性回归的残差。</p><p>此函数将 y 对 x 进行回归（可能作为稳健回归或多项式回归），然后绘制残差的散点图。您可以选择将 Lowess 平滑器拟合到残差图，这有助于确定残差是否存在结构。</p><div class="note blue no-icon flat"><p>也可以看看</p><ul><li><p><a href="http://seaborn.pydata.org/generated/seaborn.regplot.html#seaborn.regplot"><code>regplot</code></a></p><p>绘制一个简单的线性回归模型。</p></li><li><p><a href="http://seaborn.pydata.org/generated/seaborn.jointplot.html#seaborn.jointplot"><code>jointplot</code></a></p><p>绘制<a href="http://seaborn.pydata.org/generated/seaborn.residplot.html#seaborn.residplot"><code>residplot()</code></a>具有单变量边缘分布的 a（与 一起使用时<code>kind=&quot;resid&quot;</code>）。</p></li></ul></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">residplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>x</strong>  vector or string</p><p><code>data</code>预测变量的数据或列名称。</p><p><strong>y</strong>  vector or string</p><p><code>data</code>响应变量的数据或列名称。</p><p><strong>data</strong>  DataFrame, optional</p><p>如果<code>x</code>和<code>y</code>是列名，则使用 DataFrame 。</p><p><strong>lowess</strong>  boolean, optional</p><p>为残差散点图拟合一个 lowess 平滑器。</p><p><strong>{x, y}_partial</strong>  matrix or string(s) , optional</p><p>第一维与<code>x</code>或 中的列名称相同的矩阵<code>data</code>。这些变量被视为混杂变量，并在绘图前从<code>x</code>或<code>y</code>变量中删除。</p><p><strong>order</strong>  int, optional</p><p>计算残差时要拟合的多项式的顺序。</p><p><strong>robust</strong>  boolean, optional</p><p>在计算残差时拟合稳健的线性回归。</p><p><strong>dropna</strong>  boolean, optional</p><p>如果为 True，则在拟合和绘图时忽略缺失数据的观察。</p><p><strong>label</strong>  string, optional</p><p>将在任何情节图例中使用的标签。</p><p><strong>color</strong>  matplotlib color, optional</p><p>用于绘图的所有元素的颜色。</p><p><strong>{scatter, line}_kws</strong>  dictionaries, optional</p><p>传递给 scatter() 和 plot() 的其他关键字参数用于绘制绘图的组件。</p><p><strong>ax</strong>  matplotlib axis, optional</p><p>绘制到此轴上，否则抓取当前轴或创建一个新轴（如果不存在）。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn Distribution plots</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Distribution-plots/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Distribution-plots/</id>
    <published>2021-06-14T04:35:55.000Z</published>
    <updated>2021-06-14T14:22:18.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Distribution-plots"><a href="#Distribution-plots" class="headerlink" title="Distribution plots"></a>Distribution plots</h1><h2 id="seaborn-displot"><a href="#seaborn-displot" class="headerlink" title="seaborn.displot"></a>seaborn.displot</h2><p>用于在 FacetGrid 上绘制分布图的图形级界面。</p><p>该函数提供了对数据单变量或双变量分布可视化的几种方法的访问，包括由跨多个子图的语义映射和分面定义的数据子集。该 <code>kind</code>参数选择使用的方法：</p><div class="note blue no-icon flat"><p>分类散点图：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.histplot.html#seaborn.histplot"><code>histplot()</code></a>（使用<code>kind=&quot;hist&quot;</code>; 默认值）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>kdeplot()</code></a>（与<code>kind=&quot;kde&quot;</code>）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.ecdfplot.html#seaborn.ecdfplot"><code>ecdfplot()</code></a>（与<code>kind=&quot;ecdf&quot;</code>; 仅单变量）</li></ul></div><p>此外，<a href="http://seaborn.pydata.org/generated/seaborn.rugplot.html#seaborn.rugplot"><code>rugplot()</code></a>可以将 a 添加到任何类型的图中以显示单个观察结果。</p><p>额外的关键字参数会传递给底层函数，因此您应该参考每个参数的文档以了解使用此接口制作绘图的完整选项集。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">displot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>hue</strong>  vector or key in <code>data</code></p><p>被映射以确定绘图元素颜色的语义变量。</p><p><strong>row, col</strong>  vectors or keys in <code>data</code></p><p>定义子集以在不同方面绘制的变量。</p><p><strong>kind</strong>  {“hist”, “kde”, “ecdf”}</p><p>可视化数据的方法。选择基础绘图函数并确定附加的有效参数集。</p><p><strong>rug</strong>  bool</p><p>如果为 True，则显示带有边缘刻度的每个观察结果（如 中所示<a href="http://seaborn.pydata.org/generated/seaborn.rugplot.html#seaborn.rugplot"><code>rugplot()</code></a>）。</p><p><strong>rug_kws</strong>  dict</p><p>控制地毯图外观的参数。</p><p><strong>log_scale</strong>  bool or number, or pair of bools or numbers</p><p>使用给定的基数（默认为 10）在数据轴（或轴，带有双变量数据）上设置对数刻度，并在对数空间中评估 KDE。</p><p><strong>legend</strong>  bool</p><p>如果为 False，则取消语义变量的图例。</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>color</strong>  <a href="https://matplotlib.org/api/colors_api.html#module-matplotlib.colors"><code>matplotlib color</code></a></p><p>不使用色调映射时的单色规范。否则，绘图将尝试挂钩到 matplotlib 属性循环。</p><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p><p><strong>{row,col}_order</strong>  vector of strings</p><p>指定子图网格中出现<code>row</code>和/或<code>col</code>变量的级别的顺序。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p><p><strong>facet_kws</strong>  dict</p><p>传递给<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>.</p><p><strong>kwargs</strong></p><p>其他关键字参数与相关的轴级函数一起记录：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.histplot.html#seaborn.histplot"><code>histplot()</code></a> (with <code>kind=&quot;hist&quot;</code>)</li><li><a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>kdeplot()</code></a> (with <code>kind=&quot;kde&quot;</code>)</li><li><a href="http://seaborn.pydata.org/generated/seaborn.ecdfplot.html#seaborn.ecdfplot"><code>ecdfplot()</code></a> (with <code>kind=&quot;ecdf&quot;</code>)</li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>默认绘图类型是直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_1_0.png"></p><p>使用<code>kind</code>参数选择不同的表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_3_0.png"></p><p>有三种主要的情节类型；除了直方图和核密度估计 (KDE)，您还可以绘制经验累积分布函数 (ECDF)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, kind=<span class="string">&quot;ecdf&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_5_0.png"></p><p>在直方图模式下，还可以添加 KDE 曲线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, kde=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_7_0.png"></p><p>要绘制双变量图，请同时分配<code>x</code>和<code>y</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, y=<span class="string">&quot;bill_length_mm&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_9_0.png"></p><p>目前，二元图仅适用于直方图和 KDE：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, y=<span class="string">&quot;bill_length_mm&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_11_0.png"></p><p>对于每种图，您还可以使用边缘“地毯”显示单个观察结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, y=<span class="string">&quot;bill_length_mm&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>, rug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_13_0.png"></p><p>可以使用<code>hue</code>映射为数据子集分别绘制每种图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_15_0.png"></p><p>额外的关键字参数被传递给适当的底层绘图函数，允许进一步定制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, multiple=<span class="string">&quot;stack&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_17_0.png"></p><p>该图是使用 a 构建的<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>，这意味着您还可以在不同的子图或“方面”上显示子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, col=<span class="string">&quot;sex&quot;</span>, kind=<span class="string">&quot;kde&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_19_0.png"></p><p>由于图形是用 a 绘制的<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>，因此您可以使用<code>height</code>和<code>aspect</code>参数控制其大小和形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.displot(</span><br><span class="line">    data=penguins, y=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;species&quot;</span>,</span><br><span class="line">    kind=<span class="string">&quot;ecdf&quot;</span>, height=<span class="number">4</span>, aspect=<span class="number">.7</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_21_0.png"></p><p>该函数返回<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>带有绘图的对象，您可以使用此对象上的方法进一步自定义它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g = sns.displot(</span><br><span class="line">    data=penguins, y=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, col=<span class="string">&quot;species&quot;</span>,</span><br><span class="line">    kind=<span class="string">&quot;kde&quot;</span>, height=<span class="number">4</span>, aspect=<span class="number">.7</span>,</span><br><span class="line">)</span><br><span class="line">g.set_axis_labels(<span class="string">&quot;Density (a.u.)&quot;</span>, <span class="string">&quot;Flipper length (mm)&quot;</span>)</span><br><span class="line">g.set_titles(<span class="string">&quot;&#123;col_name&#125; penguins&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/displot_23_0.png"></p><p>&nbsp;</p><h2 id="seaborn-histplot"><a href="#seaborn-histplot" class="headerlink" title="seaborn.histplot"></a>seaborn.histplot</h2><p>绘制单变量或双变量直方图以显示数据集的分布。</p><p>直方图是一种经典的可视化工具，它通过计算离散区间内的观测数量来表示一个或多个变量的分布。</p><p>此函数可以对每个 bin 内计算的统计量进行归一化以估计频率、密度或概率质量，并且可以添加使用核密度估计获得的平滑曲线，类似于<a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>kdeplot()</code></a>。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">displot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>hue</strong>  vector or key in <code>data</code></p><p>被映射以确定绘图元素颜色的语义变量。</p><p><strong>weights</strong>  vector or key in <code>data</code></p><p>如果提供，则通过这些因素对相应数据点对每个 bin 中的计数的贡献进行加权。</p><p><strong>stat</strong>  {“count”, “frequency”, “density”, “probability”}</p><p>要在每个 bin 中计算的聚合统计数据。</p><ul><li><code>count</code> shows the number of observations</li><li><code>frequency</code> shows the number of observations divided by the bin width</li><li><code>density</code> normalizes counts so that the area of the histogram is 1</li><li><code>probability</code> normalizes counts so that the sum of the bar heights is 1</li></ul><p><strong>bins</strong>  str, number, vector, or a pair of such values</p><p>通用 bin 参数，可以是引用规则的名称、bin 的数量或 bin 的中断。传递给<a href="https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bin_edges"><code>numpy.histogram_bin_edges()</code></a>.</p><p><strong>binwidth</strong>  number or pair of numbers</p><p>每个 bin 的宽度，覆盖<code>bins</code>但可以与 <code>binrange</code>.</p><p><strong>binrange</strong>  pair of numbers or a pair of pairs</p><p>bin 边缘的最低和最高值；可以与<code>bins</code>或一起使用<code>binwidth</code>。默认为数据极值。</p><p><strong>discrete</strong>  bool</p><p>如果为 True，则默认为<code>binwidth=1</code>并绘制条形，使它们以相应的数据点为中心。这避免了使用离散（整数）数据时可能出现的“间隙”。</p><p><strong>cumulative</strong>  bool</p><p>如果为 True，则在 bin 增加时绘制累积计数。</p><p><strong>common_bins</strong>  bool</p><p>如果为 True，则在语义变量产生多个图时使用相同的 bin。如果使用参考规则来确定 bin，则将使用完整数据集进行计算。</p><p><strong>common_norm</strong>  bool</p><p>如果为 True 并使用归一化统计，归一化将应用于整个数据集。否则，独立标准化每个直方图。</p><p><strong>multiple</strong>  {“layer”, “dodge”, “stack”, “fill”}</p><p>语义映射创建子集时解析多个元素的方法。仅与单变量数据相关。</p><p><strong>element</strong>  {“bars”, “step”, “poly”}</p><p>直方图统计的可视化表示。仅与单变量数据相关。</p><p><strong>fill</strong>  bool</p><p>如果为 True，则填充直方图下方的空间。仅与单变量数据相关。</p><p><strong>shrink</strong>  number</p><p>通过这个因子相对于 binwidth 缩放每个条的宽度。仅与单变量数据相关。</p><p><strong>kde</strong>  bool</p><p>如果为 True，计算核密度估计以平滑分布并在图上显示为（一条或多条）线。仅与单变量数据相关。</p><p><strong>kde_kws</strong>  dict</p><p>控制 KDE 计算的参数，如<a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>kdeplot()</code></a>.</p><p><strong>line_kws</strong>  dict</p><p>控制 KDE 可视化的参数，传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot"><code>matplotlib.axes.Axes.plot()</code></a>.</p><p><strong>thresh</strong>  number or None</p><p>统计数据小于或等于此值的单元格将是透明的。仅与双变量数据相关。</p><p><strong>pthresh</strong>  number or None</p><p>类似<code>thresh</code>，但在 [0, 1] 中的值使得聚合计数（或其他统计信息，当使用时）达到总数的这一比例的单元格将是透明的。</p><p><strong>pmax</strong>  number or None</p><p>[0, 1] 中的一个值将颜色图的饱和点设置为一个值，使得下面的单元格构成总计数的这个比例（或其他统计数据，当使用时）。</p><p><strong>cbar</strong>  bool</p><p>如果为 True，则添加颜色条以注释双变量图中的颜色映射。注意：目前不支持带有<code>hue</code>变量井的图。</p><p><strong>cbar_ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>颜色条的预先存在的轴。</p><p><strong>cbar_kws</strong>  dict</p><p>传递给<a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.colorbar"><code>matplotlib.figure.Figure.colorbar()</code></a>.</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>color</strong>  <a href="https://matplotlib.org/api/colors_api.html#module-matplotlib.colors"><code>matplotlib color</code></a></p><p>不使用色调映射时的单色规范。否则，绘图将尝试挂钩到 matplotlib 属性循环。</p><p><strong>log_scale</strong>  bool or number, or pair of bools or numbers</p><p>使用给定的基数（默认为 10）在数据轴（或轴，带有双变量数据）上设置对数刻度，并在对数空间中评估 KDE。</p><p><strong>legend</strong>  bool</p><p>如果为 False，则取消语义变量的图例。</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>kwargs</strong></p><p>其他关键字参数传递给以下 matplotlib 函数之一：</p><ul><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar"><code>matplotlib.axes.Axes.bar()</code></a> (单变量, element=”bars”)</li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.fill_between.html#matplotlib.axes.Axes.fill_between"><code>matplotlib.axes.Axes.fill_between()</code></a> (单变量,其他元素, fill=True)</li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot"><code>matplotlib.axes.Axes.plot()</code></a> (单变量,其他元素, fill=False)</li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.pcolormesh.html#matplotlib.axes.Axes.pcolormesh"><code>matplotlib.axes.Axes.pcolormesh()</code></a> (二元)</li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>分配一个变量以<code>x</code>绘制沿 x 轴的单变量分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penguins &#x3D; sns.load_dataset(&quot;penguins&quot;)</span><br><span class="line">sns.histplot(data&#x3D;penguins, x&#x3D;&quot;flipper_length_mm&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_1_0.png"></p><p>通过将数据变量分配给 y 轴来翻转绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, y=<span class="string">&quot;flipper_length_mm&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_3_0.png"></p><p>通过指定不同的 bin 宽度来检查直方图表示数据的程度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, binwidth=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_5_0.png"></p><p>您还可以定义要使用的 bin 总数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, bins=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_7_0.png"></p><p>添加核密度估计以平滑直方图，提供有关分布形状的补充信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, kde=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_9_0.png"></p><p>如果既不赋值<code>x</code>也不<code>y</code>赋值，则数据集被视为宽格式，并为每个数字列绘制直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_11_0.png"></p><p>否则，您可以使用色调映射从长格式数据集中绘制多个直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_13_0.png"></p><p>绘制多个分布的默认方法是“分层”它们，但您也可以“堆叠”它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, multiple=<span class="string">&quot;stack&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_15_0.png"></p><p>重叠的条形可能很难在视觉上解决。另一种方法是绘制阶跃函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, element=<span class="string">&quot;step&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_17_0.png"></p><p>您可以通过绘制一个顶点位于每个条柱中心的多边形来进一步远离条形图。这可能会让您更容易看到分布的形状，但请谨慎使用：您的观众不会那么明显地看到他们正在查看直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, element=<span class="string">&quot;poly&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_19_0.png"></p><p>要比较大小差异很大的子集的分布，请使用独立密度归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    penguins, x=<span class="string">&quot;bill_length_mm&quot;</span>, hue=<span class="string">&quot;island&quot;</span>, element=<span class="string">&quot;step&quot;</span>,</span><br><span class="line">    stat=<span class="string">&quot;density&quot;</span>, common_norm=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_21_0.png"></p><p>也可以进行归一化，以便每个条形的高度显示概率，这对于离散变量更有意义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">sns.histplot(data=tips, x=<span class="string">&quot;size&quot;</span>, stat=<span class="string">&quot;probability&quot;</span>, discrete=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_23_0.png"></p><p>您甚至可以在分类变量上绘制直方图（尽管这是一项实验性功能）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=tips, x=<span class="string">&quot;day&quot;</span>, shrink=<span class="number">.8</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_25_0.png"></p><p>当<code>hue</code>对离散数据使用语义时，“躲避”级别是有意义的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=tips, x=<span class="string">&quot;day&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, multiple=<span class="string">&quot;dodge&quot;</span>, shrink=<span class="number">.8</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_27_0.png"></p><p>现实世界的数据往往是有偏差的。对于严重偏斜的分布，最好在日志空间中定义 bin。比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">planets = sns.load_dataset(<span class="string">&quot;planets&quot;</span>)</span><br><span class="line">sns.histplot(data=planets, x=<span class="string">&quot;distance&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_29_0.png"></p><p>对数刻度版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=planets, x=<span class="string">&quot;distance&quot;</span>, log_scale=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_31_0.png"></p><p>对于直方图的显示方式，还有许多选项。您可以显示未填充的条形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=planets, x=<span class="string">&quot;distance&quot;</span>, log_scale=<span class="literal">True</span>, fill=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_33_0.png"></p><p>或者一个未填充的阶跃函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=planets, x=<span class="string">&quot;distance&quot;</span>, log_scale=<span class="literal">True</span>, element=<span class="string">&quot;step&quot;</span>, fill=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_35_0.png"></p><p>阶梯函数，尤其是在未填充时，可以轻松比较累积直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    data=planets, x=<span class="string">&quot;distance&quot;</span>, hue=<span class="string">&quot;method&quot;</span>,</span><br><span class="line">    hue_order=[<span class="string">&quot;Radial Velocity&quot;</span>, <span class="string">&quot;Transit&quot;</span>],</span><br><span class="line">    log_scale=<span class="literal">True</span>, element=<span class="string">&quot;step&quot;</span>, fill=<span class="literal">False</span>,</span><br><span class="line">    cumulative=<span class="literal">True</span>, stat=<span class="string">&quot;density&quot;</span>, common_norm=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_37_0.png"></p><p>当<code>x</code>和<code>y</code>都被赋值时，一个二元直方图被计算并显示为热图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(penguins, x=<span class="string">&quot;bill_depth_mm&quot;</span>, y=<span class="string">&quot;body_mass_g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_39_0.png"></p><p>也可以分配一个<code>hue</code>变量，但如果来自不同级别的数据有大量重叠，这将无法正常工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(penguins, x=<span class="string">&quot;bill_depth_mm&quot;</span>, y=<span class="string">&quot;body_mass_g&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_41_0.png"></p><p>当其中一个变量是离散的时，多个颜色图才有意义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    penguins, x=<span class="string">&quot;bill_depth_mm&quot;</span>, y=<span class="string">&quot;species&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, legend=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_43_0.png"></p><p>双变量直方图接受所有与其单变量对应项相同的计算选项，使用元组进行参数化<code>x</code>和 <code>y</code>独立：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    planets, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;distance&quot;</span>,</span><br><span class="line">    bins=<span class="number">30</span>, discrete=(<span class="literal">True</span>, <span class="literal">False</span>), log_scale=(<span class="literal">False</span>, <span class="literal">True</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_45_0.png"></p><p>默认行为使没有观察的单元格透明，尽管这可以禁用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    planets, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;distance&quot;</span>,</span><br><span class="line">    bins=<span class="number">30</span>, discrete=(<span class="literal">True</span>, <span class="literal">False</span>), log_scale=(<span class="literal">False</span>, <span class="literal">True</span>),</span><br><span class="line">    thresh=<span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_47_0.png"></p><p>也可以根据累积计数的比例设置阈值和颜色图饱和点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    planets, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;distance&quot;</span>,</span><br><span class="line">    bins=<span class="number">30</span>, discrete=(<span class="literal">True</span>, <span class="literal">False</span>), log_scale=(<span class="literal">False</span>, <span class="literal">True</span>),</span><br><span class="line">    pthresh=<span class="number">.05</span>, pmax=<span class="number">.9</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_49_0.png"></p><p>要注释颜色图，请添加颜色条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(</span><br><span class="line">    planets, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;distance&quot;</span>,</span><br><span class="line">    bins=<span class="number">30</span>, discrete=(<span class="literal">True</span>, <span class="literal">False</span>), log_scale=(<span class="literal">False</span>, <span class="literal">True</span>),</span><br><span class="line">    cbar=<span class="literal">True</span>, cbar_kws=<span class="built_in">dict</span>(shrink=<span class="number">.75</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/histplot_51_0.png"></p><p>&nbsp;</p><h2 id="seaborn-kdeplot"><a href="#seaborn-kdeplot" class="headerlink" title="seaborn.kdeplot"></a>seaborn.kdeplot</h2><p>使用核密度估计绘制单变量或双变量分布。</p><p>核密度估计 (KDE) 图是一种可视化数据集中观测值分布的方法，类似于直方图。KDE 使用一维或多维的连续概率密度曲线表示数据。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>shade</strong>  bool</p><p>Alias for <code>fill</code>. Using <code>fill</code> is recommended.</p><p><strong>vertical</strong>  bool</p><p><em>0.11.0 版后已弃用：</em>通过分配<code>x</code>或<code>y</code>变量来指定方向。</p><p><strong>kernel</strong>  str</p><p>定义内核的函数。</p><p><em>自 0.11.0 版后已弃用：</em>已删除对非高斯内核的支持。</p><p><strong>bw</strong>  str, number, or callable</p><p>平滑参数。</p><p><em>自 0.11.0 版起已弃用：</em>请参阅<code>bw_method</code>和<code>bw_adjust</code>。</p><p><strong>gridsize</strong>  int</p><p>评估网格每个维度上的点数。</p><p><strong>cut</strong>  number, optional</p><p>因子乘以平滑带宽，确定评估网格延伸超过极端数据点的程度。设置为 0 时，在数据限制处截断曲线。</p><p><strong>clip</strong>  pair of numbers None, or a pair of such pairs</p><p>不要评估超出这些限制的密度。</p><p><strong>legend</strong>  bool</p><p>如果为 False，则取消语义变量的图例。</p><p><strong>cumulative</strong>  bool, optional</p><p>如果为 True，则估计累积分布函数。</p><p><strong>shade_lowest</strong>  bool</p><p>如果为 False，则最低轮廓下方的区域将是透明的</p><p><em>自 0.11.0 版起已弃用：</em>请参阅<code>thresh</code>.</p><p><strong>cbar</strong>  bool</p><p>如果为 True，则添加颜色条以注释双变量图中的颜色映射。注意：目前不支持带有<code>hue</code>变量井的图。</p><p><strong>cbar_ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>如果为 True，则添加颜色条以注释双变量图中的颜色映射。注意：目前不支持带有<code>hue</code>变量井的图。</p><p><strong>cbar_kws</strong>  dict</p><p>传递给<a href="https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.colorbar"><code>matplotlib.figure.Figure.colorbar()</code></a>.</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>weights</strong>  vector or key in <code>data</code></p><p>如果提供，请使用这些值对内核密度估计进行加权。</p><p><strong>hue</strong>  vector or key in <code>data</code></p><p>被映射以确定绘图元素颜色的语义变量。</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>multiple</strong>  {“layer”, “stack”, “fill”}</p><p>语义映射创建子集时绘制多个元素的方法。仅与单变量数据相关。</p><p>**common_norm ** bool</p><p>如果为 True，则按观察次数缩放每个条件密度，使得所有密度下的总面积总和为 1。否则，独立标准化每个密度。</p><p><strong>common_grid</strong>  bool</p><p>如果为 True，则对每个内核密度估计使用相同的评估网格。仅与单变量数据相关。</p><p><strong>levels</strong>  int or vector</p><p>要绘制等高线的等高线级别或值的数量。向量参数必须在 [0, 1] 中具有递增的值。级别对应于密度的等比例：例如，20% 的概率质量将位于为 0.2 绘制的等高线下方。仅与双变量数据相关。</p><p><strong>thresh</strong>  number in [0, 1]</p><p>绘制等高线的最低等比例水平。当<code>levels</code>是向量时忽略 。仅与双变量数据相关。</p><p><strong>bw_method</strong>  string, scalar, or callable, optional</p><p>确定要使用的平滑带宽的方法；传递给 <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde"><code>scipy.stats.gaussian_kde</code></a>.</p><p><strong>bw_adjust</strong>  number, optional</p><p>乘法缩放使用 选择的值的因子 <code>bw_method</code>。增加将使曲线更平滑。见注释。</p><p><strong>log_scale</strong>  bool or number, or pair of bools or numbers</p><p>使用给定的基数（默认为 10）在数据轴（或轴，带有双变量数据）上设置对数刻度，并在对数空间中评估 KDE。</p><p><strong>color</strong>  <a href="https://matplotlib.org/api/colors_api.html#module-matplotlib.colors"><code>matplotlib color</code></a></p><p>不使用色调映射时的单色规范。否则，绘图将尝试挂钩到 matplotlib 属性循环。</p><p><strong>fill</strong>  bool or None</p><p>如果为 True，则填充单变量密度曲线下或双变量轮廓之间的区域。如果没有，默认值取决于<code>multiple</code>.</p><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><strong>kwargs</strong></p><p>其他关键字参数传递给以下 matplotlib 函数之一：</p><ul><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot"><code>matplotlib.axes.Axes.plot()</code></a> (univariate, <code>fill=False</code>),</li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.fill_between.html#matplotlib.axes.Axes.fill_between"><code>matplotlib.axes.Axes.fill_between()</code></a> (univariate, <code>fill=True</code>),</li><li><a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.contour.html#matplotlib.axes.Axes.contour"><code>matplotlib.axes.Axes.contour()</code></a> (bivariate, <code>fill=False</code>),</li><li><code>matplotlib.axes.contourf()</code> (bivariate, <code>fill=True</code>).</li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><p>沿 x 轴绘制单变量分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_1_0.png"></p><p>通过将数据变量分配给 y 轴来翻转绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, y=<span class="string">&quot;total_bill&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_3_0.png"></p><p>为宽格式数据集的每一列绘制分布图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line">sns.kdeplot(data=iris)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_5_0.png"></p><p>使用较少的平滑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, bw_adjust=<span class="number">.2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_7_0.png"></p><p>使用更多平滑，但不要平滑超过极端数据点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax= sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, bw_adjust=<span class="number">5</span>, cut=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_9_0.png"></p><p>使用第二个变量的色调映射绘制条件分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_11_0.png"></p><p>“堆叠”条件分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>, multiple=<span class="string">&quot;stack&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_13_0.png"></p><p>对网格中每个值的堆叠分布进行归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>, multiple=<span class="string">&quot;fill&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_15_0.png"></p><p>估计累积分布函数，对每个子集进行归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">    data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>,</span><br><span class="line">    cumulative=<span class="literal">True</span>, common_norm=<span class="literal">False</span>, common_grid=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_17_0.png"></p><p>使用权重从聚合数据估计分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tips_agg = (tips</span><br><span class="line">    .groupby(<span class="string">&quot;size&quot;</span>)</span><br><span class="line">    .agg(total_bill=(<span class="string">&quot;total_bill&quot;</span>, <span class="string">&quot;mean&quot;</span>), n=(<span class="string">&quot;total_bill&quot;</span>, <span class="string">&quot;count&quot;</span>))</span><br><span class="line">)</span><br><span class="line">sns.kdeplot(data=tips_agg, x=<span class="string">&quot;total_bill&quot;</span>, weights=<span class="string">&quot;n&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_19_0.png"></p><p>使用对数缩放映射数据变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diamonds = sns.load_dataset(<span class="string">&quot;diamonds&quot;</span>)</span><br><span class="line">sns.kdeplot(data=diamonds, x=<span class="string">&quot;price&quot;</span>, log_scale=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_21_0.png"></p><p>使用数字色调映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;size&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_23_0.png"></p><p>修改情节的外观：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">   data=tips, x=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;size&quot;</span>,</span><br><span class="line">   fill=<span class="literal">True</span>, common_norm=<span class="literal">False</span>, palette=<span class="string">&quot;crest&quot;</span>,</span><br><span class="line">   alpha=<span class="number">.5</span>, linewidth=<span class="number">0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_25_0.png"></p><p>绘制二元分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geyser = sns.load_dataset(<span class="string">&quot;geyser&quot;</span>)</span><br><span class="line">sns.kdeplot(data=geyser, x=<span class="string">&quot;waiting&quot;</span>, y=<span class="string">&quot;duration&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_27_0.png"></p><p>使用色调语义映射第三个变量以显示条件分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(data=geyser, x=<span class="string">&quot;waiting&quot;</span>, y=<span class="string">&quot;duration&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_29_0.png"></p><p>显示填充轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">    data=geyser, x=<span class="string">&quot;waiting&quot;</span>, y=<span class="string">&quot;duration&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>, fill=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_31_0.png"></p><p>显示更少的轮廓级别，覆盖更少的分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">    data=geyser, x=<span class="string">&quot;waiting&quot;</span>, y=<span class="string">&quot;duration&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>,</span><br><span class="line">    levels=<span class="number">5</span>, thresh=<span class="number">.2</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_33_0.png"></p><p>使用不同的颜色图以平滑分布填充轴范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(</span><br><span class="line">    data=geyser, x=<span class="string">&quot;waiting&quot;</span>, y=<span class="string">&quot;duration&quot;</span>,</span><br><span class="line">    fill=<span class="literal">True</span>, thresh=<span class="number">0</span>, levels=<span class="number">100</span>, cmap=<span class="string">&quot;mako&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/kdeplot_35_0.png"></p><p>&nbsp;</p><h2 id="seaborn-ecdfplot"><a href="#seaborn-ecdfplot" class="headerlink" title="seaborn.ecdfplot"></a>seaborn.ecdfplot</h2><p>绘制经验累积分布函数。</p><p>ECDF 表示低于数据集中每个唯一值的观测值的比例或计数。与直方图或密度图相比，它的优点是每个观察结果都是直接可视化的，这意味着不需要调整分箱或平滑参数。它还有助于在多个分布之间进行直接比较。缺点是图的外观与分布的基本属性（例如其集中趋势、方差和任何双峰性的存在）之间的关系可能不那么直观。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><strong>x, y</strong>  vectors or keys in <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>hue</strong>  vector or key in <code>data</code></p><p>被映射以确定绘图元素颜色的语义变量。</p><p><strong>weights</strong>  vector or key in <code>data</code></p><p>如果提供，则使用这些值对相应数据点对累积分布的贡献进行加权。</p><p><strong>stat</strong>  {“proportion”, “count”}</p><p>要计算的分布统计量。</p><p><strong>complementary</strong>  bool</p><p>如果为 True，则使用互补 CDF (1 - CDF)</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>log_scale</strong>  bool or number, or pair of bools or numbers</p><p>使用给定的基数（默认为 10）在数据轴（或轴，带有双变量数据）上设置对数刻度，并在对数空间中评估 KDE。</p><p><strong>legend</strong>  bool</p><p>如果为 False，则取消语义变量的图例。</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>kwargs</strong></p><p>其他关键字参数传递给matplotlib.axes.Axes.plot().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h3><p>沿 x 轴绘制单变量分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">sns.ecdfplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_1_0.png"></p><p>通过将数据变量分配给 y 轴来翻转绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.ecdfplot(data=penguins, y=<span class="string">&quot;flipper_length_mm&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_3_0.png"></p><p>如果既不赋值<code>x</code>也不<code>y</code>赋值，则数据集被视为宽格式，并为每个数字列绘制直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.ecdfplot(data=penguins.<span class="built_in">filter</span>(like=<span class="string">&quot;bill_&quot;</span>, axis=<span class="string">&quot;columns&quot;</span>))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_5_0.png"></p><p>您还可以使用色调映射从长格式数据集中绘制多个直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.ecdfplot(data=penguins, x=<span class="string">&quot;bill_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_7_0.png"></p><p>默认分布统计量被归一化以显示比例，但您可以改为显示绝对计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.ecdfplot(data=penguins, x=<span class="string">&quot;bill_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, stat=<span class="string">&quot;count&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_9_0.png"></p><p>也可以绘制经验互补 CDF (1 - CDF)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.ecdfplot(data=penguins, x=<span class="string">&quot;bill_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, complementary=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/ecdfplot_11_0.png"></p><p>&nbsp;</p><h2 id="seaborn-rugplot"><a href="#seaborn-rugplot" class="headerlink" title="seaborn.rugplot"></a>seaborn.rugplot</h2><p>通过沿 x 和 y 轴绘制刻度来绘制边缘分布。</p><p>此功能旨在通过以不显眼的方式显示单个观察的位置来补充其他图。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">kdeplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>x, y</strong>  vectors or keys in <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>height</strong>  number</p><p>每个地毯元素覆盖的轴范围的比例。</p><p><strong>axis</strong>  {“x”, “y”}</p><p>绘制地毯的轴。</p><p><em>0.11.0 版后已弃用：</em>通过分配<code>x</code>或<code>y</code>变量来指定轴。</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p>**hue ** vector or key in <code>data</code></p><p>被映射以确定绘图元素颜色的语义变量。</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>expand_margins</strong>  bool</p><p>如果为 True，则将轴边距增加地毯的高度以避免与其他元素重叠。</p><p><strong>legend</strong>  bool</p><p>如果为 False，则不要为语义变量添加图例。</p><p><strong>kwargs</strong></p><p>其他关键字参数传递给matplotlib.axes.Axes.plot().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-4"><a href="#Examples-4" class="headerlink" title="Examples"></a>Examples</h3><p>沿其中一个轴添加地毯：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns; sns.set_theme()</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">sns.kdeplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>)</span><br><span class="line">sns.rugplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_1_0.png"></p><p>沿两个轴添加地毯：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br><span class="line">sns.rugplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_3_0.png"></p><p>用色调映射表示第三个变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">sns.rugplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_5_0.png"></p><p>画一个更高的地毯：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br><span class="line">sns.rugplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, height=<span class="number">.1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_7_0.png"></p><p>将地毯放在轴外：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br><span class="line">sns.rugplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, height=<span class="number">-.02</span>, clip_on=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_9_0.png"></p><p>使用细线和 alpha 混合显示较大数据集的密度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diamonds = sns.load_dataset(<span class="string">&quot;diamonds&quot;</span>)</span><br><span class="line">sns.scatterplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, y=<span class="string">&quot;price&quot;</span>, s=<span class="number">5</span>)</span><br><span class="line">sns.rugplot(data=diamonds, x=<span class="string">&quot;carat&quot;</span>, y=<span class="string">&quot;price&quot;</span>, lw=<span class="number">1</span>, alpha=<span class="number">.005</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/rugplot_11_0.png"></p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn Relational plots</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Relational-plots/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Relational-plots/</id>
    <published>2021-06-14T04:35:27.000Z</published>
    <updated>2021-06-14T14:18:16.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Relational-plots"><a href="#Relational-plots" class="headerlink" title="Relational plots"></a>Relational plots</h1><h2 id="seaborn-relplot"><a href="#seaborn-relplot" class="headerlink" title="seaborn.relplot"></a>seaborn.relplot</h2><p>用于在 FacetGrid 上绘制关系图的图形级界面。</p><p>此函数提供对几个不同轴级函数的访问，这些函数显示两个变量之间的关系以及子集的语义映射。该<code>kind</code>参数选择要使用的底层轴级函数：</p><div class="note blue no-icon flat"><p>分类散点图：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.scatterplot.html#seaborn.scatterplot"><code>scatterplot()</code></a>（使用<code>kind=&quot;scatter&quot;</code>; 默认值）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot"><code>lineplot()</code></a>（与<code>kind=&quot;line&quot;</code>）</li></ul></div><p>&nbsp;</p><p>额外的关键字参数会传递给底层函数，因此您应该参考每个参数的文档以查看特定于种类的选项。</p><p>之间的关系<code>x</code>和<code>y</code>可以使用显示的数据的不同子集<code>hue</code>，<code>size</code>和<code>style</code>参数。这些参数控制使用什么视觉语义来识别不同的子集。通过使用所有三种语义类型可以独立显示多达三个维度，但这种情节风格可能难以解释并且通常是无效的。使用冗余的语义（即两个 <code>hue</code>和<code>style</code>同一变量），可用于制作图形更容易帮助。</p><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">relplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><strong>hue</strong>  vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下表现不同。</p><p><strong>size</strong>  vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p><p><strong>style</strong>  vector or key in <code>data</code></p><p>将生成具有不同样式的元素的分组变量。可以有一个数字 dtype，但将始终被视为分类。</p><p><strong>data</strong>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><strong>row, col</strong>  vectors or keys in <code>data</code></p><p>定义子集以在不同方面绘制的变量。</p><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p><p><strong>row_order, col_order</strong>  lists of strings</p><p>组织网格的行和/或列的顺序，否则从数据对象推断顺序。</p><p><strong>palette</strong>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>sizes</strong>  list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p><p><strong>dashes</strong>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制线条的对象 。设置为<code>True</code>将使用默认破折号，或者您可以传递破折号列表或<code>style</code>变量的字典映射级别 到破折号。设置为<code>False</code>将对所有子集使用实线。破折号在 matplotlib 中指定：长度元组，或绘制实线的空字符串。<code>(segment, gap)</code></p><p><strong>markers</strong>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p><p><strong>legend</strong>  “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p><p><strong>kind</strong>  string</p><p>要绘制的图，对应于 seaborn 关系图。选项是 {<code>scatter</code>和<code>line</code>}。</p><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p><p><strong>facet_kws</strong>  dict</p><p>要传递给的其他关键字参数的字典<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。</p><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量识别抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。</p><p><strong>kwargs</strong>  key, value pairings</p><p>其他关键字参数将传递给底层绘图函数。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>这些示例将仅说明一些<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>能够实现的功能。有关详细信息，请参考实施例<a href="http://seaborn.pydata.org/generated/seaborn.scatterplot.html#seaborn.scatterplot"><code>scatterplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot"><code>lineplot()</code></a>，这是当使用<code>kind=&quot;scatter&quot;</code>或<code>kind=&quot;line&quot;</code>分别。</p><p>为了说明<code>kind=&quot;scatter&quot;</code>（绘图的默认样式），我们将使用“提示”数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br></pre></td></tr></table></figure><p>分配<code>x</code>和<code>y</code>和任何语义映射变量将绘制单个图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;day&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_4_0.png"></p><p>分配一个<code>col</code>变量会创建一个多面图，其中多个子图排列在网格的列中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;day&quot;</span>, col=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_6_0.png"></p><p>可以将不同的变量分配给列和行上的构面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;day&quot;</span>, col=<span class="string">&quot;time&quot;</span>, row=<span class="string">&quot;sex&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_8_0.png"></p><p>当分配给的变量<code>col</code>有多个级别时，它可以跨多行“包装”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;time&quot;</span>, col=<span class="string">&quot;day&quot;</span>, col_wrap=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_10_0.png"></p><p>分配多个语义变量可以显示多维关系，但要注意避免制作过于复杂的情节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, col=<span class="string">&quot;time&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;time&quot;</span>, size=<span class="string">&quot;size&quot;</span>, style=<span class="string">&quot;sex&quot;</span>,</span><br><span class="line">    palette=[<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>], sizes=(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_12_0.png"></p><p>当变量之一具有自然连续性时，显示线而不是点更有意义。要使用 绘制图形<a href="http://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot"><code>lineplot()</code></a>，请设置<code>kind=&quot;line&quot;</code>。我们将用“fmri 数据集”来说明这种效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmri = sns.load_dataset(<span class="string">&quot;fmri&quot;</span>)</span><br></pre></td></tr></table></figure><p>Using<code>kind=&quot;line&quot;</code>为语义映射提供了与 相同的灵活性<code>kind=&quot;scatter&quot;</code>，但<a href="http://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot"><code>lineplot()</code></a>在绘图之前对数据进行了更多的转换。观察<code>x</code>值按它们的值排序，重复的观察值被聚合。默认情况下，结果图显示每个单位的均值和 95% CI</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=fmri, x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, col=<span class="string">&quot;region&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>, kind=<span class="string">&quot;line&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_16_0.png"></p><p>图形的大小和形状由每个单独的刻面的<code>height</code>和<code>aspect</code>比率参数化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=fmri,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>, col=<span class="string">&quot;region&quot;</span>,</span><br><span class="line">    height=<span class="number">4</span>, aspect=<span class="number">.7</span>, kind=<span class="string">&quot;line&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_18_0.png"></p><p>返回的对象<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>始终是 a <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>，它有多种方法可以让您快速调整绘图的标题、标签和其他方面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g = sns.relplot(</span><br><span class="line">    data=fmri,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>, col=<span class="string">&quot;region&quot;</span>,</span><br><span class="line">    height=<span class="number">4</span>, aspect=<span class="number">.7</span>, kind=<span class="string">&quot;line&quot;</span></span><br><span class="line">)</span><br><span class="line">(g.<span class="built_in">map</span>(plt.axhline, y=<span class="number">0</span>, color=<span class="string">&quot;.7&quot;</span>, dashes=(<span class="number">2</span>, <span class="number">1</span>), zorder=<span class="number">0</span>)</span><br><span class="line">  .set_axis_labels(<span class="string">&quot;Timepoint&quot;</span>, <span class="string">&quot;Percent signal change&quot;</span>)</span><br><span class="line">  .set_titles(<span class="string">&quot;Region: &#123;col_name&#125; cortex&quot;</span>)</span><br><span class="line">  .tight_layout(w_pad=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_20_0.png"></p><p>也可以使用宽格式数据<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights_wide = sns.load_dataset(<span class="string">&quot;flights&quot;</span>).pivot(<span class="string">&quot;year&quot;</span>, <span class="string">&quot;month&quot;</span>, <span class="string">&quot;passengers&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这种情况下，分面不是一种选择，但情节仍将利用以下提供的外部图例<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(data=flights_wide, kind=<span class="string">&quot;line&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/relplot_24_0.png"></p><p>&nbsp;</p><h1 id="seaborn-scatterplot"><a href="#seaborn-scatterplot" class="headerlink" title="seaborn.scatterplot"></a>seaborn.scatterplot</h1><p>绘制具有多个语义分组可能性的散点图。</p><p>之间的关系<code>x</code>和<code>y</code>可以使用显示的数据的不同子集<code>hue</code>，<code>size</code>和<code>style</code>参数。这些参数控制使用什么视觉语义来识别不同的子集。通过使用所有三种语义类型可以独立显示多达三个维度，但这种情节风格可能难以解释并且通常是无效的。使用冗余的语义（即两个 <code>hue</code>和<code>style</code>同一变量），可用于制作图形更容易帮助。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">scatterplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><span style ="color:#FF6347"><strong>hue</strong> </span>  vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下表现不同。</p><p><strong>size</strong>  vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p><p><span style ="color:#FF6347"><strong>style</strong> </span>  vector or key in <code>data</code></p><p>将生成具有不同样式的元素的分组变量。可以有一个数字 dtype，但将始终被视为分类。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>sizes</strong>  list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p><p><span style ="color:#FF6347"><strong>markers</strong> </span>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p><p><strong>{x,y}_bins</strong>  lists or arrays or functions</p><p><em>目前无功能。</em></p><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量识别抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。 <em>目前无功能。</em></p><p><strong>estimator</strong>  name of pandas method or callable or None</p><p>聚合<code>y</code> 同一<code>x</code>级别变量的多个观察值的方法。如果<code>None</code>，则将绘制所有观察值。 <em>目前无功能。</em></p><p><span style ="color:#FF6347"><strong>ci</strong> </span>  int or “sd” or None</p><p>与估计器聚合时要绘制的置信区间的大小。“sd”表示绘制数据的标准偏差。设置为<code>None</code>将跳过引导。 <em>目前无功能。</em></p><p><strong>n_bootz</strong>  int</p><p>用于计算置信区间的引导程序数。 <em>目前无功能。</em></p><p><span style ="color:#FF6347"><strong>alpha</strong> </span>  float</p><p>点的比例不透明度。</p><p><strong>{x,y}_jitter</strong>  booleans or floats</p><p><em>目前无功能。</em></p><p><span style ="color:#FF6347"><strong>legend</strong> </span>  “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 matplotlib.axes.Axes.scatter().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>这些示例将使用“tips”数据集，其中包含数字变量和分类变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br></pre></td></tr></table></figure><p>传递长格式数据并赋值<code>x</code>，<code>y</code>将在两个变量之间绘制散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_3_0.png"></p><p>分配一个变量<code>hue</code>将其级别映射到点的颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_5_0.png"></p><p>分配相同的变量<code>style</code>也会改变标记并创建更易于访问的图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;time&quot;</span>, style=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_7_0.png"></p><p>将<code>hue</code>和分配<code>style</code>给不同的变量将独立改变颜色和标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;day&quot;</span>, style=<span class="string">&quot;time&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_9_0.png"></p><p>如果分配给的变量<code>hue</code>是数字，语义映射将是定量的并使用不同的默认调色板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;size&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_11_0.png"></p><p>传递分类调色板的名称或显式颜色（作为字典的 Python 列表）以强制<code>hue</code>变量的分类映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;size&quot;</span>, palette=<span class="string">&quot;deep&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_13_0.png"></p><p>如果有大量唯一的数值，图例将显示一个具有代表性的、间隔均匀的集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tip_rate = tips.<span class="built_in">eval</span>(<span class="string">&quot;tip / total_bill&quot;</span>).rename(<span class="string">&quot;tip_rate&quot;</span>)</span><br><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=tip_rate)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_15_0.png"></p><p>还可以分配数字变量<code>size</code>以将语义映射应用于点的区域：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;size&quot;</span>, size=<span class="string">&quot;size&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_17_0.png"></p><p>控制标记区域的范围<code>sizes</code>，并设置<code>lengend=&quot;full&quot;</code>为强制每个唯一值出现在图例中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(</span><br><span class="line">    data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;size&quot;</span>, size=<span class="string">&quot;size&quot;</span>,</span><br><span class="line">    sizes=(<span class="number">20</span>, <span class="number">200</span>), legend=<span class="string">&quot;full&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_19_0.png"></p><p>传递一组值或一个<a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a>对象<code>hue_norm</code>来控制定量色调映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(</span><br><span class="line">    data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;size&quot;</span>, size=<span class="string">&quot;size&quot;</span>,</span><br><span class="line">    sizes=(<span class="number">20</span>, <span class="number">200</span>), hue_norm=(<span class="number">0</span>, <span class="number">7</span>), legend=<span class="string">&quot;full&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_21_0.png"></p><p><code>style</code>通过传递标记代码的 Python 列表或字典来控制用于映射变量的特定标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">markers = &#123;<span class="string">&quot;Lunch&quot;</span>: <span class="string">&quot;s&quot;</span>, <span class="string">&quot;Dinner&quot;</span>: <span class="string">&quot;X&quot;</span>&#125;</span><br><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, style=<span class="string">&quot;time&quot;</span>, markers=markers)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_23_0.png"></p><p>额外的关键字参数传递给<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>，允许您直接设置未语义映射的绘图属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, s=<span class="number">100</span>, color=<span class="string">&quot;.2&quot;</span>, marker=<span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_25_0.png"></p><p>前面的示例使用了长格式数据集。处理宽格式数据时，将使用<code>hue</code>和<code>style</code>映射针对其索引绘制每一列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = pd.date_range(<span class="string">&quot;1 1 2000&quot;</span>, periods=<span class="number">100</span>, freq=<span class="string">&quot;m&quot;</span>, name=<span class="string">&quot;date&quot;</span>)</span><br><span class="line">data = np.random.randn(<span class="number">100</span>, <span class="number">4</span>).cumsum(axis=<span class="number">0</span>)</span><br><span class="line">wide_df = pd.DataFrame(data, index, [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>])</span><br><span class="line">sns.scatterplot(data=wide_df)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_27_0.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>结合<a href="http://seaborn.pydata.org/generated/seaborn.scatterplot.html#seaborn.scatterplot"><code>scatterplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内分组，并在多个子图中绘制它们。</p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>直接使用更安全，因为它确保跨方面的语义映射同步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>,</span><br><span class="line">    col=<span class="string">&quot;time&quot;</span>, hue=<span class="string">&quot;day&quot;</span>, style=<span class="string">&quot;day&quot;</span>,</span><br><span class="line">    kind=<span class="string">&quot;scatter&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/scatterplot_29_0.png"></p><p>&nbsp;</p><h2 id="seaborn-lineplot"><a href="#seaborn-lineplot" class="headerlink" title="seaborn.lineplot"></a>seaborn.lineplot</h2><p>绘制具有多个语义分组可能性的线图。</p><p>之间的关系<code>x</code>和<code>y</code>可以使用显示的数据的不同子集<code>hue</code>，<code>size</code>和<code>style</code>参数。这些参数控制使用什么视觉语义来识别不同的子集。通过使用所有三种语义类型可以独立显示多达三个维度，但这种情节风格可能难以解释并且通常是无效的。使用冗余的语义（即两个 <code>hue</code>和<code>style</code>同一变量），可用于制作图形更容易帮助。</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">lineplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in  <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p><p><span style ="color:#FF6347"><strong>hue</strong> </span>  vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下表现不同。</p><p><span style ="color:#FF6347"><strong>size</strong> </span>  vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p><p><span style ="color:#FF6347"><strong>style</strong> </span>  vector or key in <code>data</code></p><p>将生成具有不同样式的元素的分组变量。可以有一个数字 dtype，但将始终被视为分类。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长格式向量集合或将在内部重新整形的宽格式数据集。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p><p><strong>hue_norm</strong>  tuple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p><p><strong>sizes</strong>  list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p><p><strong>dashes</strong>  boolean, list, or dictionary</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p><p><span style ="color:#FF6347"><strong>markers</strong> </span>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量识别抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。 <em>目前无功能。</em></p><p><strong>estimator</strong>  name of pandas method or callable or None</p><p>聚合<code>y</code> 同一<code>x</code>级别变量的多个观察值的方法。如果<code>None</code>，则将绘制所有观察值。 <em>目前无功能。</em></p><p><span style ="color:#FF6347"><strong>ci</strong> </span>  int or “sd” or None</p><p>与估计器聚合时要绘制的置信区间的大小。“sd”表示绘制数据的标准偏差。设置为<code>None</code>将跳过引导。 <em>目前无功能。</em></p><p><strong>n_boot</strong>  int</p><p>用于计算置信区间的引导程序数。 <em>目前无功能。</em></p><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState</p><p>用于可重复引导的种子或随机数生成器。</p><p><span style ="color:#FF6347"><strong>sort</strong> </span>  boolean</p><p>如果为 True，数据将按 x 和 y 变量排序，否则线将按照它们在数据集中出现的顺序连接点。</p><p><strong>err_style</strong>  “band” or “bars”</p><p>是否使用半透明误差带或离散误差线绘制置信区间。</p><p><strong>err_kws</strong>  dict of keyword arguments</p><p>控制误差线美观的附加参数。kwargs 传递给<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.fill_between.html#matplotlib.axes.Axes.fill_between"><code>matplotlib.axes.Axes.fill_between()</code></a> 或<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.errorbar.html#matplotlib.axes.Axes.errorbar"><code>matplotlib.axes.Axes.errorbar()</code></a>，具体取决于<code>err_style</code>.</p><p><span style ="color:#FF6347"><strong>legend</strong> </span>  “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 matplotlib.axes.Axes.scatter().</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><p>该<code>flights</code>数据集有 10 年的每月航空公司乘客数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(<span class="string">&quot;flights&quot;</span>)</span><br></pre></td></tr></table></figure><p>要使用长格式数据绘制线图，请分配<code>x</code>和<code>y</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">may_flights = flights.query(<span class="string">&quot;month == &#x27;May&#x27;&quot;</span>)</span><br><span class="line">sns.lineplot(data=may_flights, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;passengers&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_3_0.png"></p><p>将数据框透视为宽格式表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flights_wide = flights.pivot(<span class="string">&quot;year&quot;</span>, <span class="string">&quot;month&quot;</span>, <span class="string">&quot;passengers&quot;</span>)</span><br></pre></td></tr></table></figure><p>要绘制单个向量，请将其传递给<code>data</code>。如果向量是 a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series"><code>pandas.Series</code></a>，它将根据其索引绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=flights_wide[<span class="string">&quot;May&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_7_0.png"></p><p>将整个宽格式数据集传递<code>data</code>给每列绘制一条单独的线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=flights_wide)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_9_0.png"></p><p>以长格式模式传递整个数据集将聚合重复值（每年）以显示均值和 95% 置信区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=flights, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;passengers&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_11_0.png"></p><p>分配分组语义（<code>hue</code>、<code>size</code>、 或<code>style</code>）以绘制单独的线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=flights, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;passengers&quot;</span>, hue=<span class="string">&quot;month&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_13_0.png"></p><p>可以将同一列分配给多个语义变量，这样可以增加绘图的可访问性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=flights, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;passengers&quot;</span>, hue=<span class="string">&quot;month&quot;</span>, style=<span class="string">&quot;month&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_15_0.png"></p><p>每个语义变量也可以代表不同的列。为此，我们需要一个更复杂的数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmri = sns.load_dataset(<span class="string">&quot;fmri&quot;</span>)</span><br></pre></td></tr></table></figure><p>即使使用语义分组，重复的观察也会被聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=fmri, x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;event&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_19_0.png"></p><p>分配<code>hue</code>和<code>style</code>来表示两个不同的分组变量：</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns<span class="variable">.lineplot</span>(data=fmri, x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;region&quot;</span>, style=<span class="string">&quot;event&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_21_0.png"></p><p>分配<code>style</code>变量时，可以使用标记代替（或连同）破折号来区分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=fmri,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>,</span><br><span class="line">    markers=<span class="literal">True</span>, dashes=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_23_0.png"></p><p>显示误差线而不是误差带并绘制 68% 置信区间（标准误差）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=fmri, x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;event&quot;</span>, err_style=<span class="string">&quot;bars&quot;</span>, ci=<span class="number">68</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_25_0.png"></p><p>分配<code>units</code>变量将绘制多条线而不应用语义映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=fmri.query(<span class="string">&quot;region == &#x27;frontal&#x27;&quot;</span>),</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;event&quot;</span>, units=<span class="string">&quot;subject&quot;</span>,</span><br><span class="line">    estimator=<span class="literal">None</span>, lw=<span class="number">1</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_27_0.png"></p><p>使用数字分组变量加载另一个数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dots = sns.load_dataset(<span class="string">&quot;dots&quot;</span>).query(<span class="string">&quot;align == &#x27;dots&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>分配一个数值变量以<code>hue</code>不同的方式映射它，使用不同的默认调色板和定量颜色映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=dots, x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;firing_rate&quot;</span>, hue=<span class="string">&quot;coherence&quot;</span>, style=<span class="string">&quot;choice&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_31_0.png"></p><p>通过设置<code>palette</code>和传递一个<a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a>对象来控制颜色映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=dots.query(<span class="string">&quot;coherence &gt; 0&quot;</span>),</span><br><span class="line">    x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;firing_rate&quot;</span>, hue=<span class="string">&quot;coherence&quot;</span>, style=<span class="string">&quot;choice&quot;</span>,</span><br><span class="line">     palette=<span class="string">&quot;flare&quot;</span>, hue_norm=mpl.colors.LogNorm(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_33_0.png"></p><p>或者传递特定颜色，作为 Python 列表或字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">palette = sns.color_palette(<span class="string">&quot;mako_r&quot;</span>, <span class="number">6</span>)</span><br><span class="line">sns.lineplot(</span><br><span class="line">    data=dots, x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;firing_rate&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;coherence&quot;</span>, style=<span class="string">&quot;choice&quot;</span>,</span><br><span class="line">    palette=palette</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_35_0.png"></p><p>分配<code>size</code>语义以使用数字变量映射线条的宽度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=dots, x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;firing_rate&quot;</span>,</span><br><span class="line">    size=<span class="string">&quot;coherence&quot;</span>, hue=<span class="string">&quot;choice&quot;</span>,</span><br><span class="line">    legend=<span class="string">&quot;full&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_37_0.png"></p><p>传递一个元组, , 来控制用于映射语义的线宽范围：<code>sizes=(smallest, largest)``size</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(</span><br><span class="line">    data=dots, x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;firing_rate&quot;</span>,</span><br><span class="line">    size=<span class="string">&quot;coherence&quot;</span>, hue=<span class="string">&quot;choice&quot;</span>,</span><br><span class="line">    sizes=(<span class="number">.25</span>, <span class="number">2.5</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_39_0.png"></p><p>默认情况下，观察按 排序<code>x</code>。禁用此选项以按照观测值出现在数据集中的顺序绘制一条线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.random.normal(size=(<span class="number">2</span>, <span class="number">5000</span>)).cumsum(axis=<span class="number">1</span>)</span><br><span class="line">sns.lineplot(x=x, y=y, sort=<span class="literal">False</span>, lw=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_41_0.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>结合<a href="http://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot"><code>lineplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.relplot.html#seaborn.relplot"><code>relplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>直接使用更安全，因为它确保跨方面的语义映射同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=fmri, x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>,</span><br><span class="line">    col=<span class="string">&quot;region&quot;</span>, hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>,</span><br><span class="line">    kind=<span class="string">&quot;line&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/lineplot_43_0.png"></p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn Categorical plots</title>
    <link href="http://yoursite.com/2021/06/14/Seaborn-Categorical-plots/"/>
    <id>http://yoursite.com/2021/06/14/Seaborn-Categorical-plots/</id>
    <published>2021-06-14T04:29:59.000Z</published>
    <updated>2021-06-14T14:20:58.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Categorical-plots"><a href="#Categorical-plots" class="headerlink" title="Categorical plots"></a>Categorical plots</h1><h2 id="seaborn-catplot"><a href="#seaborn-catplot" class="headerlink" title="seaborn.catplot"></a>seaborn.catplot</h2><p>用于在 FacetGrid 上绘制分类图的图形级界面。</p><p>此函数提供对多个轴级函数的访问，这些函数使用多种视觉表示形式之一显示数值与一个或多个分类变量之间的关系。该<code>kind</code> 参数选择要使用的底层轴级函数：</p><div class="note blue no-icon flat"><p>分类散点图：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot"><code>stripplot()</code></a>（带有<code>kind=&quot;strip&quot;</code>; 默认值）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.swarmplot.html#seaborn.swarmplot"><code>swarmplot()</code></a>（与<code>kind=&quot;swarm&quot;</code>）</li></ul><p>分类分布图：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.boxplot.html#seaborn.boxplot"><code>boxplot()</code></a>（与<code>kind=&quot;box&quot;</code>）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.violinplot.html#seaborn.violinplot"><code>violinplot()</code></a>（与<code>kind=&quot;violin&quot;</code>）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.boxenplot.html#seaborn.boxenplot"><code>boxenplot()</code></a>（与<code>kind=&quot;boxen&quot;</code>）</li></ul><p>分类估计图：</p><ul><li><a href="http://seaborn.pydata.org/generated/seaborn.pointplot.html#seaborn.pointplot"><code>pointplot()</code></a>（与<code>kind=&quot;point&quot;</code>）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.barplot.html#seaborn.barplot"><code>barplot()</code></a>（与<code>kind=&quot;bar&quot;</code>）</li><li><a href="http://seaborn.pydata.org/generated/seaborn.countplot.html#seaborn.countplot"><code>countplot()</code></a>（与<code>kind=&quot;count&quot;</code>）</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">catplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>   names of variables in <code>data</code></p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>   DataFrame</p><p>用于绘图的长格式（整洁）数据集。每列应该对应一个变量，每行应该对应一个观察值。</p><p><span style ="color:#FF6347"><strong>row, col</strong> </span>   names of variables in <code>data</code>, optional</p><p>将确定网格分面的分类变量。</p><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p><p><strong>estimator</strong>  callable that maps vector -&gt; scalar, optional</p><p>在每个分类箱内估计的统计函数。</p><p><strong>ci</strong>  float or “sd” or None, optional</p><p>围绕估计值绘制的置信区间的大小。如果为“sd”，则跳过引导并绘制观测值的标准偏差。如果<code>None</code>，则不会执行引导，并且不会绘制误差线。</p><p><strong>n_boot</strong>  int, optional</p><p>计算置信区间时使用的引导迭代次数。</p><p><strong>units</strong>  name of variable in <code>data</code> or vector data, optional</p><p>抽样单位的标识符，将用于执行多级引导程序并考虑重复测量设计。</p><p><strong>seed</strong> int, numpy.random.Generator, or numpy.random.RandomState, optional</p><p>用于可重复引导的种子或随机数生成器。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><strong>row_order, col_order</strong>  lists of strings, optional</p><p>组织网格的行和/或列的顺序，否则从数据对象推断顺序。</p><p><span style ="color:#FF6347"><strong>kind</strong> </span>   str, optional</p><p>要绘制的绘图类型对应于分类轴级别绘图函数的名称。选项包括：“strip”、“swarm”、“box”、“violin”、“boxen”、“point”、“bar”或“count”。</p><p><span style ="color:#FF6347"><strong>height</strong> </span>   scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p><p><span style ="color:#FF6347"><strong>orient</strong> </span>   “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>   palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><span style ="color:#FF6347"><strong>legend</strong> </span>   bool, optional</p><p>如果<code>True</code>有一个<code>hue</code>变量，在图上画一个图例。</p><p><strong>legend_out</strong>  bool</p><p>如果<code>True</code>，图形大小将被扩展，并且图例将绘制在中间右侧的绘图之外。</p><p><strong>share{x,y}</strong>  bool, ‘col’, or ‘row’ optional</p><p>如果为 true，则分面将跨列共享 y 轴和/或跨行共享 x 轴。</p><p><strong>margin_titles</strong>  bool</p><p>如果<code>True</code>，则行变量的标题绘制在最后一列的右侧。此选项是实验性的，可能不适用于所有情况。</p><p><strong>facet_kws</strong>  dict, optional</p><p>要传递给的其他关键字参数的字典<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。</p><p><strong>kwargs</strong>  key, value pairings</p><p>其他关键字参数将传递给底层绘图函数。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个面以使用<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>图例放置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> snssns.set_theme(style=<span class="string">&quot;ticks&quot;</span>)exercise = sns.load_dataset(<span class="string">&quot;exercise&quot;</span>)g = sns.catplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;pulse&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>, data=exercise)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-1.png"></p><p>使用不同的绘图类型来可视化相同的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;pulse&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>,</span><br><span class="line"><span class="meta">... </span>               data=exercise, kind=<span class="string">&quot;violin&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-2.png"></p><p>沿列的分面以显示第三个分类变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;pulse&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                col=<span class="string">&quot;diet&quot;</span>, data=exercise)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-3.png"></p><p>对小平面使用不同的高度和纵横比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;pulse&quot;</span>, hue=<span class="string">&quot;kind&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                col=<span class="string">&quot;diet&quot;</span>, data=exercise,</span><br><span class="line"><span class="meta">... </span>                height=<span class="number">5</span>, aspect=<span class="number">.8</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-4.png"></p><p>制作许多列面并将它们包装到网格的行中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">titanic = sns.load_dataset(<span class="string">&quot;titanic&quot;</span>)</span><br><span class="line">g = sns.catplot(x=<span class="string">&quot;alive&quot;</span>, col=<span class="string">&quot;deck&quot;</span>, col_wrap=<span class="number">4</span>,</span><br><span class="line"><span class="meta">... </span>                data=titanic[titanic.deck.notnull()],</span><br><span class="line"><span class="meta">... </span>                kind=<span class="string">&quot;count&quot;</span>, height=<span class="number">2.5</span>, aspect=<span class="number">.8</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-5.png"></p><p>水平绘图并将其他关键字参数传递给绘图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;age&quot;</span>, y=<span class="string">&quot;embark_town&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                hue=<span class="string">&quot;sex&quot;</span>, row=<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=titanic[titanic.embark_town.notnull()],</span><br><span class="line"><span class="meta">... </span>                orient=<span class="string">&quot;h&quot;</span>, height=<span class="number">2</span>, aspect=<span class="number">3</span>, palette=<span class="string">&quot;Set3&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                kind=<span class="string">&quot;violin&quot;</span>, dodge=<span class="literal">True</span>, cut=<span class="number">0</span>, bw=<span class="number">.2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-6.png"></p><p>使用返回的方法<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>来调整演示文稿：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;who&quot;</span>, y=<span class="string">&quot;survived&quot;</span>, col=<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=titanic, saturation=<span class="number">.5</span>,</span><br><span class="line"><span class="meta">... </span>                kind=<span class="string">&quot;bar&quot;</span>, ci=<span class="literal">None</span>, aspect=<span class="number">.6</span>)</span><br><span class="line">(g.set_axis_labels(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Survival Rate&quot;</span>)</span><br><span class="line"><span class="meta">... </span>  .set_xticklabels([<span class="string">&quot;Men&quot;</span>, <span class="string">&quot;Women&quot;</span>, <span class="string">&quot;Children&quot;</span>])</span><br><span class="line"><span class="meta">... </span>  .set_titles(<span class="string">&quot;&#123;col_name&#125; &#123;col_var&#125;&quot;</span>)</span><br><span class="line"><span class="meta">... </span>  .<span class="built_in">set</span>(ylim=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span>  .despine(left=<span class="literal">True</span>)) </span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-catplot-7.png"></p><p>&nbsp;</p><h2 id="seaborn-stripplot"><a href="#seaborn-stripplot" class="headerlink" title="seaborn.stripplot"></a>seaborn.stripplot</h2><p>绘制一个散点图。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">stripplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><span style ="color:#FF6347"><strong>jitter</strong> </span>  float, <code>True</code>/<code>1</code> is special-cased, optional</p><p>要应用的抖动量（仅沿分类轴）。当您有很多点并且它们重叠时，这会很有用，以便更容易查看分布。您可以指定抖动量（均匀随机变量支持宽度的一半），或者仅<code>True</code>用于良好的默认值。</p><p><strong>dodge</strong>  bool, optional</p><p>使用<code>hue</code>嵌套时，将其设置为<code>True</code>将沿分类轴分离不同色调级别的条带。否则，每个级别的点将绘制在彼此之上。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>size</strong>  float, optional</p><p>标记的半径，以点为单位。</p><p><strong>edgecolor</strong>  matplotlib color, “gray” is special-cased, optional</p><p>每个点周围线条的颜色。如果通过<code>&quot;gray&quot;</code>，则亮度由用于点主体的调色板确定。</p><p><strong>linewidth</strong>  float, optional</p><p>构成绘图元素的灰线的宽度。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个水平条形图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">ax = sns.stripplot(x=tips[<span class="string">&quot;total_bill&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-1.png"></p><p>按分类变量对条带进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-2.png"></p><p>使用更少量的抖动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips, jitter=<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-3.png"></p><p>绘制水平条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-4.png"></p><p>围绕点绘制轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips,...                    linewidth=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-5.png"></p><p>将条带嵌套在第二个分类变量中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;day&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-6.png"></p><p><code>hue</code>在主要分类轴上的不同位置绘制变量的每个级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                   data=tips, palette=<span class="string">&quot;Set2&quot;</span>, dodge=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-7.png"></p><p>通过传递显式顺序来控制条带顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.stripplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,...                    order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-8.png"></p><p>绘制大点和不同美感的条带：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax =  sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                   data=tips, palette=<span class="string">&quot;Set2&quot;</span>, size=<span class="number">20</span>, marker=<span class="string">&quot;D&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                   edgecolor=<span class="string">&quot;gray&quot;</span>, alpha=<span class="number">.25</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-9.png"></p><p>在箱线图顶部绘制观察条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> npax = sns.boxplot(x=<span class="string">&quot;tip&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips, whis=np.inf)ax = sns.stripplot(x=<span class="string">&quot;tip&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips, color=<span class="string">&quot;.3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-10.png"></p><p>在小提琴图的顶部绘制观察条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,</span><br><span class="line"><span class="meta">... </span>                    inner=<span class="literal">None</span>, color=<span class="string">&quot;.8&quot;</span>)</span><br><span class="line">ax = sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-111.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot"><code>stripplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,...                 hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,...                 data=tips, kind=<span class="string">&quot;strip&quot;</span>,...                 height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-stripplot-12.png"></p><p>&nbsp;</p><h2 id="seaborn-swarmplot"><a href="#seaborn-swarmplot" class="headerlink" title="seaborn.swarmplot"></a>seaborn.swarmplot</h2><p>绘制具有非重叠点的分类散点图。</p><p>此函数类似于<a href="http://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot"><code>stripplot()</code></a>，但调整了点（仅沿分类轴）以使它们不重叠。这可以更好地表示值的分布，但不能很好地扩展到大量观察。这种情节风格有时被称为“beeswarm”。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">swarmplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><strong>dodge</strong>  bool, optional</p><p>使用<code>hue</code>嵌套时，将其设置为<code>True</code>将沿分类轴分离不同色调级别的条带。否则，每个级别的点将绘制在彼此之上。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>size</strong>  float, optional</p><p>标记的半径，以点为单位。</p><p><strong>edgecolor</strong>  matplotlib color, “gray” is special-cased, optional</p><p>每个点周围线条的颜色。如果通过<code>&quot;gray&quot;</code>，则亮度由用于点主体的调色板确定。</p><p><strong>linewidth</strong>  float, optional</p><p>构成绘图元素的灰线的宽度。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个水平群图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns&gt;&gt;&gt; sns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)&gt;&gt;&gt; tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)&gt;&gt;&gt; ax = sns.swarmplot(x=tips[<span class="string">&quot;total_bill&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-1.png"></p><p>按分类变量对群进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-2.png"></p><p>绘制水平群：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-3.png"></p><p>使用第二个分类变量为点着色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-4.png"></p><p><code>hue</code>沿分类轴拆分变量的每个级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips, palette=<span class="string">&quot;Set2&quot;</span>, dodge=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-5.png"></p><p>通过传递显式命令来控制群顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                    order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-6.png"></p><p>使用较大的点绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips, size=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-7.png"></p><p>在箱线图上绘制成群的观察结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips, whis=np.inf)ax = sns.swarmplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips, color=<span class="string">&quot;.2&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-8.png"></p><p>在小提琴图上绘制成群的观察结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips, inner=<span class="literal">None</span>)ax = sns.swarmplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                    color=<span class="string">&quot;white&quot;</span>, edgecolor=<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-9.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.swarmplot.html#seaborn.swarmplot"><code>swarmplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,...                 hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,...                 data=tips, kind=<span class="string">&quot;swarm&quot;</span>,...                 height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-swarmplot-10.png"></p><p>&nbsp;</p><h2 id="seaborn-boxplot"><a href="#seaborn-boxplot" class="headerlink" title="seaborn.boxplot"></a>seaborn.boxplot</h2><p>绘制箱线图以显示关于类别的分布。</p><p>箱线图（或箱线图）以一种便于比较变量之间或跨分类变量水平的方式显示定量数据的分布。该框显示数据集的四分位数，而胡须扩展以显示分布的其余部分，除了使用作为四分位间距函数的方法确定为“异常值”的点之外。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">boxplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>saturation</strong>  float, optional</p><p>绘制颜色的原始饱和度的比例。大色块通常在颜色稍微不饱和的情况下看起来更好，但<code>1</code>如果您希望绘图颜色与输入颜色规格完美匹配，请将其设置为 。</p><p><strong>width</strong>  float, optional</p><p>不使用色调嵌套时的完整元素的宽度，或主要分组变量的一个级别的所有元素的宽度。</p><p><strong>dodge</strong>  bool, optional</p><p>使用色调嵌套时，元素是否应沿分类轴移动。</p><p><strong>fliersize</strong>  float, optional</p><p>用于指示异常值观察的标记的大小。</p><p><strong>linewidth</strong>  float, optional</p><p>构成绘图元素的灰线的宽度。</p><p><strong>whis</strong>  float, optional</p><p>IQR 通过低四分位数和高四分位数以扩展图须的比例。此范围之外的点将被识别为异常值。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个水平箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> snssns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)ax = sns.boxplot(x=tips[<span class="string">&quot;total_bill&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-1.png"></p><p>绘制按分类变量分组的垂直箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-2.png"></p><p>用两个分类变量嵌套分组绘制箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                  data=tips, palette=<span class="string">&quot;Set3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-3.png"></p><p>当某些 bin 为空时，绘制带有嵌套分组的箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>,...                  data=tips, linewidth=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-4.png"></p><p>通过传递显式顺序来控制框顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,...                  order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-5.png"></p><p>为 DataFrame 中的每个数值变量绘制箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line">ax = sns.boxplot(data=iris, orient=<span class="string">&quot;h&quot;</span>, palette=<span class="string">&quot;Set2&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-6.png"></p><p>在<code>hue</code>不改变框位置或宽度的情况下使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips[<span class="string">&quot;weekend&quot;</span>] = tips[<span class="string">&quot;day&quot;</span>].isin([<span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>])</span><br><span class="line">ax = sns.boxplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;weekend&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                 data=tips, dodge=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-7.png"></p><p>用于<a href="http://seaborn.pydata.org/generated/seaborn.swarmplot.html#seaborn.swarmplot"><code>swarmplot()</code></a>在框顶部显示数据点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br><span class="line">ax = sns.swarmplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips, color=<span class="string">&quot;.25&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-8.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.boxplot.html#seaborn.boxplot"><code>boxplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=tips, kind=<span class="string">&quot;box&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxplot-9.png"></p><p>&nbsp;</p><h2 id="seaborn-violinplot"><a href="#seaborn-violinplot" class="headerlink" title="seaborn.violinplot"></a>seaborn.violinplot</h2><p>绘制箱线图和核密度估计的组合。</p><p>小提琴图的作用与盒须图相似。它显示了定量数据在一个（或多个）分类变量的多个级别上的分布，以便可以比较这些分布。与箱线图不同，箱线图的所有图分量都对应于实际数据点，小提琴图的特点是对基础分布进行核密度估计。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">violinplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><strong>bw</strong>  {‘scott’, ‘silverman’, float}, optional</p><p>计算内核带宽时要使用的参考规则的名称或比例因子。实际内核大小将通过将比例因子乘以每个 bin 内数据的标准偏差来确定。</p><p><strong>cut</strong>  float, optional</p><p>距离，以带宽大小为单位，将密度扩展到超过极端数据点。设置为0，以限制观测数据的范围内的小提琴范围（即，具有相同的效果<code>trim=True</code>在 <code>ggplot</code>。</p><p><strong>scale</strong>  {“area”, “count”, “width”}, optional</p><p>用于缩放每把小提琴的宽度的方法。如果<code>area</code>，每把小提琴将有相同的面积。如果<code>count</code>，小提琴的宽度将按该 bin 中的观察数进行缩放。如果<code>width</code>，每把小提琴将具有相同的宽度。</p><p><strong>scale_hue</strong>  bool, optional</p><p>使用<code>hue</code>变量嵌套小提琴时，此参数确定是在主要分组变量 ( <code>scale_hue=True</code>) 的每个级别内还是在绘图 ( <code>scale_hue=False</code>)上的所有小提琴中计算缩放比例。</p><p><strong>gridsize</strong>  int, optional</p><p>用于计算核密度估计的离散网格中的点数。</p><p><strong>width</strong>  float, optional</p><p>不使用色调嵌套时的完整元素的宽度，或主要分组变量的一个级别的所有元素的宽度。</p><p><span style ="color:#FF6347"><strong>inner</strong> </span>  {“box”, “quartile”, “point”, “stick”, None}, optional</p><p>小提琴内部数据点的表示。如果<code>box</code>，绘制一个微型箱线图。如果<code>quartiles</code>，绘制分布的四分位数。如果<code>point</code>或<code>stick</code>，则显示每个基础数据点。使用<code>None</code>将绘制朴素的小提琴。</p><p><span style ="color:#FF6347"><strong>split</strong> </span>  bool, optional</p><p>当使用带有两个级别的变量的色调嵌套时，设置 <code>split</code>为 True 将为每个级别绘制一半的小提琴。这可以更容易地直接比较分布。</p><p><strong>dodge</strong>  bool, optional</p><p>使用色调嵌套时，元素是否应沿分类轴移动。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><strong>linewidth</strong>  float, optional</p><p>构成绘图元素的灰线的宽度。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>saturation</strong>  float, optional</p><p>绘制颜色的原始饱和度的比例。大色块通常在颜色稍微不饱和的情况下看起来更好，但<code>1</code>如果您希望绘图颜色与输入颜色规格完美匹配，请将其设置为 。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-4"><a href="#Examples-4" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个水平小提琴图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">ax = sns.violinplot(x=tips[<span class="string">&quot;total_bill&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-1.png"></p><p>绘制按分类变量分组的垂直小提琴图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-2.png"></p><p>用两个分类变量嵌套分组绘制小提琴图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                    data=tips, palette=<span class="string">&quot;muted&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-3.png"></p><p>绘制分割小提琴以比较色调变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                    data=tips, palette=<span class="string">&quot;muted&quot;</span>, split=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-4.png"></p><p>通过传递显式命令来控制小提琴顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,</span><br><span class="line"><span class="meta">... </span>                    order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-5.png"></p><p>按每个 bin 中的观察次数缩放小提琴宽度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,...                     data=tips, palette=<span class="string">&quot;Set2&quot;</span>, split=<span class="literal">True</span>,...                     scale=<span class="string">&quot;count&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-6.png"></p><p>将四分位数绘制为水平线而不是迷你框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,...                     data=tips, palette=<span class="string">&quot;Set2&quot;</span>, split=<span class="literal">True</span>,...                     scale=<span class="string">&quot;count&quot;</span>, inner=<span class="string">&quot;quartile&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-7.png"></p><p>用小提琴内的一根棍子显示每个观察结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,...                     data=tips, palette=<span class="string">&quot;Set2&quot;</span>, split=<span class="literal">True</span>,...                     scale=<span class="string">&quot;count&quot;</span>, inner=<span class="string">&quot;stick&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-8.png"></p><p>相对于所有 bin 的计数缩放密度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,...                     data=tips, palette=<span class="string">&quot;Set2&quot;</span>, split=<span class="literal">True</span>,...                     scale=<span class="string">&quot;count&quot;</span>, inner=<span class="string">&quot;stick&quot;</span>, scale_hue=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-9.png"></p><p>使用窄带宽来减少平滑量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,...                     data=tips, palette=<span class="string">&quot;Set2&quot;</span>, split=<span class="literal">True</span>,...                     scale=<span class="string">&quot;count&quot;</span>, inner=<span class="string">&quot;stick&quot;</span>,...                     scale_hue=<span class="literal">False</span>, bw=<span class="number">.2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-10.png"></p><p>绘制水平小提琴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets = sns.load_dataset(<span class="string">&quot;planets&quot;</span>)ax = sns.violinplot(x=<span class="string">&quot;orbital_period&quot;</span>, y=<span class="string">&quot;method&quot;</span>,...                     data=planets[planets.orbital_period &lt; <span class="number">1000</span>],...                     scale=<span class="string">&quot;width&quot;</span>, palette=<span class="string">&quot;Set3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-111.png"></p><p>不要让密度超出数据中的极值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.violinplot(x=<span class="string">&quot;orbital_period&quot;</span>, y=<span class="string">&quot;method&quot;</span>,...                     data=planets[planets.orbital_period &lt; <span class="number">1000</span>],...                     cut=<span class="number">0</span>, scale=<span class="string">&quot;width&quot;</span>, palette=<span class="string">&quot;Set3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-12.png"></p><p>在<code>hue</code>不改变小提琴位置或宽度的情况下使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips[<span class="string">&quot;weekend&quot;</span>] = tips[<span class="string">&quot;day&quot;</span>].isin([<span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>])ax = sns.violinplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;weekend&quot;</span>,...                     data=tips, dodge=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-13.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.violinplot.html#seaborn.violinplot"><code>violinplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,...                 hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,...                 data=tips, kind=<span class="string">&quot;violin&quot;</span>, split=<span class="literal">True</span>,...                 height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-violinplot-14.png"></p><p>&nbsp;</p><h2 id="seaborn-boxenplot"><a href="#seaborn-boxenplot" class="headerlink" title="seaborn.boxenplot"></a>seaborn.boxenplot</h2><p>为较大的数据集绘制增强型箱线图。</p><p>这种绘图风格最初被命名为“字母值”图，因为它显示了大量定义为“字母值”的分位数。它类似于绘制分布的非参数表示的箱线图，其中所有特征都对应于实际观察。通过绘制更多的分位数，它提供了更多关于分布形状的信息，特别是在尾部。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">boxplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>saturation</strong>  float, optional</p><p>绘制颜色的原始饱和度的比例。大色块通常在颜色稍微不饱和的情况下看起来更好，但<code>1</code>如果您希望绘图颜色与输入颜色规格完美匹配，请将其设置为 。</p><p><strong>width</strong>  float, optional</p><p>不使用色调嵌套时的完整元素的宽度，或主要分组变量的一个级别的所有元素的宽度。</p><p><strong>dodge</strong>  bool, optional</p><p>使用色调嵌套时，元素是否应沿分类轴移动。</p><p><strong>k_depth</strong>  {“tukey”, “proportion”, “trustworthy”, “full”} or scalar, optional</p><p>要绘制的框数和百分位数。Wickham 的论文中详细介绍了所有方法。每个人都对异常值的数量做出不同的假设，并利用不同的统计属性。如果是“比例”，则只能进行 <code>outlier_prop</code>极端观察。如果“满”，画框<code>log(n)+1</code>。</p><p><strong>linewidth</strong>  float, optional</p><p>构成绘图元素的灰线的宽度。</p><p><strong>scale</strong>  {“area”, “count”, “width”}, optional</p><p>用于缩放每把小提琴的宽度的方法。如果<code>area</code>，每把小提琴将有相同的面积。如果<code>count</code>，小提琴的宽度将按该 bin 中的观察数进行缩放。如果<code>width</code>，每把小提琴将具有相同的宽度。</p><p><strong>outlier_prop</strong>  float, optional</p><p>被认为是异常值的数据比例。必须在 (0, 1] 范围内。用于确定当 时要绘制的框数 <code>k_depth=&quot;proportion&quot;</code>。</p><p><strong>trust_alpha</strong>  float, optional</p><p>要绘制的框的置信水平。用于确定在 时绘制的框数<code>k_depth=&quot;trustworthy&quot;</code>。必须在 (0, 1) 范围内。</p><p><strong>showfliers</strong>  bool, optional</p><p>如果为 False，则禁止绘制异常值。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter"><code>matplotlib.axes.Axes.scatter()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-5"><a href="#Examples-5" class="headerlink" title="Examples"></a>Examples</h3><p>绘制单个水平箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">ax = sns.boxenplot(x=tips[<span class="string">&quot;total_bill&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-1.png"></p><p>绘制按分类变量分组的垂直箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxenplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-2.png"></p><p>用两个分类变量嵌套分组绘制字母值图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxenplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips, palette=<span class="string">&quot;Set3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-3.png"></p><p>当某些 bin 为空时，绘制带有嵌套分组的 boxen 图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxenplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;time&quot;</span>,...                    data=tips, linewidth=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-4.png"></p><p>通过传递显式顺序来控制框顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxenplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,...                    order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-5.png"></p><p>为 DataFrame 中的每个数值变量绘制箱线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)ax = sns.boxenplot(data=iris, orient=<span class="string">&quot;h&quot;</span>, palette=<span class="string">&quot;Set2&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-6.png"></p><p>用于<a href="http://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot"><code>stripplot()</code></a>在框顶部显示数据点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.boxenplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                    showfliers=<span class="literal">False</span>)ax = sns.stripplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                    size=<span class="number">4</span>, color=<span class="string">&quot;.26&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-7.png"></p><p>用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合<a href="http://seaborn.pydata.org/generated/seaborn.boxenplot.html#seaborn.boxenplot"><code>boxenplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>直接使用 更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,...                 hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,...                 data=tips, kind=<span class="string">&quot;boxen&quot;</span>,...                 height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-boxenplot-8.png"></p><p>&nbsp;</p><h2 id="seaborn-pointplot"><a href="#seaborn-pointplot" class="headerlink" title="seaborn.pointplot"></a>seaborn.pointplot</h2><p>使用散点图字形显示点估计和置信区间。</p><p>点图表示通过散点图点的位置对数值变量集中趋势的估计，并使用误差线提供该估计周围不确定性的一些指示。</p><p>对于集中比较一个或多个分类变量的不同级别之间的比较，点图可能比条形图更有用。他们特别擅长展示相互作用：一个分类变量的水平之间的关系如何在第二个分类变量的水平之间变化。连接同<code>hue</code> 一层的每个点的线允许通过斜率的差异来判断交互，这比比较几组点或条的高度对眼睛来说更容易。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">pointplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><strong>estimator</strong>  callable that maps vector -&gt; scalar, optional</p><p>在每个分类箱内估计的统计函数。</p><p><strong>ci</strong>  float or “sd” or None, optional</p><p>围绕估计值绘制的置信区间的大小。如果为“sd”，则跳过引导并绘制观测值的标准偏差。如果<code>None</code>，则不会执行引导，并且不会绘制误差线。</p><p><strong>n_boot</strong>  int, optional</p><p>计算置信区间时使用的引导迭代次数。</p><p><strong>units</strong>  name of variable in <code>data</code> or vector data, optional</p><p>抽样单位的标识符，将用于执行多级引导程序并考虑重复测量设计。</p><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState, optional</p><p>用于可重复引导的种子或随机数生成器。</p><p><span style ="color:#FF6347"><strong>markers</strong> </span>  string or list of strings, optional</p><p>用于每个<code>hue</code>级别的标记。</p><p><strong>linestyles</strong>  string or list of strings, optional</p><p>用于每个<code>hue</code>级别的线型。</p><p><strong>dodge</strong>  bool or float, optional</p><p><code>hue</code>沿分类轴分隔变量每个级别的点的量。</p><p><span style ="color:#FF6347"><strong>join</strong> </span>  bool, optional</p><p>如果<code>True</code>，将在同一<code>hue</code>级别的点估计之间画线 。</p><p><strong>scale</strong>  float, optional</p><p>绘图元素的比例因子。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>errwidth</strong>  float, optional</p><p>误差条线（和上限）的粗细。</p><p><strong>capsize</strong>  float, optional</p><p>误差条上“上限”的宽度。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-6"><a href="#Examples-6" class="headerlink" title="Examples"></a>Examples</h3><p>绘制一组按分类变量分组的垂直点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> snssns.set_theme(style=<span class="string">&quot;darkgrid&quot;</span>)tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-1.png"></p><p>用两个变量嵌套分组绘制一组垂直点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-2.png"></p><p>沿分类轴分离不同色调级别的点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips, dodge=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-3.png"></p><p>对色调级别使用不同的标记和线条样式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips,...                    markers=[<span class="string">&quot;o&quot;</span>, <span class="string">&quot;x&quot;</span>],...                    linestyles=[<span class="string">&quot;-&quot;</span>, <span class="string">&quot;--&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-4.png"></p><p>绘制一组水平点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;tip&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-5.png"></p><p>不要画一条连接每个点的线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;tip&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips, join=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-6.png"></p><p>对单层图使用不同的颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                    color=<span class="string">&quot;#bb3f3f&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-7.png"></p><p>对点使用不同的调色板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>,...                    data=tips, palette=<span class="string">&quot;Set2&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-8.png"></p><p>通过传递显式顺序来控制点顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,...                    order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-9.png"></p><p>使用中值作为集中趋势的估计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> median</span><br><span class="line">ax = sns.pointplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, estimator=median)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-10.png"></p><p>用误差线显示平均值的标准误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, ci=<span class="number">68</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-111.png"></p><p>显示观察的标准偏差而不是置信区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, ci=<span class="string">&quot;sd&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-12.png"></p><p>将“caps”添加到误差条中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.pointplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, capsize=<span class="number">.2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-13.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.pointplot.html#seaborn.pointplot"><code>pointplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=tips, kind=<span class="string">&quot;point&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                dodge=<span class="literal">True</span>,</span><br><span class="line"><span class="meta">... </span>                height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-pointplot-14.png"></p><p>&nbsp;</p><h2 id="seaborn-barplot"><a href="#seaborn-barplot" class="headerlink" title="seaborn.barplot"></a>seaborn.barplot</h2><p>将点估计和置信区间显示为矩形条。</p><p>条形图表示具有每个矩形高度的数值变量的集中趋势估计，并使用误差条提供该估计周围不确定性的一些指示。条形图在定量轴范围内包含 0，当 0 是定量变量的有意义值并且您想与之进行比较时，它们是一个不错的选择。</p><p>对于 0 不是有意义值的数据集，点图将允许您关注一个或多个分类变量的水平之间的差异。</p><p>同样重要的是要记住，条形图仅显示平均值（或其他估计量）值，但在许多情况下，显示分类变量每个级别的值分布可能会提供更多信息。在这种情况下，其他方法（例如方框图或小提琴图）可能更合适。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">barplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><strong>order, hue_order</strong>  lists of strings, optional</p><p>按顺序绘制分类级别，否则从数据对象推断级别。</p><p><strong>estimator</strong>  callable that maps vector -&gt; scalar, optional</p><p>在每个分类箱内估计的统计函数。</p><p><strong>ci</strong>  float or “sd” or None, optional</p><p>围绕估计值绘制的置信区间的大小。如果为“sd”，则跳过引导并绘制观测值的标准偏差。如果<code>None</code>，则不会执行引导，并且不会绘制误差线。</p><p><strong>n_boot</strong>  int, optional</p><p>计算置信区间时使用的引导迭代次数。</p><p><strong>units</strong>  name of variable in <code>data</code> or vector data, optional</p><p>抽样单位的标识符，将用于执行多级引导程序并考虑重复测量设计。</p><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState, optional</p><p>用于可重复引导的种子或随机数生成器。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>saturation</strong>  float, optional</p><p>绘制颜色的原始饱和度的比例。大色块通常在颜色稍微不饱和的情况下看起来更好，但<code>1</code>如果您希望绘图颜色与输入颜色规格完美匹配，请将其设置为 。</p><p><strong>errcolor</strong>  matplotlib color</p><p>代表置信区间的线条的颜色。</p><p><strong>errwidth</strong>  float, optional</p><p>误差条线（和上限）的粗细。</p><p><strong>capsize</strong>  float, optional</p><p>误差条上“上限”的宽度。</p><p><strong>dodge</strong>  bool, optional</p><p>使用色调嵌套时，元素是否应沿分类轴移动。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar"><code>matplotlib.axes.Axes.bar()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-7"><a href="#Examples-7" class="headerlink" title="Examples"></a>Examples</h3><p>绘制一组按分类变量分组的垂直条形图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> snssns.set_theme(style=<span class="string">&quot;whitegrid&quot;</span>)tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-1.png"></p><p>绘制一组由两个变量嵌套分组的垂直条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-2.png"></p><p>绘制一组水平条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;tip&quot;</span>, y=<span class="string">&quot;day&quot;</span>, data=tips)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-3.png"></p><p>通过传递显式订单来控制栏顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,...                  order=[<span class="string">&quot;Dinner&quot;</span>, <span class="string">&quot;Lunch&quot;</span>])</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-4.png"></p><p>使用中值作为集中趋势的估计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> medianax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, estimator=median)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-5.png"></p><p>用误差线显示平均值的标准误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, ci=<span class="number">68</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-6.png"></p><p>显示观察的标准偏差而不是置信区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, ci=<span class="string">&quot;sd&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-7.png"></p><p>将“caps”添加到误差条中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips, capsize=<span class="number">.2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-8.png"></p><p>为条形使用不同的调色板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;size&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                  palette=<span class="string">&quot;Blues_d&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-9.png"></p><p>在<code>hue</code>不改变条形位置或宽度的情况下使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips[<span class="string">&quot;weekend&quot;</span>] = tips[<span class="string">&quot;day&quot;</span>].isin([<span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>])ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, hue=<span class="string">&quot;weekend&quot;</span>,...                  data=tips, dodge=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-10.png"></p><p>以单一颜色绘制所有条形图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;size&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                  color=<span class="string">&quot;salmon&quot;</span>, saturation=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-111.png"></p><p>使用<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar"><code>matplotlib.axes.Axes.bar()</code></a>参数来控制样式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.barplot(x=<span class="string">&quot;day&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>, data=tips,...                  linewidth=<span class="number">2.5</span>, facecolor=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),...                  errcolor=<span class="string">&quot;.2&quot;</span>, edgecolor=<span class="string">&quot;.2&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-12.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.barplot.html#seaborn.barplot"><code>barplot()</code></a>和<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>直接使用 更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;sex&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,...                 hue=<span class="string">&quot;smoker&quot;</span>, col=<span class="string">&quot;time&quot;</span>,...                 data=tips, kind=<span class="string">&quot;bar&quot;</span>,...                 height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-barplot-13.png"></p><p>&nbsp;</p><h2 id="seaborn-countplot"><a href="#seaborn-countplot" class="headerlink" title="seaborn.countplot"></a>seaborn.countplot</h2><p>使用条形显示每个分类 bin 中的观察计数。</p><p>计数图可以被认为是跨分类变量而不是定量变量的直方图。基本 API 和选项与 的相同<a href="http://seaborn.pydata.org/generated/seaborn.barplot.html#seaborn.barplot"><code>barplot()</code></a>，因此您可以比较嵌套变量之间的计数。</p><div class="note blue no-icon flat"><p>输入数据可以以多种格式传递，包括：</p><ul><li>Vectors of data represented as lists, numpy arrays, or pandas Series objects passed directly to the <code>x</code>, <code>y</code>, and/or <code>hue</code> parameters.</li><li>A “long-form” DataFrame, in which case the <code>x</code>, <code>y</code>, and <code>hue</code> variables will determine how the data are plotted.</li><li>A “wide-form” DataFrame, such that each numeric column will be plotted.</li><li>An array or list of vectors.</li></ul></div><p>&nbsp;</p><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">countplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><span style ="color:#FF6347"><strong>x, y, hue</strong> </span>  names of variables in <code>data</code> or vector data, optional</p><p>用于绘制长格式数据的输入。请参阅示例以进行解释。</p><p><span style ="color:#FF6347"><strong>data</strong> </span>  DataFrame, array, or list of arrays, optional</p><p>用于绘图的数据集。如果<code>x</code>和<code>y</code>不存在，则将其解释为宽格式。否则，它应该是长格式的。</p><p><span style ="color:#FF6347"><strong>orient</strong> </span>  “v” | “h”, optional</p><p>图的方向（垂直或水平）。这通常是根据输入变量的类型推断出来的，但是当<code>x</code>和<code>y</code>都是数字或绘制宽格式数据时，它可用于解决歧义。</p><p><span style ="color:#FF6347"><strong>color</strong> </span>  matplotlib color, optional</p><p>所有元素的颜色，或渐变调色板的种子。</p><p><span style ="color:#FF6347"><strong>palette</strong> </span>  palette name, list, or dict</p><p>用于<code>hue</code>变量不同级别的颜色。应该是可以解释的东西<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>，或者是将色调级别映射到 matplotlib 颜色的字典。</p><p><strong>saturation</strong>  float, optional</p><p>绘制颜色的原始饱和度的比例。大色块通常在颜色稍微不饱和的情况下看起来更好，但<code>1</code>如果您希望绘图颜色与输入颜色规格完美匹配，请将其设置为 。</p><p><strong>dodge</strong>  bool, optional</p><p>使用色调嵌套时，元素是否应沿分类轴移动。</p><p><strong>ax</strong>  matplotlib Axes, optional</p><p>要在其上绘制绘图的 Axes 对象，否则使用当前 Axes。</p><p><strong>kwargs</strong>  key, value mappings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar"><code>matplotlib.axes.Axes.bar()</code></a>.</p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="Examples-8"><a href="#Examples-8" class="headerlink" title="Examples"></a>Examples</h3><p>显示单个分类变量的值计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> snssns.set_theme(style=<span class="string">&quot;darkgrid&quot;</span>)titanic = sns.load_dataset(<span class="string">&quot;titanic&quot;</span>)ax = sns.countplot(x=<span class="string">&quot;class&quot;</span>, data=titanic)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-1.png"></p><p>显示两个分类变量的值计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.countplot(x=<span class="string">&quot;class&quot;</span>, hue=<span class="string">&quot;who&quot;</span>, data=titanic)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-2.png"></p><p>水平绘制条形图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.countplot(y=<span class="string">&quot;class&quot;</span>, hue=<span class="string">&quot;who&quot;</span>, data=titanic)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-3.png"></p><p>使用不同的调色板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.countplot(x=<span class="string">&quot;who&quot;</span>, data=titanic, palette=<span class="string">&quot;Set3&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-4.png"></p><p>使用<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar"><code>matplotlib.axes.Axes.bar()</code></a>参数来控制样式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = sns.countplot(x=<span class="string">&quot;who&quot;</span>, data=titanic,...                    facecolor=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),...                    linewidth=<span class="number">5</span>,...                    edgecolor=sns.color_palette(<span class="string">&quot;dark&quot;</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-5.png"></p><p>使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>结合一<a href="http://seaborn.pydata.org/generated/seaborn.countplot.html#seaborn.countplot"><code>countplot()</code></a>和 <a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。这允许在其他分类变量内进行分组。使用<a href="http://seaborn.pydata.org/generated/seaborn.catplot.html#seaborn.catplot"><code>catplot()</code></a>比<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a> 直接使用更安全，因为它确保跨方面的变量顺序同步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;class&quot;</span>, hue=<span class="string">&quot;who&quot;</span>, col=<span class="string">&quot;survived&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=titanic, kind=<span class="string">&quot;count&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                height=<span class="number">4</span>, aspect=<span class="number">.7</span>);</span><br></pre></td></tr></table></figure><p><img src="http://seaborn.pydata.org/_images/seaborn-countplot-6.png"></p><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Python Seaborn(多样化)</title>
    <link href="http://yoursite.com/2021/06/06/Python-Seaborn-%E5%A4%9A%E6%A0%B7%E5%8C%96/"/>
    <id>http://yoursite.com/2021/06/06/Python-Seaborn-%E5%A4%9A%E6%A0%B7%E5%8C%96/</id>
    <published>2021-06-06T13:48:32.000Z</published>
    <updated>2021-06-06T14:38:05.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g = sns.catplot(x=<span class="string">&quot;who&quot;</span>, y=<span class="string">&quot;survived&quot;</span>, col=<span class="string">&quot;class&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                data=titanic, saturation=<span class="number">.5</span>,</span><br><span class="line"><span class="meta">... </span>                kind=<span class="string">&quot;bar&quot;</span>, ci=<span class="literal">None</span>, aspect=<span class="number">.6</span>)</span><br><span class="line">(g.set_axis_labels(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Survival Rate&quot;</span>)</span><br><span class="line"><span class="meta">... </span>  .set_xticklabels([<span class="string">&quot;Men&quot;</span>, <span class="string">&quot;Women&quot;</span>, <span class="string">&quot;Children&quot;</span>])</span><br><span class="line"><span class="meta">... </span>  .set_titles(<span class="string">&quot;&#123;col_name&#125; &#123;col_var&#125;&quot;</span>)</span><br><span class="line"><span class="meta">... </span>  .<span class="built_in">set</span>(ylim=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span>  .despine(left=<span class="literal">True</span>)) </span><br></pre></td></tr></table></figure><p>常用方法：</p><table><thead><tr><th>函数</th><th>函数说明</th></tr></thead><tbody><tr><td><code>add_legend</code>（[legend_data，title，label_order]）</td><td>绘制一个图例，可能将其放在轴外并调整图形大小。</td></tr><tr><td><code>despine</code></td><td>从小平面上移除轴刺。<code>left/right/bottom=True</code></td></tr><tr><td><code>savefig</code>（* args，** kwargs）</td><td>保存图。</td></tr><tr><td><code>set_axis_labels</code>（[“x_var”，”y_var”]）</td><td>在网格的左列和底行设置轴标签。</td></tr><tr><td><code>set_titles</code>（[template，row_template，…]）</td><td>在每个构面上方或网格边距上绘制标题。</td></tr><tr><td><code>set_xlabels</code>([label])</td><td>在网格的底行标记x轴。</td></tr><tr><td><code>set_xticklabels</code>([“xxx”, “xxx”, “xxx”,…])</td><td>在网格的底行设置x轴刻度标签。</td></tr><tr><td><code>set_ylabels</code>([label])</td><td>在网格的左列标记y轴。</td></tr><tr><td><code>set_yticklabels</code>([“xxx”, “xxx”, “xxx”,…])</td><td>在网格的左列上设置y轴刻度标签。</td></tr><tr><td><code>share&#123;x,y&#125;</code></td><td>是否共享x轴或者y轴。<code>sharex/sharey=True</code></td></tr><tr><td><code>dodge</code></td><td>沿分类轴分离不同色调级别的条带<code>dodge=True</code></td></tr><tr><td><code>edgecolor</code></td><td>亮度由用于点主体的调色板确定<code>edgecolor=True</code></td></tr><tr><td><code>inner</code></td><td>小提琴内部数据点的表示<code>&#123;“box”, “quartile”, “point”, “stick”, None&#125;</code></td></tr><tr><td><code>scale</code></td><td>用于缩放每把小提琴的宽度的方法<code>&#123;“area”, “count”, “width”&#125;</code></td></tr><tr><td><code>saturation</code></td><td>绘制颜色的原始饱和度的比例</td></tr><tr><td><code>split</code></td><td><code>&#123;“True”, “False”&#125;</code></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>Boxenplot:</p><p>如果为 False，则禁止绘制异常值</p><p><code>showfliers=False</code></p><p>Pointplot:</p><p>如果为 False，则去除画一条连接每个点的线</p><p><code>join=False</code></p><p>将“caps”添加到误差条中</p><p><code>capsize=.2</code></p><p>Barplot:</p><p>围绕估计值绘制的置信区间的大小。如果为“sd”，则跳过引导并绘制观测值的标准偏差。如果<code>None</code>，则不会执行引导，并且不会绘制误差线。</p><p><code>ci=None</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Python Seaborn</title>
    <link href="http://yoursite.com/2021/06/03/Python-Seaborn/"/>
    <id>http://yoursite.com/2021/06/03/Python-Seaborn/</id>
    <published>2021-06-03T13:57:32.000Z</published>
    <updated>2021-06-14T04:33:04.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Seaborn-属性速查"><a href="#Seaborn-属性速查" class="headerlink" title="Seaborn 属性速查"></a>Seaborn 属性速查</h1><h2 id="markers"><a href="#markers" class="headerlink" title="markers"></a>markers</h2><p><a href="https://matplotlib.org/api/markers_api.html?highlight=marker#module-matplotlib.markers">https://matplotlib.org/api/markers_api.html?highlight=marker#module-matplotlib.markers</a></p><h1 id="Seaborn-样式"><a href="#Seaborn-样式" class="headerlink" title="Seaborn 样式"></a>Seaborn 样式</h1><h2 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h2><ul><li><p><strong>设置Style、Context的三种方法：</strong></p><ul><li>set  ：通用设置接口</li><li>set_style  ： 专用设置接口，设置后全局随之改变</li><li>axes_style  ：设置当前图（axes级），同时返回设置后的系列参数，支持with关键字用法。</li></ul></li><li><p><strong>Style:</strong></p><ul><li>darkgrid  :  默认风格</li><li>dark  :</li><li>whitegrid  :</li><li>white. :</li><li>ticks  :</li></ul></li></ul><p>style对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic//img/seabornstyle.png"></p><ul><li><strong>context:</strong><ul><li>notebook  ：默认环境</li><li>paper</li><li>talk</li><li>poster</li></ul></li></ul><p>context对比图：</p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic//img/seaborncontext.png"></p><h2 id="color"><a href="#color" class="headerlink" title="color"></a>color</h2><ul><li><strong>Color：</strong><ul><li>color_palett  ：基于RGB原理设置颜色的接口，可接收一个调色板对象作为参数，同时可以设置颜色数量。</li><li>hls_palett  ： 基于Hue(色相)、Luminance(亮度)、Saturation(饱和度)原理设置颜色的接口，除了颜色数量参数外，另外3个重要参数即是hls。</li></ul></li></ul><p>Color对比图</p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic//img/seaborncolor.png"></p><h2 id="palette"><a href="#palette" class="headerlink" title="palette"></a>palette</h2><p>自定义颜色板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flatui = [<span class="string">&quot;#9b59b6&quot;</span>, <span class="string">&quot;#3498db&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line">sns.set_palette(flatui)</span><br><span class="line">sns.lmplot( x=<span class="string">&quot;sepal_length&quot;</span>, y=<span class="string">&quot;sepal_width&quot;</span>, data=df, fit_reg=<span class="literal">False</span>, hue=<span class="string">&#x27;species&#x27;</span>, legend=<span class="literal">False</span>);</span><br></pre></td></tr></table></figure><p>调色板调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(palette=<span class="string">&quot;XXX&quot;</span>)</span><br></pre></td></tr></table></figure><p>seaborn有三种类型的调色板: Sequential, Diverging and Discrete:</p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/palette/palette1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/palette/palette2.png"></p><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/palette/palette3.png"></p><h2 id="axis"><a href="#axis" class="headerlink" title="axis"></a>axis</h2><p><strong>tittle:</strong>  <em>需要调用matplotlib xlabel/ylabel</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&#x27;XXX&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, color = <span class="string">&#x27;orange&#x27;</span>, fontsize=<span class="string">&#x27;17&#x27;</span>, horizontalalignment=<span class="string">&#x27;center&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>ticks:</strong> <em>调用matplotlib tick_params</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.tick_params(axis=<span class="string">&#x27;x&#x27;</span>, colors=<span class="string">&#x27;red&#x27;</span>, direction=<span class="string">&#x27;out&#x27;</span>, length=<span class="number">15</span>, width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>labels:</strong>  <em>调用matplotlib xticks/yticks</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(y_pos, bars, color=<span class="string">&#x27;orange&#x27;</span>, rotation=<span class="number">45</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="string">&#x27;17&#x27;</span>, horizontalalignment=<span class="string">&#x27;right&#x27;</span>);</span><br><span class="line"><span class="comment"># rotatio:  逆时针旋转角度</span></span><br></pre></td></tr></table></figure><p><strong>limit:</strong>  <em>调用matplotlib xlim/ylim</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim(0,20);</span><br><span class="line">plt.ylim(0,50);</span><br></pre></td></tr></table></figure><h2 id="Add-annotations"><a href="#Add-annotations" class="headerlink" title="Add annotations"></a>Add annotations</h2><ul><li>添加文本 add text</li><li>添加长方形 add rectangle</li><li>添加圆 add circle</li><li>添加参考线 add reference line</li><li>添加公式 add formula</li></ul><div class="tabs" id="test5"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test5-1">text</button></li><li class="tab"><button type="button" data-href="#test5-2">rectangle</button></li><li class="tab"><button type="button" data-href="#test5-3">circle</button></li><li class="tab"><button type="button" data-href="#test5-4">reference line</button></li><li class="tab"><button type="button" data-href="#test5-5">formula</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test5-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文本 add text</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Annotate with text + Arrow 添加文本和箭头</span></span><br><span class="line">plt.annotate(</span><br><span class="line"><span class="comment"># Label and coordinate</span></span><br><span class="line"><span class="comment"># xy箭头尖的坐标，xytest文本起始位置</span></span><br><span class="line"><span class="string">&#x27;This point is interesting!&#x27;</span>, xy=(<span class="number">20</span>, <span class="number">40</span>), xytext=(<span class="number">0</span>, <span class="number">80</span>),</span><br><span class="line"><span class="comment"># Custom arrow 添加箭头</span></span><br><span class="line">arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, shrink=<span class="number">0.05</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations1.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加长方形 add rectangle</span></span><br><span class="line"><span class="comment"># libraries</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Data 数据</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig1 = plt.figure()</span><br><span class="line"><span class="comment"># 添加子图</span></span><br><span class="line">ax1 = fig1.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add rectangle 添加长方形</span></span><br><span class="line">ax1.add_patch(</span><br><span class="line">    patches.Rectangle(</span><br><span class="line">        (<span class="number">20</span>, <span class="number">25</span>), <span class="comment"># (x,y) 左上角坐标</span></span><br><span class="line">        <span class="number">50</span>, <span class="number">50</span>, <span class="comment"># width and height 宽高</span></span><br><span class="line">        <span class="comment"># You can add rotation as well with &#x27;angle&#x27;</span></span><br><span class="line">        alpha=<span class="number">0.3</span>, facecolor=<span class="string">&quot;red&quot;</span>, edgecolor=<span class="string">&quot;black&quot;</span>, linewidth=<span class="number">3</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations2.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加圆 add circle</span></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig1 = plt.figure()</span><br><span class="line">ax1 = fig1.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line">ax1.add_patch(</span><br><span class="line">    patches.Circle(</span><br><span class="line">        (<span class="number">40</span>, <span class="number">35</span>), <span class="comment"># (x,y) 圆心</span></span><br><span class="line">        <span class="number">30</span>, <span class="comment"># radius 半径</span></span><br><span class="line">        alpha=<span class="number">0.3</span>, facecolor=<span class="string">&quot;green&quot;</span>, edgecolor=<span class="string">&quot;black&quot;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations3.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加参考线 add reference line</span></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line"><span class="comment"># 添加垂直参考线</span></span><br><span class="line">plt.axvline(<span class="number">40</span>, color=<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="comment"># 添加水平参考系</span></span><br><span class="line">plt.axhline(<span class="number">50</span>, color=<span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations4.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-5"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加公式 add formula</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line">plt.text(<span class="number">40</span>, <span class="number">00</span>, <span class="string">r&#x27;equation: $\sum_&#123;i=0&#125;^\infty x_i$&#x27;</span>, fontsize=<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations5.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Seaborn" scheme="http://yoursite.com/tags/Python-Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>Python Matplotlib</title>
    <link href="http://yoursite.com/2021/06/03/Python-Matplotlib/"/>
    <id>http://yoursite.com/2021/06/03/Python-Matplotlib/</id>
    <published>2021-06-03T12:44:07.000Z</published>
    <updated>2021-06-06T14:32:36.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用速查"><a href="#常用速查" class="headerlink" title="常用速查"></a>常用速查</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li>创建图表对象和创建子图对象的函数</li></ul><table><thead><tr><th>函数名</th><th>函数说明</th></tr></thead><tbody><tr><td>figure()</td><td>创建一个图表对象，可以指定图表的标识ID、宽度和高度、背景色、边框等。</td></tr><tr><td>subplot()</td><td>可以讲一个图表化成多个子图进行绘制，该函数用来设置子图，第一个参数是行，第二个参数是列。</td></tr><tr><td>subplots()</td><td>该函数返回Figure对象和子图对应的Axes对象数组，Axes是可以进行绘图操作的对象。</td></tr></tbody></table><ul><li>添加标签、绘制图形和添加图例的常用函数</li></ul><table><thead><tr><th>函数名</th><th>函数说明</th></tr></thead><tbody><tr><td>plot()</td><td>创建Figure对象后，接下来会调用plot()在当前Figure对象绘图。plot()的前两个参数是表示x,y轴数据的对象，后面参数是一个格式化字符串，由颜色字符、风格字符和标记字符组成。</td></tr><tr><td>titlt()</td><td>在当前子图中添加标题，可以指定标题的名称、位置、颜色、字体大小等参数。</td></tr><tr><td>xlabel()、ylabel()</td><td>添加x轴、y轴名称。</td></tr><tr><td>xlim()、ylim()</td><td>设置当前图表的x轴和y轴的取值范围，只能确定一个数值区间</td></tr><tr><td>xticks()、yticks()</td><td>指定x轴和y轴刻度的数目与取值</td></tr><tr><td>legend()</td><td>设置图例，可以设置图例的位置、列数、字体参数、边框等、</td></tr><tr><td>grid()</td><td>添加图表网格线</td></tr></tbody></table><ul><li>保存和显示图形的常用函数</li></ul><table><thead><tr><th>函数名</th><th>函数说明</th></tr></thead><tbody><tr><td>sacefig()</td><td>保存绘制的图形到文件中，可以指定图形的分辨率、边缘的颜色等参数</td></tr><tr><td>show()</td><td>在本机上显示图形</td></tr></tbody></table><h2 id="常用属性速查"><a href="#常用属性速查" class="headerlink" title="常用属性速查"></a>常用属性速查</h2><h3 id="rcParams"><a href="#rcParams" class="headerlink" title="rcParams"></a>rcParams</h3><p>基本属性</p><table><thead><tr><th>属性</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>plt.rcParams[’<code>axes.unicode_minus</code>’] = False</td><td>字符显示</td></tr><tr><td>plt.rcParams[’<code>font.sans-serif</code>’] = ‘SimHei’</td><td>设置字体</td></tr></tbody></table><p>线条样式：lines</p><table><thead><tr><th>属性</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>plt.rcParams[’<code>lines.linestyle</code>’] = ‘-.’</td><td>线条样式</td></tr><tr><td>plt.rcParams[’<code>lines.linewidth</code>’] = 3</td><td>线条宽度</td></tr><tr><td>plt.rcParams[’<code>lines.color</code>’] = ‘blue’</td><td>线条颜色</td></tr><tr><td>plt.rcParams[’<code>lines.marker</code>’] = None</td><td>默认标记</td></tr><tr><td>plt.rcParams[’<code>lines.markersize</code>’] = 6</td><td>标记大小</td></tr><tr><td>plt.rcParams[’<code>lines.markeredgewidth</code>’] = 0.5</td><td>标记附近的线宽</td></tr></tbody></table><p>横、纵轴：xtick、ytick</p><table><thead><tr><th>属性</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>plt.rcParams[’<code>xtick.labelsize</code>’]</td><td>横轴字体大小</td></tr><tr><td>plt.rcParams[’<code>ytick.labelsize</code>’]</td><td>纵轴字体大小</td></tr><tr><td>plt.rcParams[’<code>xtick.major.size</code>’]</td><td>x轴最大刻度</td></tr><tr><td>plt.rcParams[’<code>ytick.major.size</code>’]</td><td>y轴最大刻度</td></tr></tbody></table><p>figure中的子图：axes</p><table><thead><tr><th>属性</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>plt.rcParams[’<code>axes.titlesize</code>’]</td><td>子图的标题大小</td></tr><tr><td>plt.rcParams[’<code>axes.labelsize</code>’]</td><td>子图的标签大小</td></tr></tbody></table><p>图像、图片：figure、savefig</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>plt.rcParams[’<code>figure.dpi</code>’]</td><td>图像分辨率</td></tr><tr><td>plt.rcParams[’<code>figure.figsize</code>’]</td><td>图像显示大小</td></tr><tr><td>plt.rcParams[’<code>savefig.dpi</code>’]</td><td></td></tr></tbody></table><h3 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h3><div class="note warning flat"><p><code>seaborn.relplot</code></p><p><code>seaborn.scatterplot</code></p><p><code>seaborn.lineplot</code></p></div><p><strong>属性参数配置如下：</strong></p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">Relplot</button></li><li class="tab"><button type="button" data-href="#test3-2">Scatterplot</button></li><li class="tab"><button type="button" data-href="#test3-3">Lineplot</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><ul><li><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p></li><li><p><span style ="color:#FF6347"><strong>hue</strong> </span>   vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>size</strong> </span>   vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>style</strong> </span>  vector or key in <code>data</code></p><p>将生成具有不同样式的元素的分组变量。可以有一个数字 dtype，但将始终被视为分类。</p></li><li><p><span style ="color:#FF6347"><strong>data</strong> </span>   <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长形式向量集合或将在内部重塑的宽形式数据集。</p></li><li><p><span style ="color:#FF6347"><strong>row, col</strong> </span>   vectors or keys in <code>data</code></p><p>定义子集以在不同方面绘制的变量。</p></li><li><p><strong>col_wrap</strong>  int</p><p>以此宽度“包裹”列变量，以便列面跨越多行。与一个<code>row</code>方面不兼容。</p></li><li><p><strong>row_order, col_order</strong>  lists of strings</p><p>组织网格的行和/或列的顺序，否则从数据对象推断顺序。</p></li><li><p><span style ="color:#FF6347"><strong>palette</strong> </span>   string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>调色板，在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p></li><li><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p></li><li><p><strong>hue_norm</strong>t  uple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p></li><li><p><span style ="color:#FF6347"><strong>sizes</strong> </span>   list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p></li><li><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p></li><li><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p></li><li><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p></li><li><p><strong>dashes</strong>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制线条的对象 。设置为<code>True</code>将使用默认破折号，或者您可以传递破折号列表或<code>style</code>变量的字典映射级别 到破折号。设置为<code>False</code>将对所有子集使用实线。破折号在 matplotlib 中指定：长度元组，或绘制实线的空字符串。<code>(segment, gap)</code></p></li><li><p><span style ="color:#FF6347"><strong>markers</strong> </span>   boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p></li><li><p><span style ="color:#FF6347"><strong>legend</strong> </span>   “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p></li><li><p><strong>kind</strong>  string</p><p>要绘制的图，对应于 seaborn 关系图。选项是 {<code>scatter</code>和<code>line</code>}。</p></li><li><p><strong>height</strong>  scalar</p><p>每个刻面的高度（以英寸为单位）。另见：<code>aspect</code>。</p></li><li><p><strong>aspect</strong>  scalar</p><p>每个刻面的纵横比，从而以英寸为单位给出每个刻面的宽度。<code>aspect * height</code></p></li><li><p><strong>facet_kws</strong>  dict</p><p>要传递给的其他关键字参数的字典<a href="http://seaborn.pydata.org/generated/seaborn.FacetGrid.html#seaborn.FacetGrid"><code>FacetGrid</code></a>。</p></li><li><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量标识抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。</p></li><li><p><strong>kwargs</strong>  key, value pairings</p><p>其他关键字参数将传递给底层绘图函数。</p></li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><ul><li><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p></li><li><p><span style ="color:#FF6347"><strong>hue</strong> </span>   vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>size</strong> </span>   vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>style</strong> </span>  vector or key in <code>data</code></p><p>分组变量将产生具有不同破折号和/或标记的线条。可以有一个数字 dtype，但将始终被视为分类。</p></li><li><p><span style ="color:#FF6347"><strong>data</strong> </span>   <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长形式向量集合或将在内部重塑的宽形式数据集。</p></li><li><p><span style ="color:#FF6347"><strong>palette</strong> </span>   string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>调色板，在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p></li><li><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p></li><li><p><strong>hue_norm</strong>  uple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p></li><li><p><span style ="color:#FF6347"><strong>sizes</strong> </span>   list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p></li><li><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p></li><li><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p></li><li><p><span style ="color:#FF6347"><strong>markers</strong> </span>   boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p></li><li><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p></li><li><p><strong>{x,y}_bins</strong>  lists or arrays or functions</p><p>目前无功能。</p></li><li><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量标识抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。</p></li><li><p><strong>estimator</strong>  name of pandas method or callable or None</p><p>聚合<code>y</code> 同一<code>x</code>级别变量的多个观察值的方法。如果<code>None</code>，则将绘制所有观察值。</p></li><li><p><strong>ci</strong>  int or “sd” or None</p><p>与估计器聚合时要绘制的置信区间的大小。“sd”表示绘制数据的标准偏差。设置为<code>None</code>将跳过引导。</p></li><li><p><strong>n_boot</strong>  int</p><p>用于计算置信区间的引导程序数。</p></li><li><p><span style ="color:#FF6347"><strong>alpha</strong> </span>   float</p><p>点的比例不透明度。</p></li><li><p><strong>{x,y}_jitter</strong>  booleans or floats</p><p><em>目前无功能。</em></p></li><li><p><span style ="color:#FF6347"><strong>legend</strong> </span>   “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p></li><li><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p></li><li><p><strong>kwargs</strong>  key, value pairings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot"><code>matplotlib.axes.Axes.plot()</code></a>。</p></li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><ul><li><p><span style ="color:#FF6347"><strong>x, y</strong> </span>   vectors or keys in <code>data</code></p><p>指定 x 轴和 y 轴位置的变量。</p></li><li><p><span style ="color:#FF6347"><strong>hue</strong> </span>   vector or key in <code>data</code></p><p>将产生具有不同颜色的元素的分组变量。可以是分类的或数字的，尽管颜色映射在后一种情况下的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>size</strong> </span>   vector or key in <code>data</code></p><p>将产生不同大小元素的分组变量。可以是分类的或数字的，尽管在后一种情况下大小映射的行为会有所不同。</p></li><li><p><span style ="color:#FF6347"><strong>style</strong> </span>  vector or key in <code>data</code></p><p>分组变量将产生具有不同破折号和/或标记的线条。可以有一个数字 dtype，但将始终被视为分类。</p></li><li><p><span style ="color:#FF6347"><strong>data</strong> </span>   <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>pandas.DataFrame</code></a>, <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray"><code>numpy.ndarray</code></a>, mapping, or sequence</p><p>输入数据结构。可以分配给命名变量的长形式向量集合或将在内部重塑的宽形式数据集。</p></li><li><p><span style ="color:#FF6347"><strong>palette</strong> </span>   string, list, dict, or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap"><code>matplotlib.colors.Colormap</code></a></p><p>调色板，在映射<code>hue</code>语义时选择要使用的颜色的方法。字符串值传递给<a href="http://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette"><code>color_palette()</code></a>. List 或 dict 值意味着分类映射，而 colormap 对象意味着数字映射。</p></li><li><p><strong>hue_order</strong>  vector of strings</p><p>指定<code>hue</code>语义分类级别的处理和绘图顺序 。</p></li><li><p><strong>hue_norm</strong>  uple or <a href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Normalize.html#matplotlib.colors.Normalize"><code>matplotlib.colors.Normalize</code></a></p><p>以数据单位设置归一化范围的一对值或将从数据单位映射到 [0, 1] 区间的对象。用法意味着数字映射。</p></li><li><p><span style ="color:#FF6347"><strong>sizes</strong> </span>   list, dict, or tuple</p><p>确定使用时如何选择大小的对象<code>size</code>。它始终可以是大小值列表或<code>size</code>变量到大小的字典映射级别 。当<code>size</code>是数字时，它也可以是一个元组，指定要使用的最小和最大大小，以便其他值在此范围内标准化。</p></li><li><p><strong>size_order</strong>  list</p><p><code>size</code>变量级别出现的指定顺序，否则根据数据确定。当<code>size</code>变量是数字时不相关 。</p></li><li><p><strong>size_norm</strong>  tuple or Normalize object</p><p>当<code>size</code>变量为数值时，用于缩放绘图对象的数据单位标准化 。</p></li><li><p><strong>dashes</strong>  boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制线条的对象 。设置为<code>True</code>将使用默认破折号，或者您可以传递破折号列表或<code>style</code>变量的字典映射级别 到破折号。设置为<code>False</code>将对所有子集使用实线。破折号在 matplotlib 中指定：长度元组，或绘制实线的空字符串。<code>(segment, gap)</code></p></li><li><p><span style ="color:#FF6347"><strong>markers</strong> </span>   boolean, list, or dictionary</p><p>确定如何为<code>style</code>变量的不同级别绘制标记的对象 。设置为<code>True</code>将使用默认标记，或者您可以将标记列表或<code>style</code>变量的字典映射级别传递 给标记。设置为<code>False</code>将绘制无标记线。标记在 matplotlib 中指定。</p></li><li><p><strong>style_order</strong>  list</p><p><code>style</code>变量级别出现的指定顺序，否则它们由数据确定。当<code>style</code>变量是数字时不相关 。</p></li><li><p><strong>units</strong>  vector or key in <code>data</code></p><p>分组变量标识抽样单位。使用时，将为每个具有适当语义的单元绘制一条单独的线，但不会添加图例条目。当不需要确切的身份时，可用于显示实验重复的分布。</p></li><li><p><strong>estimator</strong>  name of pandas method or callable or None</p><p>聚合<code>y</code> 同一<code>x</code>级别变量的多个观察值的方法。如果<code>None</code>，则将绘制所有观察值。</p></li><li><p><strong>ci</strong>  int or “sd” or None</p><p>与估计器聚合时要绘制的置信区间的大小。“sd”表示绘制数据的标准偏差。设置为<code>None</code>将跳过引导。</p></li><li><p><strong>n_boot</strong>  int</p><p>用于计算置信区间的引导程序数。</p></li><li><p><strong>seed</strong>  int, numpy.random.Generator, or numpy.random.RandomState</p><p>用于可重复引导的种子或随机数生成器。</p></li><li><p><span style ="color:#FF6347"><strong>sort</strong> </span>   boolean</p><p>如果为 True，数据将按 x 和 y 变量排序，否则线将按照它们在数据集中出现的顺序连接点。</p></li><li><p><strong>err_style</strong>  “band” or “bars”</p><p>是否使用半透明误差带或离散误差线绘制置信区间。</p></li><li><p><strong>err_kws</strong>  dict of keyword arguments</p><p>控制误差线美观的附加参数。kwargs 传递给<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.fill_between.html#matplotlib.axes.Axes.fill_between"><code>matplotlib.axes.Axes.fill_between()</code></a> 或<a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.errorbar.html#matplotlib.axes.Axes.errorbar"><code>matplotlib.axes.Axes.errorbar()</code></a>，具体取决于<code>err_style</code>。</p></li><li><p><span style ="color:#FF6347"><strong>legend</strong> </span>   “auto”, “brief”, “full”, or False</p><p>如何绘制图例。如果“简短”，数字<code>hue</code>和<code>size</code> 变量将用均匀间隔值的样本表示。如果“已满”，则每个组都将在图例中获得一个条目。如果是“自动”，则根据级别数在简短或完整表示之间进行选择。如果<code>False</code>，则不添加图例数据且不绘制图例。</p></li><li><p><strong>ax</strong>  <a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes"><code>matplotlib.axes.Axes</code></a></p><p>绘图的预先存在的轴。否则，<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.gca.html#matplotlib.pyplot.gca"><code>matplotlib.pyplot.gca()</code></a> 内部调用。</p></li><li><p><strong>kwargs</strong>  key, value pairings</p><p>其他关键字参数传递给 <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot"><code>matplotlib.axes.Axes.plot()</code></a>。</p></li></ul><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="常用处理"><a href="#常用处理" class="headerlink" title="常用处理"></a>常用处理</h2><ul><li><p>设置中文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">font=&#123;</span><br><span class="line">  <span class="string">&#x27;family&#x27;</span>:<span class="string">&quot;SimHei&quot;</span>,</span><br><span class="line">  <span class="string">&quot;weight&quot;</span>:<span class="string">&quot;blod&quot;</span>,</span><br><span class="line">  <span class="string">&quot;size&quot;</span>:<span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">plt.rc(<span class="string">&quot;font&quot;</span>,**font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&quot;SimHei&quot;</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;font.size&quot;</span>] = <span class="number">16</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>处理负号显示问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rc(<span class="string">&quot;axes&quot;</span>.unicode_minus=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Matplotlib-样式"><a href="#Matplotlib-样式" class="headerlink" title="Matplotlib 样式"></a>Matplotlib 样式</h1><h2 id="axis"><a href="#axis" class="headerlink" title="axis"></a>axis</h2><p><strong>tittle:</strong>  <em>需要调用matplotlib xlabel/ylabel</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&#x27;XXX&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, color = <span class="string">&#x27;orange&#x27;</span>, fontsize=<span class="string">&#x27;17&#x27;</span>, horizontalalignment=<span class="string">&#x27;center&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>ticks:</strong> <em>调用matplotlib tick_params</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.tick_params(axis=<span class="string">&#x27;x&#x27;</span>, colors=<span class="string">&#x27;red&#x27;</span>, direction=<span class="string">&#x27;out&#x27;</span>, length=<span class="number">15</span>, width=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>labels:</strong>  <em>调用matplotlib xticks/yticks</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(y_pos, bars, color=<span class="string">&#x27;orange&#x27;</span>, rotation=<span class="number">45</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="string">&#x27;17&#x27;</span>, horizontalalignment=<span class="string">&#x27;right&#x27;</span>);</span><br><span class="line"><span class="comment"># rotatio:  逆时针旋转角度</span></span><br></pre></td></tr></table></figure><p><strong>limit:</strong>  <em>调用matplotlib xlim/ylim</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim(0,20);</span><br><span class="line">plt.ylim(0,50);</span><br></pre></td></tr></table></figure><h2 id="Add-annotations"><a href="#Add-annotations" class="headerlink" title="Add annotations"></a>Add annotations</h2><ul><li>添加文本 add text</li><li>添加长方形 add rectangle</li><li>添加圆 add circle</li><li>添加参考线 add reference line</li><li>添加公式 add formula</li></ul><div class="tabs" id="test5"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test5-1">text</button></li><li class="tab"><button type="button" data-href="#test5-2">rectangle</button></li><li class="tab"><button type="button" data-href="#test5-3">circle</button></li><li class="tab"><button type="button" data-href="#test5-4">reference line</button></li><li class="tab"><button type="button" data-href="#test5-5">formula</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test5-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文本 add text</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Annotate with text + Arrow 添加文本和箭头</span></span><br><span class="line">plt.annotate(</span><br><span class="line"><span class="comment"># Label and coordinate</span></span><br><span class="line"><span class="comment"># xy箭头尖的坐标，xytest文本起始位置</span></span><br><span class="line"><span class="string">&#x27;This point is interesting!&#x27;</span>, xy=(<span class="number">20</span>, <span class="number">40</span>), xytext=(<span class="number">0</span>, <span class="number">80</span>),</span><br><span class="line"><span class="comment"># Custom arrow 添加箭头</span></span><br><span class="line">arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, shrink=<span class="number">0.05</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations1.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加长方形 add rectangle</span></span><br><span class="line"><span class="comment"># libraries</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Data 数据</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig1 = plt.figure()</span><br><span class="line"><span class="comment"># 添加子图</span></span><br><span class="line">ax1 = fig1.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add rectangle 添加长方形</span></span><br><span class="line">ax1.add_patch(</span><br><span class="line">    patches.Rectangle(</span><br><span class="line">        (<span class="number">20</span>, <span class="number">25</span>), <span class="comment"># (x,y) 左上角坐标</span></span><br><span class="line">        <span class="number">50</span>, <span class="number">50</span>, <span class="comment"># width and height 宽高</span></span><br><span class="line">        <span class="comment"># You can add rotation as well with &#x27;angle&#x27;</span></span><br><span class="line">        alpha=<span class="number">0.3</span>, facecolor=<span class="string">&quot;red&quot;</span>, edgecolor=<span class="string">&quot;black&quot;</span>, linewidth=<span class="number">3</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations2.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加圆 add circle</span></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig1 = plt.figure()</span><br><span class="line">ax1 = fig1.add_subplot(<span class="number">111</span>)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line">ax1.add_patch(</span><br><span class="line">    patches.Circle(</span><br><span class="line">        (<span class="number">40</span>, <span class="number">35</span>), <span class="comment"># (x,y) 圆心</span></span><br><span class="line">        <span class="number">30</span>, <span class="comment"># radius 半径</span></span><br><span class="line">        alpha=<span class="number">0.3</span>, facecolor=<span class="string">&quot;green&quot;</span>, edgecolor=<span class="string">&quot;black&quot;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations3.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加参考线 add reference line</span></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line"><span class="comment"># 添加垂直参考线</span></span><br><span class="line">plt.axvline(<span class="number">40</span>, color=<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="comment"># 添加水平参考系</span></span><br><span class="line">plt.axhline(<span class="number">50</span>, color=<span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations4.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-5"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加公式 add formula</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), <span class="string">&#x27;y&#x27;</span>: np.random.randn(<span class="number">100</span>)*<span class="number">15</span>+<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) &#125;)</span><br><span class="line">sns.regplot( data=df, x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Annotation</span></span><br><span class="line">plt.text(<span class="number">40</span>, <span class="number">00</span>, <span class="string">r&#x27;equation: $\sum_&#123;i=0&#125;^\infty x_i$&#x27;</span>, fontsize=<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/JOEL-T99/Pic@master/python/annotations/annotations5.png"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Python - Matplotlib" scheme="http://yoursite.com/tags/Python-Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>数工-下午大题</title>
    <link href="http://yoursite.com/2021/05/11/%E6%95%B0%E5%B7%A5-%E4%B8%8B%E5%8D%88%E5%A4%A7%E9%A2%98/"/>
    <id>http://yoursite.com/2021/05/11/%E6%95%B0%E5%B7%A5-%E4%B8%8B%E5%8D%88%E5%A4%A7%E9%A2%98/</id>
    <published>2021-05-11T13:54:52.000Z</published>
    <updated>2021-05-12T09:45:56.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据流图设计"><a href="#数据流图设计" class="headerlink" title="数据流图设计"></a>数据流图设计</h1><ul><li><p><strong>问：如何保持数据流图平衡？</strong></p><p>父图中某个加工的输入输出数据流必须与其子图的输入输出数据流在数量上和名字上相同。父图的一个输入（或输出）数据流对应于子图中几个输入（或输出）数据流，而子图中组成的这些数据流的数据项全体正好是父图中的这一个数据流。 </p></li></ul><p>&nbsp;</p><ul><li><p><strong>问：请给出三种在绘制加工的输入、输出时可能出现的错误？</strong></p><p>只有输入而无输出或者黑洞</p><p>只有输出而无输入或者奇迹</p><p>输入的数据流无法通过加工产生输出流或者灰洞</p><p>输入的数据流与输出的数据流名称相同</p></li></ul><ul><li><p><strong>问：两个实体之间可否有数据流？</strong></p><p>数据流的起点和终点必须有一个加工（处理）</p></li></ul><h1 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h1><h1 id="关系模式设计"><a href="#关系模式设计" class="headerlink" title="关系模式设计"></a>关系模式设计</h1><p>函数依赖的定义是：当X值确定，则Y值必确定，称作Y函数依赖于X</p><p><strong>完全函数依赖：</strong>如果X只是一个属性，则Y函数依赖X的同时也是完全函数依赖。当X是一个属性组（比如复合主键），无论X的哪一个真子集确定，都无法确定Y的值，则称作Y完全函数依赖于X。</p><p><strong>部分函数依赖：</strong>X是一个属性组，并且当X的某一个真子集确定时，Y的值也随之确定，且Y依赖于X。再称作Y部分函数依赖于X。</p><p><strong>传递函数依赖：</strong>Y函数依赖于X，Z函数依赖于Y，并且X、Y没有任何依赖关系，且Y不是X的真子集，则称作Z传递函数依赖于X。</p><p>存在问题：数据冗余、更新复杂、插入异常、删除异常</p><p>第一范式：属性不能再分割。</p><p>第二范式：消除了非主属性对码的部分函数依赖，使得所有属性完全依赖于主键。</p><p>第三范式：消除了非主属性对码的传递函数依赖。</p><p><strong>第二范式消除了部分函数依赖，第三范式消除了传递函数依赖。</strong></p><ul><li><p><strong>问：用100字以内文字简要说明它会产生什么问题？</strong></p><p>根据“结算单”关系模式，可知其键为（流水号，条码），而又存在部分函数依赖：<br>条码—水果名称，销售单价，数量，金额，导购员编号<br>根据第二范式的要求：不存在非主属性对键的部分依赖。所以“结算单”关系模式不满足第二范式，会造成：插入异常、删除异常和修改异常。</p></li></ul><ul><li><p><strong>问：它是否是第四范式，用100字以内文字叙述理由？</strong></p><p>不属于第四范式。<br>根据“职责”关系模式可知：其键为（水果名称，采购员编号，导购员编号），而存在多值依赖：<br>水果名称――采购员编号<br>水果名称——导购员编号<br>根据第四范式的要求，不允许存在非平凡的多值依赖。因此，“职责”关系模式不满足第四范式。</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li><p><strong>如果两个用户同时查询相同日期和房间类别的空房数量，得到的空房数量为1，并且这两个用户又同时要求预订，可能会产生什么结果？</strong></p><p>同时预订时，可能会产生一个客户订不到或者把同一房订给两个客户。</p><p>两个用户同时查询相同日期和房间类别的空房数量，得到的空房数量为1，并且这两个用户又同时要求预订。预订的执行逻辑是用空房数量减去要预订的数量后，将值写入空房表。会造成丢失修改的不一致性。</p></li></ul><ul><li><p><strong>可能出现的执行序列为：xl=R（A），x2=R（A）,W（A,xl-al）,W（Bl,al）,W（A,x2-a2）,W（B2，a2）此时会出现什么问题？</strong></p><p>出现问题：丢失修改，客户1预订al数量房间后，对空房数量的修改被T2的修改覆盖，造成数据不一致。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>IE浏览器安全详情</title>
    <link href="http://yoursite.com/2021/04/22/IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E8%AF%A6%E6%83%85/"/>
    <id>http://yoursite.com/2021/04/22/IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E8%AF%A6%E6%83%85/</id>
    <published>2021-04-22T03:58:23.000Z</published>
    <updated>2021-04-22T04:27:31.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NET-Framework"><a href="#NET-Framework" class="headerlink" title=".NET Framework"></a>.NET Framework</h1><h3 id="XAML-浏览器应用程序"><a href="#XAML-浏览器应用程序" class="headerlink" title="XAML 浏览器应用程序"></a>XAML 浏览器应用程序</h3><p>Extensible Application Markup Language，相应的中文名称为可扩展应用程序标记语言，它是微软公司为构建应用程序用户界面而创建的一种新的描述性语言，是 .NET Framework中用来描述UI的。</p><h3 id="XPS-文档"><a href="#XPS-文档" class="headerlink" title="XPS 文档"></a>XPS 文档</h3><p>XPS是 XML Paper Specification的简称，它是微软公司开发的一种文档保存与查看的规范。以前的开发代号为 “Metro”。这个规范本身描述了这种格式以及分发、归档、显示以及处理 XPS 文档所遵循的规则。最为显著的特点是，XPS 所用的置标语言是 WPF所用的 XAML的一个子集，因此显示 Windows应用程序所用的方法可以用于 XPS 文档。</p><p>人们认为 XPS 是 Adobe公司的 PDF的潜在竞争对手。但是，XPS 是一个静态文档格式，其本身不包括类似于 PDF 所具有的动态特性。微软公司指出高级认证的设备到2007年6月1日需要提供 XPSDrv 的解决方案。</p><h3 id="松散-XAML"><a href="#松散-XAML" class="headerlink" title="松散 XAML"></a>松散 XAML</h3><h1 id="NET-Framework-相关组件"><a href="#NET-Framework-相关组件" class="headerlink" title=".NET Framework 相关组件"></a>.NET Framework 相关组件</h1><h3 id="带有清单的权限的组件"><a href="#带有清单的权限的组件" class="headerlink" title="带有清单的权限的组件"></a>带有清单的权限的组件</h3><h3 id="运行未用-Authenticode-签名的组件"><a href="#运行未用-Authenticode-签名的组件" class="headerlink" title="运行未用 Authenticode 签名的组件"></a>运行未用 Authenticode 签名的组件</h3><p>一种对从web下载的应用的签名方法。</p><h1 id="ActiveX-控件和插件"><a href="#ActiveX-控件和插件" class="headerlink" title="ActiveX 控件和插件"></a>ActiveX 控件和插件</h1><h3 id="ActiveX-控件自动提示"><a href="#ActiveX-控件自动提示" class="headerlink" title="ActiveX 控件自动提示"></a>ActiveX 控件自动提示</h3><h3 id="对标记为可安全执行脚本的-ActiveX-控件执行脚本"><a href="#对标记为可安全执行脚本的-ActiveX-控件执行脚本" class="headerlink" title="对标记为可安全执行脚本的 ActiveX 控件执行脚本*"></a>对标记为可安全执行脚本的 ActiveX 控件执行脚本*</h3><p>ActiveX控件是必须下载到本地安装才能使用</p><p>这样就可以自由操作本机资源</p><p>如果安装了恶意ActiveX控件,会给系统安全造成极大破坏</p><p>建议不要开启，这样每次ActiveX控件要下载安装的时候，系统会提示你</p><p>这样你就可以自己选择是否安装,将不信任的网站中的ActiveX控件挡住</p><h3 id="二进制和脚本行为"><a href="#二进制和脚本行为" class="headerlink" title="二进制和脚本行为"></a>二进制和脚本行为</h3><p>禁用的话就是[5.12大地震知道吧，网页都是灰的，某网友发明了这个招，网页不灰了]启用的话<br>就是你家的网页随着网站的变化</p><h3 id="仅允许经过批准的域在未经提示的情况下使用-ActiveX"><a href="#仅允许经过批准的域在未经提示的情况下使用-ActiveX" class="headerlink" title="仅允许经过批准的域在未经提示的情况下使用 ActiveX"></a>仅允许经过批准的域在未经提示的情况下使用 ActiveX</h3><h3 id="下载未签名的-ActiveX-控件"><a href="#下载未签名的-ActiveX-控件" class="headerlink" title="下载未签名的 ActiveX 控件"></a>下载未签名的 ActiveX 控件</h3><p>签名的组件被认为是安全组件，允许运行即可以完成一定的功能。</p><h3 id="允许-ActiveX-筛选"><a href="#允许-ActiveX-筛选" class="headerlink" title="允许 ActiveX 筛选"></a>允许 ActiveX 筛选</h3><h3 id="允许Scriptlet"><a href="#允许Scriptlet" class="headerlink" title="允许Scriptlet"></a>允许Scriptlet</h3><p>Scriptlet是一种将一个页面打包成组件的轻量方法。</p><h3 id="允许运行以前未使用的-ActiveX-控件而不提示"><a href="#允许运行以前未使用的-ActiveX-控件而不提示" class="headerlink" title="允许运行以前未使用的 ActiveX 控件而不提示"></a>允许运行以前未使用的 ActiveX 控件而不提示</h3><h3 id="运行-ActiveX-控件和插件"><a href="#运行-ActiveX-控件和插件" class="headerlink" title="运行 ActiveX 控件和插件"></a>运行 ActiveX 控件和插件</h3><h3 id="在没有使用外部媒体播放机的网页上显示视频和动画"><a href="#在没有使用外部媒体播放机的网页上显示视频和动画" class="headerlink" title="在没有使用外部媒体播放机的网页上显示视频和动画"></a>在没有使用外部媒体播放机的网页上显示视频和动画</h3><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h3 id="Java-小程序脚本"><a href="#Java-小程序脚本" class="headerlink" title="Java 小程序脚本"></a>Java 小程序脚本</h3><p>脚本是网页中用编程语言写的代码，可以完成一定操作，可能是有害的，对于信任的站点可以允许加载和运行脚本。</p><h3 id="活动脚本"><a href="#活动脚本" class="headerlink" title="活动脚本"></a>活动脚本</h3><h3 id="启用-XSS-筛选器"><a href="#启用-XSS-筛选器" class="headerlink" title="启用 XSS 筛选器"></a>启用 XSS 筛选器</h3><h3 id="允许对剪贴板进行编程访问"><a href="#允许对剪贴板进行编程访问" class="headerlink" title="允许对剪贴板进行编程访问"></a>允许对剪贴板进行编程访问</h3><p>常用的“点击复制”类似的功能，需要考虑在禁用此项时的容错方案。</p><p>将文件上传到服务器时包含本地目录路径</p><p>若禁用，上传文件时将得到类似这样的地址：</p><p>C:\fakepath\xxxxxx.png</p><h3 id="允许网站使用脚本窗口提示获得信息"><a href="#允许网站使用脚本窗口提示获得信息" class="headerlink" title="允许网站使用脚本窗口提示获得信息"></a>允许网站使用脚本窗口提示获得信息</h3><h3 id="允许状态栏通过脚本更新"><a href="#允许状态栏通过脚本更新" class="headerlink" title="允许状态栏通过脚本更新"></a>允许状态栏通过脚本更新</h3><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="持续使用用户数据"><a href="#持续使用用户数据" class="headerlink" title="持续使用用户数据"></a>持续使用用户数据</h3><h3 id="加载应用程序和不安全文件"><a href="#加载应用程序和不安全文件" class="headerlink" title="加载应用程序和不安全文件"></a>加载应用程序和不安全文件</h3><h3 id="将文件上传到服务器时包含本地目录路径"><a href="#将文件上传到服务器时包含本地目录路径" class="headerlink" title="将文件上传到服务器时包含本地目录路径"></a>将文件上传到服务器时包含本地目录路径</h3><h3 id="跨域浏览窗口和框架"><a href="#跨域浏览窗口和框架" class="headerlink" title="跨域浏览窗口和框架"></a>跨域浏览窗口和框架</h3><h3 id="启用-MIME-探查"><a href="#启用-MIME-探查" class="headerlink" title="启用 MIME 探查"></a>启用 MIME 探查</h3><p>通过探查MIME类型来确定文件类型。不会将文件类型提升为更危险的文件类型。例如，以纯文本接收的但包含 HTML 代码的文件将不会提升为 HTML 类型，因为其中可能包含恶意代码。</p><h3 id="使用-SmartScreen-筛选器"><a href="#使用-SmartScreen-筛选器" class="headerlink" title="使用 SmartScreen 筛选器"></a>使用 SmartScreen 筛选器</h3><h3 id="使用弹出窗口阻止程序"><a href="#使用弹出窗口阻止程序" class="headerlink" title="使用弹出窗口阻止程序"></a>使用弹出窗口阻止程序</h3><h3 id="特权较少的-Web-内容区域中的网站可以定位到该区域"><a href="#特权较少的-Web-内容区域中的网站可以定位到该区域" class="headerlink" title="特权较少的 Web 内容区域中的网站可以定位到该区域"></a>特权较少的 Web 内容区域中的网站可以定位到该区域</h3><h3 id="提交非加密表单"><a href="#提交非加密表单" class="headerlink" title="提交非加密表单"></a>提交非加密表单</h3><h3 id="通过域访问数据源"><a href="#通过域访问数据源" class="headerlink" title="通过域访问数据源"></a>通过域访问数据源</h3><h3 id="拖放或复制和粘贴文件"><a href="#拖放或复制和粘贴文件" class="headerlink" title="拖放或复制和粘贴文件"></a>拖放或复制和粘贴文件</h3><h3 id="显示混合内容"><a href="#显示混合内容" class="headerlink" title="显示混合内容"></a>显示混合内容</h3><p>即在HTTPS的页面中包含HTTP的请求时，会出现提示。</p><h3 id="允许-META-REFRESH"><a href="#允许-META-REFRESH" class="headerlink" title="允许 META REFRESH"></a>允许 META REFRESH</h3><h3 id="允许-Microsoft-网页浏览器控件的脚本"><a href="#允许-Microsoft-网页浏览器控件的脚本" class="headerlink" title="允许 Microsoft 网页浏览器控件的脚本"></a>允许 Microsoft 网页浏览器控件的脚本</h3><h3 id="允许脚本初始化的窗口，不受大小或位置限制"><a href="#允许脚本初始化的窗口，不受大小或位置限制" class="headerlink" title="允许脚本初始化的窗口，不受大小或位置限制"></a>允许脚本初始化的窗口，不受大小或位置限制</h3><h3 id="允许网页使用活动内容受限协议"><a href="#允许网页使用活动内容受限协议" class="headerlink" title="允许网页使用活动内容受限协议"></a>允许网页使用活动内容受限协议</h3><h3 id="允许网站打开没有地址或状态栏的窗口"><a href="#允许网站打开没有地址或状态栏的窗口" class="headerlink" title="允许网站打开没有地址或状态栏的窗口"></a>允许网站打开没有地址或状态栏的窗口</h3><h3 id="在-IFRAME-中加载程序和文件"><a href="#在-IFRAME-中加载程序和文件" class="headerlink" title="在 IFRAME 中加载程序和文件"></a>在 IFRAME 中加载程序和文件</h3><h3 id="只存在一个证书时不提示进行客户端证书选择"><a href="#只存在一个证书时不提示进行客户端证书选择" class="headerlink" title="只存在一个证书时不提示进行客户端证书选择"></a>只存在一个证书时不提示进行客户端证书选择</h3><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><h3 id="字体下载"><a href="#字体下载" class="headerlink" title="字体下载"></a>字体下载</h3><h1 id="用户验证"><a href="#用户验证" class="headerlink" title="用户验证"></a>用户验证</h1><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数工 计算机系统精华知识点</title>
    <link href="http://yoursite.com/2021/04/14/%E6%95%B0%E5%B7%A5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%B2%BE%E5%8D%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2021/04/14/%E6%95%B0%E5%B7%A5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%B2%BE%E5%8D%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-04-14T07:52:32.000Z</published>
    <updated>2021-04-14T07:55:36.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工 知识点大纲</title>
    <link href="http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2/"/>
    <id>http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E7%BA%B2/</id>
    <published>2021-04-13T09:44:39.000Z</published>
    <updated>2021-04-14T07:53:05.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机系统知识"><a href="#计算机系统知识" class="headerlink" title="计算机系统知识"></a>计算机系统知识</h1><h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><h3 id="计算机体系结构和主要部件地基本工作原理"><a href="#计算机体系结构和主要部件地基本工作原理" class="headerlink" title="计算机体系结构和主要部件地基本工作原理"></a>计算机体系结构和主要部件地基本工作原理</h3><p>CPU和存储器地组成、性能、基本工作原理</p><p>常用I/O设备、通信设备地性能，以及基本工作原理</p><p>I/O接口地功能、类型和特点</p><p>CISC/RISC，流水线操作，多处理机，并行处理</p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p>虚拟存储器基本工作原理，多级存储体系</p><p>RAID类型和特性</p><h3 id="安全性、可靠性与系统性能评测基础知识"><a href="#安全性、可靠性与系统性能评测基础知识" class="headerlink" title="安全性、可靠性与系统性能评测基础知识"></a>安全性、可靠性与系统性能评测基础知识</h3><p>诊断与容错</p><p>系统可靠性分析评价</p><p>计算机系统性能评测方法</p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h3><p>数组（静态数组、动态数组）</p><p>线性表、链表（单向链表、双向链表、循环链表）</p><p>栈和队列</p><p>树（二叉树、查找树、平衡树、遍历树、堆）、图、集合地定义、存储和操作</p><p>Hash（存储位置计算、碰撞处理）</p><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p>排序算法、查找算法、数值计算、字符串处理、数据压缩算法、递归算法、图地相关算法</p><p>算法与数据结构的关系，算法效率，算法设计，算法描述（流程图、伪代码、决策表），算法的复杂性</p><h2 id="软件知识"><a href="#软件知识" class="headerlink" title="软件知识"></a>软件知识</h2><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><p>操作系统的类型、特征、地位、内核（中断控制）、进程、线程概念</p><p>处理机管理（状态转换、同步与互斥、信号灯、分时轮转、抢占、死锁）</p><p>存储管理（主存保护、动态连接分配、分段、分页、虚存）</p><p>设备管理（I/O控制、假脱机、磁盘调度）</p><p>文件管理（文件目录、文件地结构和组织、存取方法、存取控制、恢复处理、共享和安全）</p><p>作业管理（作业调度、作业控制语言（JCL）、多道程序设计）</p><p>汉字处理，多媒体处理，人机界面</p><p>网络操作系统和嵌入式操作系统基础知识</p><p>操作系统的配置</p><h3 id="程序设计语言和语言处理程序地知识"><a href="#程序设计语言和语言处理程序地知识" class="headerlink" title="程序设计语言和语言处理程序地知识"></a>程序设计语言和语言处理程序地知识</h3><p>汇编、编译、解释系统地基础知识和基本工作原理</p><p>程序设计语言地基本成分：数据、运算、控制和传输,程序调用地实现机制</p><p>各类程序设计语言地主要特点和适用情况</p><h2 id="计算机网络知识"><a href="#计算机网络知识" class="headerlink" title="计算机网络知识"></a>计算机网络知识</h2><p>网络体系结构（网络拓扑、OSI/RM、基本地网络协议）</p><p>传输介质，传输技术，传输方法，传输控制</p><p>常用网络设备和各类通信设备</p><p>Client/Server结构、Browser/Server结构、Browser/Web/Datebase结构</p><p>LAN拓扑，存取控制，LAN地组网，LAN间连接，LAN-WAN连接</p><p>因特网基础知识及应用</p><p>网络软件</p><p>网络管理</p><p>网络性能分析</p><p>网络有关地法律、法规</p><h1 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术"></a>数据库技术</h1><h2 id="数据库技术基础"><a href="#数据库技术基础" class="headerlink" title="数据库技术基础"></a>数据库技术基础</h2><h3 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h3><p>数据库系统地三级模式（概念模式、外模式、内模式），两级映像（概念模式/外模式、外模式/内模式）</p><p>数据库模型：数据模型地组成要素，概念数据模型ER图（实体、属性、关系），逻辑数据模型（关系模型、层次模型、网络模型）</p><h3 id="数据库管理系统地功能和特征"><a href="#数据库管理系统地功能和特征" class="headerlink" title="数据库管理系统地功能和特征"></a>数据库管理系统地功能和特征</h3><p>主要功能（数据库定义、数据库操作、数据库控制、事务管理、用户视图）</p><p>特征（确保数据独立性、数据库存取、同时执行过程、排它控制、故障恢复、安全性、完整性）</p><p>RDB（关系数据库），OODB（面向对象数据库），ORDB（对象关系数据库），NDB（网状数据库）</p><p>几种常用Web数据库的特点</p><h3 id="数据库系统体系结构"><a href="#数据库系统体系结构" class="headerlink" title="数据库系统体系结构"></a>数据库系统体系结构</h3><p>集中式数据库系统</p><p>Client/Server数据库系统</p><p>并行数据库系统</p><p>分布式数据库系统</p><p>对象关系数据库系统</p><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>关系代数运算（并、交、差、笛卡儿积、选择、投影、连接、除）</p><p>元组演算</p><p>完整性约束</p><h3 id="关系数据库标准语言（SQL）"><a href="#关系数据库标准语言（SQL）" class="headerlink" title="关系数据库标准语言（SQL）"></a>关系数据库标准语言（SQL）</h3><p>SQL地功能与特点</p><p>用SQL进行数据定义（表、视图、索引、约束）</p><p>用SQL进行数据操作（数据检索、数据插入/删除/更新、触发控制）</p><p>安全性和授权</p><p>程序中地API，嵌入SQL</p><h2 id="数据库地控制功能"><a href="#数据库地控制功能" class="headerlink" title="数据库地控制功能"></a>数据库地控制功能</h2><p>数据库事务管理（ACID属性）</p><p>数据库备份与恢复技术（UNDO、REDO）</p><p>并发控制</p><h2 id="数据库设计基础理论"><a href="#数据库设计基础理论" class="headerlink" title="数据库设计基础理论"></a>数据库设计基础理论</h2><h3 id="系数据库设计"><a href="#系数据库设计" class="headerlink" title="系数据库设计"></a>系数据库设计</h3><p>函数依赖</p><p>规范化（第一范式、第二范式、第三范式、BC范式、第四范式、第五范式）</p><p>模式分解及分解应遵循地原则</p><h3 id="对象关系数据库设计"><a href="#对象关系数据库设计" class="headerlink" title="对象关系数据库设计"></a>对象关系数据库设计</h3><p>嵌套关系、 复杂类型,继承与引用类型</p><p>与复杂类型有关地查询</p><p>SQL中地函数与过程</p><p>对象关系</p><h2 id="数据挖掘和数据仓库基础知识"><a href="#数据挖掘和数据仓库基础知识" class="headerlink" title="数据挖掘和数据仓库基础知识"></a>数据挖掘和数据仓库基础知识</h2><p>数据挖掘应用和分类</p><p>关联规则、聚类</p><p>数据仓库地成分</p><p>数据仓库地模式</p><h2 id="多媒体基本知识"><a href="#多媒体基本知识" class="headerlink" title="多媒体基本知识"></a>多媒体基本知识</h2><h3 id="多媒体技术基本概念"><a href="#多媒体技术基本概念" class="headerlink" title="多媒体技术基本概念"></a>多媒体技术基本概念</h3><p>多媒体系统基础知识</p><p>常用多媒体文件格式</p><h3 id="多媒体压缩编码技术"><a href="#多媒体压缩编码技术" class="headerlink" title="多媒体压缩编码技术"></a>多媒体压缩编码技术</h3><p>多媒体压缩编码技术</p><p>统计编码</p><p>预测编码</p><p>编码地国际标准</p><h3 id="多媒体技术应用"><a href="#多媒体技术应用" class="headerlink" title="多媒体技术应用"></a>多媒体技术应用</h3><p>简单图形地绘制,图像文件地处理方法</p><p>音频和视频信息地应用</p><p>多媒体应用开发过程</p><h2 id="系统性能知识"><a href="#系统性能知识" class="headerlink" title="系统性能知识"></a>系统性能知识</h2><p>性能计算（应时间、吞吐量、周转时间）</p><p>性能指标和性能设计</p><p>性能测试和性能评估</p><h2 id="计算机应用基础知识"><a href="#计算机应用基础知识" class="headerlink" title="计算机应用基础知识"></a>计算机应用基础知识</h2><p>信息管理、数据处理、辅助设计、科学计算,人工智能等基础知识</p><p>远程通信服务及相关通信协议基础知识</p><h1 id="系统开发和运行维护知识"><a href="#系统开发和运行维护知识" class="headerlink" title="系统开发和运行维护知识"></a>系统开发和运行维护知识</h1><h2 id="软件工程、软件过程改进和软件开发工程管理知识"><a href="#软件工程、软件过程改进和软件开发工程管理知识" class="headerlink" title="软件工程、软件过程改进和软件开发工程管理知识"></a>软件工程、软件过程改进和软件开发工程管理知识</h2><p>软件工程知识</p><p>软件开发生命周期阶段目标和任务</p><p>软件开发工程基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具</p><p>主要地软件开发方法（生命周期法、原型法、面向对象法、CASE）</p><p>软件开发工具与环境知识</p><p>软件质量管理基础知识</p><p>软件过程改进基础知识</p><p>软件开发过程评估、软件能力成熟度评估地基础知识</p><h2 id="系统分析基础知识"><a href="#系统分析基础知识" class="headerlink" title="系统分析基础知识"></a>系统分析基础知识</h2><p>系统分析的目地和任务</p><p>结构化分析方法（数据流图（DFD）和数据字典（DD），实体关系图（ERD），描述加工处理地结构化语言）</p><p>统一建模语言（UML）系统规格说明书</p><h2 id="系统设计知识"><a href="#系统设计知识" class="headerlink" title="系统设计知识"></a>系统设计知识</h2><p>系统设计的目地和任务</p><p>结构化设计方法和工具（系统流程图、HIPO图、控制流程图）</p><p>系统总体结构设计（总体布局，设计原则，模块结构设计，数据存取设计，系统配置方案）</p><p>系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计）</p><p>系统设计说明书</p><h2 id="系统实施知识"><a href="#系统实施知识" class="headerlink" title="系统实施知识"></a>系统实施知识</h2><p>系统实施地主要任务</p><p>结构化程序设计、面向对象程序设计、可视化程序设计</p><p>程序设计语言地选择、程序设计风格</p><p>系统测试地目地、类型,系统测试方法（黑盒测试、白盒测试、灰盒测试）</p><p>测试设计和管理（误曲线、错误排除、收敛、注入故障、测试试用例设计、系统测试报告）</p><p>系统转换基础知识</p><h2 id="系统运行和维护知识"><a href="#系统运行和维护知识" class="headerlink" title="系统运行和维护知识"></a>系统运行和维护知识</h2><p>系统运行管理知识</p><p>系统维护知识</p><p>系统评价知识</p><h1 id="安全性知识"><a href="#安全性知识" class="headerlink" title="安全性知识"></a>安全性知识</h1><p>安全性基本概念（网络安全、操作系统安全、数据库安全）</p><p>计算机病毒地防治，计算机犯罪地防范，容灾</p><p>访问控制、防闯入、安全管理措施</p><p>加密与解密机制</p><p>风险分析、风险类型、抗风险措施和内部控制</p><h1 id="标准化知识"><a href="#标准化知识" class="headerlink" title="标准化知识"></a>标准化知识</h1><p>标准化意识,标准化地发展,标准出台过程</p><p>国际标准、国家标准、行业标准、企业标准基本知识</p><p>代码标准、文件格式标准、安全标准软件开发规范和文档标准</p><p>标准化机构</p><h1 id="信息化基础知识"><a href="#信息化基础知识" class="headerlink" title="信息化基础知识"></a>信息化基础知识</h1><p>信息化意识</p><p>全球信息化趋势、国家信息化战略、企业信息化战略和策略</p><p>有关地法律、法规</p><p>远程教育、电子商务、电子政务等基础知识</p><p>企业信息资源管理基础知识</p><h1 id="计算机专业英语"><a href="#计算机专业英语" class="headerlink" title="计算机专业英语"></a>计算机专业英语</h1><p>掌握计算机技术地基本词汇</p><p>能正确阅读和理解计算机领域地英文资料</p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="理解系统需求说明"><a href="#理解系统需求说明" class="headerlink" title="理解系统需求说明"></a>理解系统需求说明</h2><p>了解用户需求、确定系统范围</p><p>确定应用系统数据库地各种关系</p><p>现有环境与新系统环境地关系</p><p>新系统中地数据项、数据字典、数据流</p><h2 id="系统开发地准备"><a href="#系统开发地准备" class="headerlink" title="系统开发地准备"></a>系统开发地准备</h2><p>选择开发方法，准备开发环境，制订开发计划</p><h2 id="设计系统功能"><a href="#设计系统功能" class="headerlink" title="设计系统功能"></a>设计系统功能</h2><p>选择系统机构，设计各子系统地功能和接口，设计安全性策略、需求和实现方法，制定详细地工作流和数据流</p><h2 id="数据库设计-1"><a href="#数据库设计-1" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计数据模型"><a href="#设计数据模型" class="headerlink" title="设计数据模型"></a>设计数据模型</h3><p>概念结构设计（设计ER模型）</p><p>逻辑结构设计（转换成DBMS所能接收地数据模型）</p><p>评审设计</p><h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><p>设计方法与内容</p><p>存取方法地选择</p><p>评审设计与性能预测</p><h3 id="数据库实施与维护"><a href="#数据库实施与维护" class="headerlink" title="数据库实施与维护"></a>数据库实施与维护</h3><p>数据加载与应用程序调试</p><p>数据库试运行</p><p>数据库运行与维护</p><h3 id="数据库的保护"><a href="#数据库的保护" class="headerlink" title="数据库的保护"></a>数据库的保护</h3><p>数据库的备份与恢复</p><p>数据库的安全性</p><p>数据库的完整性</p><p>数据库的并发控制</p><h2 id="编写外部设计文档"><a href="#编写外部设计文档" class="headerlink" title="编写外部设计文档"></a>编写外部设计文档</h2><p>编写系统说明书（系统配置图、各子系统关系图、系统流程图，系统功能说明、输入输出规格说明、数据规格说明、用户手册框架）</p><p>设计系统测试要求</p><h2 id="设计评审"><a href="#设计评审" class="headerlink" title="设计评审"></a>设计评审</h2><h1 id="数据库应用系统设计"><a href="#数据库应用系统设计" class="headerlink" title="数据库应用系统设计"></a>数据库应用系统设计</h1><h2 id="设计数据库应用系统结构"><a href="#设计数据库应用系统结构" class="headerlink" title="设计数据库应用系统结构"></a>设计数据库应用系统结构</h2><p>信息系统的架构（如Client/Server）与DBMS</p><p>多用户数据库环境（文件服务器体系结构、Client/Server体系结构）</p><p>大规模数据库和并行计算机体系结构（SMP、MPP）</p><p>中间件角色和相关工具</p><p>按构件分解，确定构件功能规格以及构件之间的接口</p><h2 id="设计输入输出"><a href="#设计输入输出" class="headerlink" title="设计输入输出"></a>设计输入输出</h2><p>屏幕界面设计,设计输入输出检查方法和检查信息</p><p>数据库交互与连接（掌握C程序设计语言，以及Java、Visual Basic、Visual C＋＋、PowerBuilder、Delphi中任一种开发工具与数据库互连地方法（如何与数据库服务器沟通））</p><h2 id="设计物理数据"><a href="#设计物理数据" class="headerlink" title="设计物理数据"></a>设计物理数据</h2><p>分析事务在数据库上运行的频率和性能要求，确定逻辑数据组织方式、存储介质，设计索引结构和处理方式<br>将逻辑数据结构变换成物理数据结构，计算容量（空间代价），确定存取方法（时间效率）、系统配置（维护代价）并进行优化</p><h2 id="设计安全体系"><a href="#设计安全体系" class="headerlink" title="设计安全体系"></a>设计安全体系</h2><p>明确安全等级</p><p>数据库的登录方式</p><p>数据库访问</p><p>许可（对象许可、命令许可、授权许可的方法）</p><h2 id="应用程序开发"><a href="#应用程序开发" class="headerlink" title="应用程序开发"></a>应用程序开发</h2><h3 id="应用程序开发-1"><a href="#应用程序开发-1" class="headerlink" title="应用程序开发"></a>应用程序开发</h3><p>选择应用程序开发平台</p><p>系统实施顺序</p><p>框架开发</p><p>基础小组的程序开发</p><p>源代码控制</p><p>版本控制</p><h3 id="模块划分（原则、方法、标准）"><a href="#模块划分（原则、方法、标准）" class="headerlink" title="模块划分（原则、方法、标准）"></a>模块划分（原则、方法、标准）</h3><h3 id="编写程序设计文档"><a href="#编写程序设计文档" class="headerlink" title="编写程序设计文档"></a>编写程序设计文档</h3><p>模块规格说明书（功能和接口说明、程序处理逻辑地描述、输入输出数据格式地描述）</p><p>测试要求说明书（测试类型和目标，测试用例，测试方法）</p><h3 id="程序设计评审"><a href="#程序设计评审" class="headerlink" title="程序设计评审"></a>程序设计评审</h3><h2 id="编写应用系统设计文档"><a href="#编写应用系统设计文档" class="headerlink" title="编写应用系统设计文档"></a>编写应用系统设计文档</h2><p>系统配置说明、构件划分图、构件间地接口、构件处理说明、屏幕设计文档、报表设计文档、程序设计文档、文件设计文档、数据库设计文档</p><h2 id="设计评审-1"><a href="#设计评审-1" class="headerlink" title="设计评审"></a>设计评审</h2><h1 id="数据库应用系统实施"><a href="#数据库应用系统实施" class="headerlink" title="数据库应用系统实施"></a>数据库应用系统实施</h1><h2 id="整个系统地配置与管理"><a href="#整个系统地配置与管理" class="headerlink" title="整个系统地配置与管理"></a>整个系统地配置与管理</h2><h2 id="常用数据库管理系统的应用（SQL-Server、Oracle、Sybase、DB2、Access或Visual-Foxpro）"><a href="#常用数据库管理系统的应用（SQL-Server、Oracle、Sybase、DB2、Access或Visual-Foxpro）" class="headerlink" title="常用数据库管理系统的应用（SQL Server、Oracle、Sybase、DB2、Access或Visual Foxpro）"></a>常用数据库管理系统的应用（SQL Server、Oracle、Sybase、DB2、Access或Visual Foxpro）</h2><p>创建数据库</p><p>创建表、创建索引、创建视图、创建约束、创建UDDT&lt;用户自定义类型）</p><p>创建和管理触发器</p><p>建立安全体系</p><h2 id="数据库应用系统安装"><a href="#数据库应用系统安装" class="headerlink" title="数据库应用系统安装"></a>数据库应用系统安装</h2><p>拟定系统安装计划（考虑费用、客户关系、雇员关系、后勤关系和风险等因素）</p><p>拟定人力资源使用计划（组织机构安排地合理性）</p><p>直接安装（安装新系统并使系统快速进入运行状态）</p><p>并行安装（新旧系统并行运行一段时间）</p><p>阶段安装（经过一系列地步骤和阶段使新系统各部分逐步投入运行）</p><h2 id="数据库应用系统测试"><a href="#数据库应用系统测试" class="headerlink" title="数据库应用系统测试"></a>数据库应用系统测试</h2><p>拟定测试目标、计划、方法与步骤</p><p>数据加载，准备测试数据</p><p>指导应用程序员进行模块测试进行验收</p><p>准备系统集成测试环境测试工具</p><p>写出数据库运行测试报告</p><h2 id="培训与用户支持"><a href="#培训与用户支持" class="headerlink" title="培训与用户支持"></a>培训与用户支持</h2><h1 id="数据库系统地运行和管理"><a href="#数据库系统地运行和管理" class="headerlink" title="数据库系统地运行和管理"></a>数据库系统地运行和管理</h1><h2 id="数据库系统地运行计划"><a href="#数据库系统地运行计划" class="headerlink" title="数据库系统地运行计划"></a>数据库系统地运行计划</h2><p>运行策略的确定</p><p>确定数据库系统报警对象和报警方式</p><p>数据库系统地管理计划（执行，故障/恢复，安全性，完整性，用户培训和维护）</p><h2 id="数据库系统地运行和维护"><a href="#数据库系统地运行和维护" class="headerlink" title="数据库系统地运行和维护"></a>数据库系统地运行和维护</h2><p>新旧系统的转换</p><p>收集和分析报警数据（执行报警、故障报警、安全报警）</p><p>连续稳定地运行</p><p>数据库维护（数据库重构、安全视图地评价和验证、文档维护）</p><p>数据库系统地运行统计（收集、分析、提出改进措施）</p><p>关于运行标准和标准改进一致性的建议</p><p>数据库系统的审计</p><h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>数据字典和数据仓库的管理</p><p>数据完整性维护和管理（实体完整性、参照完整性）</p><p>数据库物理结构的管理（保证数据不推迟访问）</p><p>数据库空间及碎片管理</p><p>备份和恢复（顺序、日志（审计痕迹）、检查点）</p><p>死锁管理（集中式、分布式）</p><p>并发控制（可串行性、锁机制、时间戳、优化）</p><p>数据安全性管理（加密、安全、访问控制、视图、有效性确认规则）</p><p>数据库管理员（DBA）职责</p><h2 id="性能调整"><a href="#性能调整" class="headerlink" title="性能调整"></a>性能调整</h2><p>SQL语句的编码检验</p><p>表设计的评价　</p><p>索引的改进</p><p>物理分配的改进</p><p>设备增强</p><p>数据库性能优化</p><h2 id="用户支持"><a href="#用户支持" class="headerlink" title="用户支持"></a>用户支持</h2><p>用户培训</p><p>售后服务</p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h2><p>数据库语言的要素</p><p>数据库语言的使用方式（交互式和嵌入式）</p><h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><p>SQL语句的特征</p><p>SQL语句的基本成分</p><h2 id="数据库定义"><a href="#数据库定义" class="headerlink" title="数据库定义"></a>数据库定义</h2><p>创建数据库（Create Datebase）、创建表（Create Table）</p><p>定义数据完整性</p><p>修改表（Alter Table）、删除表（Drop Table）</p><p>定义索引（Create Index）、删除索引（Drop Index）</p><p>定义视图（Create View）、删除视图（Drop View）、更新视图</p><h2 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h2><p>Select语句的基本机构</p><p>简单查询</p><p>SQL中的选择、投影</p><p>字符串比较，涉及空值地比较</p><p>日期时间，布尔值，输出排序</p><p>多表查询</p><p>避免属性歧义</p><p>SQL中的连接、并、交、差</p><p>SQL中的元组变量</p><p>子查询</p><h2 id="完整性控制与安全机制"><a href="#完整性控制与安全机制" class="headerlink" title="完整性控制与安全机制"></a>完整性控制与安全机制</h2><p>主键（Primary Key）约束</p><p>外键（Foreign Key）约束</p><p>属性值上的约束（Null、Check、Create Domain）</p><p>全局约束（Create Assertions）</p><p>权限、授权（Grant）、销权（Revoke）</p><h2 id="创建触发器（Create-Trigger）"><a href="#创建触发器（Create-Trigger）" class="headerlink" title="创建触发器（Create Trigger）"></a>创建触发器（Create Trigger）</h2><h2 id="SQL使用方式"><a href="#SQL使用方式" class="headerlink" title="SQL使用方式"></a>SQL使用方式</h2><p>交互式SQL</p><p>嵌入式SQL</p><p>SQL与宿主语言接口&lt;Declare、共享变量、游标、卷游标）</p><p>动态SQL</p><p>API</p><h2 id="SQL-标准化"><a href="#SQL-标准化" class="headerlink" title="SQL 标准化"></a>SQL 标准化</h2><h1 id="网络环境下的数据库"><a href="#网络环境下的数据库" class="headerlink" title="网络环境下的数据库"></a>网络环境下的数据库</h1><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><h3 id="分布式数据库的概念"><a href="#分布式数据库的概念" class="headerlink" title="分布式数据库的概念"></a>分布式数据库的概念</h3><p>分布式数据库的特点与目标</p><h3 id="分布式数据库地体系结构"><a href="#分布式数据库地体系结构" class="headerlink" title="分布式数据库地体系结构"></a>分布式数据库地体系结构</h3><p>分布式数据库的模式结构</p><p>数据分布的策略（数据分片、分布透明性）</p><p>分布式数据库管理系统</p><h3 id="分布式查询处理和优化"><a href="#分布式查询处理和优化" class="headerlink" title="分布式查询处理和优化"></a>分布式查询处理和优化</h3><h3 id="分布式事务管理"><a href="#分布式事务管理" class="headerlink" title="分布式事务管理"></a>分布式事务管理</h3><p>分布式数据库的恢复（故障、恢复、2段提交、3段提交）</p><p>分布式数据库的透明性（局部、分裂、复制、处理、并发、执行）</p><h3 id="分布式数据库系统的应用"><a href="#分布式数据库系统的应用" class="headerlink" title="分布式数据库系统的应用"></a>分布式数据库系统的应用</h3><h2 id="网络环境下数据库系统地设计与实施"><a href="#网络环境下数据库系统地设计与实施" class="headerlink" title="网络环境下数据库系统地设计与实施"></a>网络环境下数据库系统地设计与实施</h2><p>数据地分布设计</p><p>负载均衡设计</p><p>数据库互连技术</p><h2 id="面向Web地DBMS技术"><a href="#面向Web地DBMS技术" class="headerlink" title="面向Web地DBMS技术"></a>面向Web地DBMS技术</h2><p>三层体系结构</p><p>动态Web网页</p><p>ASP、JSP、XML的应用</p><h1 id="数据库地安全性"><a href="#数据库地安全性" class="headerlink" title="数据库地安全性"></a>数据库地安全性</h1><h2 id="安全性策略地理解"><a href="#安全性策略地理解" class="headerlink" title="安全性策略地理解"></a>安全性策略地理解</h2><p>数据库视图的安全性策略</p><p>数据地安全级别（最重要的、重要的、注意、选择）</p><h2 id="数据库安全测量"><a href="#数据库安全测量" class="headerlink" title="数据库安全测量"></a>数据库安全测量</h2><p>用户访问控制（采用口令等）</p><p>程序访问控制（包含在程序中的SQL命令限制）</p><p>表的访问控制（视图机制）</p><p>控制访问的函数和操作</p><p>外部存储数据的加密与解密</p><h1 id="数据库发展趋势与新技术"><a href="#数据库发展趋势与新技术" class="headerlink" title="数据库发展趋势与新技术"></a>数据库发展趋势与新技术</h1><h2 id="面向对象数据库（OODBMS）"><a href="#面向对象数据库（OODBMS）" class="headerlink" title="面向对象数据库（OODBMS）"></a>面向对象数据库（OODBMS）</h2><h3 id="OODBMS的特征"><a href="#OODBMS的特征" class="headerlink" title="OODBMS的特征"></a>OODBMS的特征</h3><h3 id="面向对象数据模型"><a href="#面向对象数据模型" class="headerlink" title="面向对象数据模型"></a>面向对象数据模型</h3><p>对象结构、对象类、继承与多重继承、对象标识、对象包含、对象嵌套</p><h3 id="面向对象数据库语言"><a href="#面向对象数据库语言" class="headerlink" title="面向对象数据库语言"></a>面向对象数据库语言</h3><h3 id="对象关系数据库系统（ORDBMS）"><a href="#对象关系数据库系统（ORDBMS）" class="headerlink" title="对象关系数据库系统（ORDBMS）"></a>对象关系数据库系统（ORDBMS）</h3><p>嵌套关系</p><p>复杂类型</p><p>继承、引用类型</p><p>与复杂类型有关的查询</p><p>函数与过程</p><p>面向对象与对象关系</p><p>ORDBMS应用领域</p><h2 id="企业资源计划（ERP）和数据库"><a href="#企业资源计划（ERP）和数据库" class="headerlink" title="企业资源计划（ERP）和数据库"></a>企业资源计划（ERP）和数据库</h2><h3 id="ERP概述"><a href="#ERP概述" class="headerlink" title="ERP概述"></a>ERP概述</h3><p>基本MRP（制造资源计划）、闭环MRP、ERP</p><p>基本原理、发展趋势</p><p>ERP设计地总体思路（一个中心、两类业务、三条干线）</p><h3 id="ERP与数据库"><a href="#ERP与数据库" class="headerlink" title="ERP与数据库"></a>ERP与数据库</h3><p>运行数据库与ERP数据模型之间的关系</p><p>运行数据库与ERP数据库之间的关系</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h2 id="决策支持系统地建立"><a href="#决策支持系统地建立" class="headerlink" title="决策支持系统地建立"></a>决策支持系统地建立</h2><p>决策支持系统的概念</p><p>数据仓库设计</p><p>数据转移技术</p><p>联机分析处理（OLAP）技术</p><p>企业决策支持解决方案</p><p>联机事务处理（OLTP）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工 真题考点总结</title>
    <link href="http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E7%9C%9F%E9%A2%98%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E7%9C%9F%E9%A2%98%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-12T18:34:16.000Z</published>
    <updated>2021-04-14T07:51:34.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机操作类"><a href="#计算机操作类" class="headerlink" title="计算机操作类"></a>计算机操作类</h1><h2 id="计算机系统基础常识"><a href="#计算机系统基础常识" class="headerlink" title="计算机系统基础常识"></a>计算机系统基础常识</h2><h3 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h3><p>二进制数据在计算机系统中的表示方法是最基本的专业知识。补码本身是带符号位的，补码表示的数字中0是唯一的，不想原码有+0和-0之分，也意味着n位二进制编码可以表示（2^n）个不同的数。</p><h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><h3 id="2015-1"><a href="#2015-1" class="headerlink" title="2015"></a>2015</h3><p>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的，其次是Cache、内存的、硬盘（外设）。它们共同组成分级存储体系来解决存储容量、成本和速度之间的矛盾。</p><p>Cache工作时，需要拷贝主存信息到Cache中，就需要建立主存地址和Cache地址的映像关系。Cache的地址映像方法主要有三种，即全相联映像、直接映像和组相联映像。</p><ul><li><p><strong>全相联映像</strong></p><p>全相联映像方式意味着主存的任意一块可以映像到Cache中的任意一块。</p><p><strong>特点：</strong>块冲突概率低，Cache空间利用率高。</p><p><strong>缺点：</strong>相联目录表容量大导致成本高、查表速度慢。</p></li><li><p><strong>直接映像</strong></p><p>直接映像方式是指主存中的每一块只能映像到Cache汇总的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同。</p><p><strong>特点：</strong>硬件简单，不需要相联寄存器，访问速度快（无需地址变换）。</p><p><strong>缺点：</strong>Cache快冲突概率高导致Cache空间利用率很低。</p></li><li><p><strong>组相联映像</strong></p><p>组相联方式是对上述两种方式的折中处理，对Cache分组，实现组间直接映像，组内全相联，从而获取较低的冲突概率、较高的块利用率，同时的到较快的速度和较低的成本。</p></li></ul><p><strong>总线宽度：</strong>指总线的位数，即数据信号的并行传输能力，也体现总线占用物理空间和成本；总线的宽度是指最大传输率，即每秒传输的数据总量。总线的宽度与时钟频率共同决定了总线的带宽。例如：</p><p>32bit/8=4Byte，200MHz/5*4Byte=160MB/s</p><h3 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h3><p>CPU中有一些重要的寄存器：</p><ul><li><p>程序计数器（PC）</p><p>用于存放指令的地址。当程序顺序执行时，没去出一条指令，PC内容自动增加一个值，指向下一条要取的指令。当程序出现转移时，则将转移地址送入PC，然后由PC指出新的指令地址。</p></li><li><p>状态寄存器</p><p>用于记录运算中产生的标志信息。状态寄存器中的每一位单独使用，称为标识位。标志位的取值反映了ALU当前的各种状态，可以作为条件转移指令的转移条件。典型的标志位有以下几位：进位标志位（C）、零标志位（Z）、符号标志位（S）、溢出标志位（V）、奇偶标志位（P）。</p></li><li><p>通用寄存器组</p><p>是CPU中的一组工作寄存器，运算时用于暂存操作数或地址。在程序中使用通用寄存器可以减少访问内存的次数，提高运算速度。</p></li><li><p>累加器</p><p>是一个数据寄存器，在运算过程中暂时存放操作数和中间运算结果，不能用于长时间地保存一个数据。</p></li></ul><h2 id="计算机组成原理的基础知识"><a href="#计算机组成原理的基础知识" class="headerlink" title="计算机组成原理的基础知识"></a>计算机组成原理的基础知识</h2><h3 id="2015-2"><a href="#2015-2" class="headerlink" title="2015"></a>2015</h3><p><strong>中断相应时间：</strong>是指从发出中断请求到开始进入中断服务程序所需的时间。</p><h2 id="计算机系统结构基础知识"><a href="#计算机系统结构基础知识" class="headerlink" title="计算机系统结构基础知识"></a>计算机系统结构基础知识</h2><h3 id="2015-3"><a href="#2015-3" class="headerlink" title="2015"></a>2015</h3><p>对指令流水性能的度量有吞吐率、加速比和效率等指标。因此要使加速比效率最大化应该对流水线各级采用相同的运行时间。另外，流水线采用异步控制法并不会给流水线性能带来改善，反而会增加控制电路的复杂性。</p><ul><li><p><strong>吞吐率</strong></p><p>是指单位时间流水线所完成的任务数或输出结果的数量，最大吞吐率则是在达到稳定状态后所得到的吞吐率，它取决于流水线中最慢一段所需的时间，所以该段称为流水线的瓶颈。</p></li><li><p>加速比</p><p>是指等功能的非流水线执行时间与流水线执行时间之比，加速比与吞吐率成正比，如果流水线断流，实际吞吐率将会明显下降，则加速比也会明显下降。</p></li><li><p><strong>效率</strong></p><p>是指流水线的设备利用率，从时空图上看效率就是n个任务所占的时空区与m个段总的时空区之比。</p></li></ul><h1 id="网络安全类"><a href="#网络安全类" class="headerlink" title="网络安全类"></a>网络安全类</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="2015-4"><a href="#2015-4" class="headerlink" title="2015"></a>2015</h3><p>终端设备与远程站点之间建立安全连接的协议是SSH。SSH意为Secure Shell的缩写是由IETF制定的建立在应用层和传输层基础上的安全协议。SSH是专门远程登录会话和其他网络服务提供安全性的协议。</p><p><strong>安全需求分为：</strong>物理线路安全、网络安全、系统安全和应用安全。机房安全属于物理安全、入侵检测属于网络安全、漏洞补丁管理属于系统安全、数据库安全是应用安全。</p><p>把局域网划分为多个不同的VLAN，使得网络接入不再局限于物理地址的约束，这样做就简化了在网络中增加、移除和移动主机的配置，特别是动态配置VLAN，物理主机在哪里，它都属于自己的VLAN中。VLAN内部可以相互通信，VLAN之间不能直接通信，必须经过特殊配制的路由器才可以连通。这样做的结果是，通过在较大的局域网中创建不同的VLAN，可以抵御广播风暴的影响，也可以通过设置防火墙来提高网络的安全性。VLAN并不能直接增强网络的安全性。</p><h2 id="URL的基础知识"><a href="#URL的基础知识" class="headerlink" title="URL的基础知识"></a>URL的基础知识</h2><h3 id="2015-5"><a href="#2015-5" class="headerlink" title="2015"></a>2015</h3><p><strong>URL由三部分组成：</strong>资源类型、存放资源的主机域名、资源文件名。一般情况下，一个URL可以采用“主机名.域名”的形式打开指定的页面，也可以单独使用“域名”来打开指定的页面，但是这样实现的前提是需要进行相应的设置和对应。</p><h2 id="DHCP和FTP的两个应用协议"><a href="#DHCP和FTP的两个应用协议" class="headerlink" title="DHCP和FTP的两个应用协议"></a>DHCP和FTP的两个应用协议</h2><h3 id="2015-6"><a href="#2015-6" class="headerlink" title="2015"></a>2015</h3><p><strong>DHCP协议的功能：</strong>自动分配IP地址。</p><p><strong>FTP协议的作用：</strong>文件传输，使用的传输协议为TCP。</p><h1 id="知识产权类"><a href="#知识产权类" class="headerlink" title="知识产权类"></a>知识产权类</h1><h3 id="2015-7"><a href="#2015-7" class="headerlink" title="2015"></a>2015</h3><p>当两个以上的申请人分别就同样的发明创造申请专利的，专利授予最先申请的人。</p><h1 id="软件工程类"><a href="#软件工程类" class="headerlink" title="软件工程类"></a>软件工程类</h1><h2 id="软件工程的基本概念"><a href="#软件工程的基本概念" class="headerlink" title="软件工程的基本概念"></a>软件工程的基本概念</h2><h3 id="2015-8"><a href="#2015-8" class="headerlink" title="2015"></a>2015</h3><p><strong>软件工程的基本要素包括：</strong>方法、工具和过程。方法是产生某些结果的形式化过程；工具是用更好的方式完成某件事情的设备或自动化过程；过程是把工具和方法结合起来，定义涉及活动、约束和资源使用的一系列步骤，来达到某种想要的输出。</p><p>从工程管理角度，可以将软件设计分为两个阶段：<strong>概要设计阶段和详细设计阶段</strong>。结构化设计方法汇中，概要设计阶段进行软件体系结构的设计、数据设计和接口设计；详细设计阶段进行数据结构和算法的设计。面向对象设计中，概要设计阶段进行体系结构设计、初步的类设计/数据设计、结构设计；详细设计阶段进行构件设计。</p><p>结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序；面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p><h2 id="软件项目管理的基础知识"><a href="#软件项目管理的基础知识" class="headerlink" title="软件项目管理的基础知识"></a>软件项目管理的基础知识</h2><h3 id="2015-9"><a href="#2015-9" class="headerlink" title="2015"></a>2015</h3><p><strong>活动图</strong>是描述一个项目中各个工作任务相互依赖关系的一种模型，项目的很多重要特性可以通过分析活动图得到，如估算项目完成时间、计算关键路径和关键活动等。</p><p>在进行风险管理时，根据风险的优先级来确定风险控制策略，而优先级是根据风险暴露来确定的。风险暴露是一种量化风险影响的指标，等于风险影响乘以风险概率。风险影响是当风险发生时造成的损失。风险概率是风险管理的一个重要活动。</p><h1 id="程序语言类"><a href="#程序语言类" class="headerlink" title="程序语言类"></a>程序语言类</h1><h2 id="程序语言基础知识"><a href="#程序语言基础知识" class="headerlink" title="程序语言基础知识"></a>程序语言基础知识</h2><h3 id="2015-10"><a href="#2015-10" class="headerlink" title="2015"></a>2015</h3><p>程序设计语言的基本成分包括<strong>数据、运算、控制和传输</strong>等。</p><p>高级语言不依赖于具体的机器硬件。</p><p>局部变量只能在函数内部使用，其作用域是从定义位置到函数体或复合语句体结束为止。局部变量的值通常在其生存期内是变化的。</p><p>程序中的常量的值在运行时是不可改变的。</p><p>程序运行时的用户内存空间一般划分为代码区、静态数据区、栈区和堆区，其中栈区和堆区也称为动态数据区。全局变量的存储空间在静态数据区。</p><h2 id="软件过程模型的基础知识"><a href="#软件过程模型的基础知识" class="headerlink" title="软件过程模型的基础知识"></a>软件过程模型的基础知识</h2><h3 id="2015-11"><a href="#2015-11" class="headerlink" title="2015"></a>2015</h3><p>瀑布模型：将软件生存周期各个活动规定为线形顺序连接的若干阶段的模型。这是一种理想的现象开发模型，缺乏灵活性，无法解决软件需求不明确或不准确的问题。</p><p>原型模型：从初始的原型逐渐演化成为最红软件产品，特别适用于对软件需求缺乏准确的认识的情况。</p><p>增量开发：是把软件产品作为一系列的增量构件来设计、编码、集成和测试，可以在增量开发过程中逐步理解需求。</p><p>螺旋将瀑布模型与快速原型结合起来，并且加入了两种模型均忽略了的风险分析，适用于复杂的大型软件。</p><h1 id="系统开发和运行类"><a href="#系统开发和运行类" class="headerlink" title="系统开发和运行类"></a>系统开发和运行类</h1><h2 id="数据流图的概念和应用"><a href="#数据流图的概念和应用" class="headerlink" title="数据流图的概念和应用"></a>数据流图的概念和应用</h2><h3 id="2015-12"><a href="#2015-12" class="headerlink" title="2015"></a>2015</h3><p>数据流图或称数据流程图（Data Flow Diagram，DFD）是一种便于客户理解、分析系统数据流程的图形工具。数据流图描述堆数据的处理流程，着重系统信息的流向和处理过程。它摆脱了系统的物理内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p><h1 id="关系数据库类"><a href="#关系数据库类" class="headerlink" title="关系数据库类"></a>关系数据库类</h1><h2 id="关系数据库基础知识"><a href="#关系数据库基础知识" class="headerlink" title="关系数据库基础知识"></a>关系数据库基础知识</h2><h3 id="2015-13"><a href="#2015-13" class="headerlink" title="2015"></a>2015</h3><p><strong>简单属性</strong>是原子的、不可再分割的，<strong>复合属性</strong>可以细分为更小的部分（即划分为别的属性）。</p><h2 id="关系数据库中键的基本概念"><a href="#关系数据库中键的基本概念" class="headerlink" title="关系数据库中键的基本概念"></a>关系数据库中键的基本概念</h2><h3 id="2015-14"><a href="#2015-14" class="headerlink" title="2015"></a>2015</h3><p>关系数据库中，全码（All-key）指关系模型的所有属性组是这个关系模型的候选键。</p><h2 id="关系数据库E-R模型的相关知识"><a href="#关系数据库E-R模型的相关知识" class="headerlink" title="关系数据库E-R模型的相关知识"></a>关系数据库E-R模型的相关知识</h2><h3 id="2015-15"><a href="#2015-15" class="headerlink" title="2015"></a>2015</h3><p><strong>多对多联系向关系模式的转换的规则是：</strong>多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的主键及联系的属性，关系的码是多方实体的主键构成的属性组。</p><h2 id="数据表示基础知识"><a href="#数据表示基础知识" class="headerlink" title="数据表示基础知识"></a>数据表示基础知识</h2><h3 id="2014-1"><a href="#2014-1" class="headerlink" title="2014"></a>2014</h3><p>机器字长位n，最高位为标志位，则删除的n-1位用来表示数值，其最大是这n-1位都位都位1，也就是（2^（n-1）-1）。                                                                                        </p><h1 id="数据库技术基础类"><a href="#数据库技术基础类" class="headerlink" title="数据库技术基础类"></a>数据库技术基础类</h1><h2 id="数据挖掘基础知识"><a href="#数据挖掘基础知识" class="headerlink" title="数据挖掘基础知识"></a>数据挖掘基础知识</h2><h3 id="2015-16"><a href="#2015-16" class="headerlink" title="2015"></a>2015</h3><p>可以说，数据挖掘是深层次的数据分析。从功能上可以将数据挖掘的分析方法划分为四种，即关联分析、序列模式分析、分析类分析和聚类分析。在时间应用的DM系统中，这四种方法有着不同的使用范围，因此经常被综合运用。</p><ul><li><p><strong>关联分析</strong>（Association）</p><p>目的是挖掘出隐藏在数据间的相互关系。</p></li><li><p><strong>序列模式分析</strong>（Sequential Patterns）</p><p>目的也是挖掘出隐藏在数据间的相互关系，它的侧重点在于分析数据间的前后关系（因果关系）。在进行序列模式分析时也因计算置信度和支持度。</p></li><li><p><strong>分类分析</strong>（Classifiers）</p><p>和搜寻爱你为每一个记录赋予一个标记（一组具有不同特征的类别），即按标记分类记录，然后检查这些标记的记录，描述出这些记录的特性。</p></li><li><p><strong>聚类分析</strong>（Clustering）</p><p>聚类分析法是分类分析法的逆过程，它的输入集是一组未标记的记录，即输入的记录没有任何处理。目的是根据一定的规则，合理地划分记录集合，并用显式或隐式的方法描述不同的类别。</p></li></ul><h2 id="数据库模型的基础知识"><a href="#数据库模型的基础知识" class="headerlink" title="数据库模型的基础知识"></a>数据库模型的基础知识</h2><h3 id="2015-17"><a href="#2015-17" class="headerlink" title="2015"></a>2015</h3><p>概念模型是信息的描述方式，逻辑模型是数据的逻辑结构，数据模型是指数据的物理组织方式。逻辑模型（E-R图）中的联系描述的是实体间的关联关系，主要是现实世界的事件，包括参与者和事件自身的属性。在关系模型中，取参与联系的实体的码（唯一代表具体的参与者）和事件自身的属性，构成记录即关系的形式来描述。</p><p>索引是为了提高查询效率而引入的机制。</p><p>基于历史数据预测新数据所属的类型，类型已知，这就是一个典型的分类问题。</p><p>贝叶斯信念网络是一个分类算法，Apriori是一个关联规则挖掘算法，K-means和EM都是聚类算法。</p><p>K-means和DBSCAN是两个经典的聚类算法，将相似的数据对象归类一组，不相似的数据对象分开。K-means算法基于对象之间的聚类进行聚类，需要传入聚类的个数。DBSCAN算法基于密度进行聚类，需要确定阈值，两者的聚类结构均与输入参数关系很大。DBSCAN可以处理不同大小形状的簇，而K-means算法则不适用。若数据分布密度变化大，则这两种算法都不适用。</p><h2 id="扩展E-R图的基础知识"><a href="#扩展E-R图的基础知识" class="headerlink" title="扩展E-R图的基础知识"></a>扩展E-R图的基础知识</h2><h3 id="2015-18"><a href="#2015-18" class="headerlink" title="2015"></a>2015</h3><p>派生属性是指可以由其他属性来获取的属性。</p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="数据库的基础知识"><a href="#数据库的基础知识" class="headerlink" title="数据库的基础知识"></a>数据库的基础知识</h2><h3 id="2015-19"><a href="#2015-19" class="headerlink" title="2015"></a>2015</h3><p><strong>数据字典</strong>（Data Dictionary，DD）是各类数据藐视的集合，它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典包括数据项、数据结构、数据流、数据存储和处理过程5个过程。其中“数据项”通常包括数据项名，数据项含义说明、别名、数据类型、长度、取值范围、取之含义、与其他数据项的逻辑关系。</p><h2 id="数据库应用系统的基础知识"><a href="#数据库应用系统的基础知识" class="headerlink" title="数据库应用系统的基础知识"></a>数据库应用系统的基础知识</h2><h3 id="2015-20"><a href="#2015-20" class="headerlink" title="2015"></a>2015</h3><p>数据库的运行维护是由专门的数据库管理系统软件（DBMS）来负责的。C/S结构又称两层结构，由客户端运行应用程序；B/S结构分为三层，客户端只需要浏览器显示的简单的页面处理，Web服务器上的应用程序负责业务处理并与数据库交互。</p><h1 id="事务管理类"><a href="#事务管理类" class="headerlink" title="事务管理类"></a>事务管理类</h1><h2 id="数据库事务处理方面的基础知识"><a href="#数据库事务处理方面的基础知识" class="headerlink" title="数据库事务处理方面的基础知识"></a>数据库事务处理方面的基础知识</h2><h3 id="2015-21"><a href="#2015-21" class="headerlink" title="2015"></a>2015</h3><p>并发事务如果不加以控制，会破坏事务的隔离性和一致性。控制的手段就是加锁，在事务执行时限制其他事务堆数据的读取。在并发控制中引入两种锁：排他锁（Exclusive Locks，简称X锁）和共享锁（Share Locks，简称S锁）。</p><ul><li><p><strong>排他锁</strong></p><p>又称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T读取和修改数据A，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。</p></li><li><p><strong>共享锁</strong></p><p>又称为读锁，用于对数据进行数据读操作时进行锁定。如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改，其他事务可以再对数据A加S锁来读取，只要数据上有S锁，其他事务只能再对其加S锁读取而不能加X锁修改。</p></li></ul><h2 id="事务程序的基础知识"><a href="#事务程序的基础知识" class="headerlink" title="事务程序的基础知识"></a>事务程序的基础知识</h2><h3 id="2015-22"><a href="#2015-22" class="headerlink" title="2015"></a>2015</h3><p>事务的结束语句是ROLLBACK和COMMIT，当事务执行中出错时，使用ROLLBACK对的当前事务对数据库已做的更新进行撤销；事务所有指令执行完成后，用COMMIT语句对数据库所做的更改提交。COMMITWORK 和 ROLLBACK WORK 中的WORK可省略。</p><h2 id="事务调度知识"><a href="#事务调度知识" class="headerlink" title="事务调度知识"></a>事务调度知识</h2><h3 id="2015-23"><a href="#2015-23" class="headerlink" title="2015"></a>2015</h3><p>事务的执行由DBMS进行调度，在执行事务的过程中加入相关锁指令一控制事务满足ACID属性。常用的方式是两段锁协议（2PL）。即事务的加锁和解锁分为两个阶段，第一节阶段为锁增长阶段，只能加锁不能解锁，第二阶段为锁的减少阶段，只能解锁不能加锁。</p><p>死锁的解除由DBMS来完成。需要在造成死锁的多个事务中选择一个回滚代价最小的事务进行强制回滚，并将该事务置于事务队列稍后执行。</p><h2 id="数据库恢复的基础知识"><a href="#数据库恢复的基础知识" class="headerlink" title="数据库恢复的基础知识"></a>数据库恢复的基础知识</h2><h3 id="2015-24"><a href="#2015-24" class="headerlink" title="2015"></a>2015</h3><p>数据库故障会造成数据不一致。数据库的更新是由事务驱动的，事务的ACID属性被破坏的数据不一致的根本原因。系统重启会使内存中更新过的数据未写入硬盘而丢失，破坏了事务的持久性，即事务一经提交，其对数据库的运影响会体现在数据库中。</p><p>为了保证事务发生故障后可恢复，DBMS使用日志。即在对数据更新前，现将欲做的修改在日志中记录并写入硬盘，然后再进行数据更新。当系统重启时，根据日志文件对数据进行恢复。</p><h1 id="数据库主流应用技术类"><a href="#数据库主流应用技术类" class="headerlink" title="数据库主流应用技术类"></a>数据库主流应用技术类</h1><h2 id="面向对象数据库的基础知识"><a href="#面向对象数据库的基础知识" class="headerlink" title="面向对象数据库的基础知识"></a>面向对象数据库的基础知识</h2><h3 id="2015-25"><a href="#2015-25" class="headerlink" title="2015"></a>2015</h3><p>面向对象数据库中的数据模型充分利用了面向对象的核心概念。一个对象通常对应实际领域的一个实体，有唯一的标识，即对象标识OID。但是对用户而言，OID不可以修改。</p><h1 id="非关系型数据库类"><a href="#非关系型数据库类" class="headerlink" title="非关系型数据库类"></a>非关系型数据库类</h1><h2 id="NoSQL的相关知识"><a href="#NoSQL的相关知识" class="headerlink" title="NoSQL的相关知识"></a>NoSQL的相关知识</h2><h3 id="2015-26"><a href="#2015-26" class="headerlink" title="2015"></a>2015</h3><p>NoSQL是指非关系型数据库，是不同于传统的关系型数据库DBMS的统称。有几种典型的NoSQL数据库：</p><ul><li><p><strong>文档存储数据库</strong></p><p>是指一文档为存储信息的基本单位，如BaseX、CouchDB、MongoDB等。</p></li><li><p><strong>键值存储数据库</strong></p><p>支持简单的键值存储和提取，具有极高的并发读写能力，如Dynamo、Memcached、Redis等。</p></li><li><p><strong>图形存储数据库</strong></p><p>利用计算机将点、线、面等图形基本元素按照一定的数据结构进行存储，如FlockDB、Neo4j等。</p></li></ul><p>多值数据库系统是一种分布式数据库系统，提供了一个通用的数据集成与访问平台，屏蔽了各种数据库系统不同的访问方式和用户界面，给用户呈现出一个访问多种数据库的公共接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（六）数据库技术基础</title>
    <link href="http://yoursite.com/2021/04/08/%E6%95%B0%E5%B7%A5%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/04/08/%E6%95%B0%E5%B7%A5%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-08T09:42:03.000Z</published>
    <updated>2021-06-03T13:50:40.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h2><p>数据库系统（DataBase System，DBS）是一种采用了数据库技术，有组织地、动态地存储大量相关联数据方便多用户访问的计算机系统，。广义上讲是由数据库、硬件、软件和人员组成的。</p><ul><li><p>数据库（DataBase，DB）</p><p>数据库是统一管理的、长期存储在计算机的、有组织的相关数据的集合。</p><p>其特点是数据间联系紧密、冗余度小、独立性强、易扩展，并且可为各类用户共享。</p></li><li><p>硬件（hardware）</p><p>硬件是构成计算机系统的各种物理设备，包括存储数据所需的外设。硬件的配置应满足整个数据库系统的需要。</p></li><li><p>软件（software）</p><p>软件包括操作系统、数据管理系统及应用程序。数据库管理系统（DataBase Management System，DBMS）是数据系统的核心软件，是由一组相关联的数据的集合和一组用以访问这些数据的软件组成。</p><p>功能：数据定义功能、数据操纵功能、数据库的运行管理和数据的建立与维护。</p></li><li><p>人员</p><ul><li>第一类：系统分析员和数据库设计人员</li><li>第二类：应用程序员</li><li>第三类：最终客户</li><li>第四类：数据库管理员（DataBase Administrator，DBA）</li></ul></li></ul><h2 id="DBMS的功能和特点"><a href="#DBMS的功能和特点" class="headerlink" title="DBMS的功能和特点"></a>DBMS的功能和特点</h2><p>DBMS主要是实现对共享数据有效地组织、管理与存取。</p><h3 id="DBMS功能"><a href="#DBMS功能" class="headerlink" title="DBMS功能"></a>DBMS功能</h3><ul><li><p>数据定义</p><p>DBMS提供数据定义语言（Data Definition Language，DDL），用户可以对数据库的结构描述，包括外模式、模式和内模式定义；数据库的完整性定义；安全保密定义等。</p></li><li><p>数据库操作</p><p>DBMS向用户提供数据操作语言（Data Manipulation Language，DML），实现对数据库中数据的基本操作，如检索、插入、修改和删除。</p><p>DML分为两类：宿主型和自含型：</p><ul><li>宿主型：将DML语句嵌入某种主语言（如C、Java、COBOL等）中使用</li><li>自含型：可以单独使用DML语句，供用户交互使用</li></ul></li><li><p>数据库运行管理</p><p>数据库在运行期间多用户环境下的并发控制、安全性检查和存取控制、完整性检查和执行、运行日志的组织管理、事物管理和自动恢复等是DBMS的重要组成部分。</p></li><li><p>数据组织、存储和管理</p><p>DBMS分类组织、存储和管理各种数据，需要实现数据间的联系、数据组织和存储，基本目标是提高存储空间的利用率。</p></li><li><p>数据库的建立与维护</p><p>数据库的建立和维护包括数据库的初始建立、数据转换、数据库的转储和恢复、数据库的重组和重构、性能监测和分析等。</p></li><li><p>其他功能</p><p>如DBMS与网络中其他软件系统的通行功能，一个DBMS与另一个DBMS或文件系统的数据转换功能等。</p></li></ul><h3 id="DBMS特点"><a href="#DBMS特点" class="headerlink" title="DBMS特点"></a>DBMS特点</h3><ul><li><p>数据库结构化且统一管理</p><p>数据库中的数据由DBMS统一管理。由于数据库系统采用复杂的数据模型表示数据结构，数据模型不仅描述数据本身的特点，还描述数据之间的联系。</p><p>数据不在面向某个应用，而是面向整个系统。</p><p>数据易维护、易扩展，数据荣誉明显减少，真正实现了数据的共享。</p></li><li><p>有较高的数据独立性</p><p>数据独立性是指数据与程序独立，将收据的定义操你个程序中分离出去，由DBMS负责数据的存储，应用程序关心的是数据逻辑结构，无须了解数据在磁盘上的数据库汇总的存储形式，从而简化应用程序，大大减少了应用程序编制的工作量。</p><p>数据的独立性包括啊物理独立性和数据的逻辑独立性</p></li><li><p>数据控制功能</p><p>DBMS提供了数据控制功能，以适应共享数据的环境。</p><p>数据的控制功能如下：</p><ul><li><p>数据的安全性（security）</p><p>是指保护数据库以防止不合法的使用造成数据泄漏、更改和破坏。</p></li><li><p>数据完整性（integrality）</p><p>指数据库正确性和相容性，是防止合法用户使用数据库时向数据库加入不符合语义的数据。</p><p>保证数据库中数据是正确的，避免非法的更新。</p></li><li><p>并发控制（concurrency control）</p><p>指在多用户共享的系统中，许多用户可能同时对同一数据进行操作。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据</p></li><li><p>故障恢复（recovery from failure）</p><p>数据库中的4类故障是事务内部故障、系统故障、介质故障及计算机病毒。</p><p>恢复的原理：建立冗余（redundancy）数据。</p><p>冗余是物理级的，通常认为逻辑级是没有冗余的。</p></li></ul></li></ul><h3 id="DBMS特点-1"><a href="#DBMS特点-1" class="headerlink" title="DBMS特点"></a>DBMS特点</h3><ul><li><p>关系数据库系统（Relation DataBase Systems，RDBS）</p><p>关系数据库系统时间里在关系数据模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据。</p><p>目前主流的关系数据库由Oracle、Db2、Sybase、Microsoft SQL Server、Microsoft Access、MySQL等。</p><p>在关系模型中，实体以及实体间的联系都是用关系表示的。</p><p>在一个给定的现实世界领域汇总，相应的所有实体及实体之间联系的关系的集合构成以关系数据库，有型和值之分。</p><ul><li><p>关系数据库的型也称为关系数据库模式，它是对关系数据库的描述，是关系模式的集合。</p></li><li><p>关系数据库的值也称为关系数据库，是关系的集合</p></li><li><p>关系数据库模式与关系数据库通常统称为关系数据库。</p></li></ul></li><li><p>面向对象的数据库系统（Object-Oriented DataBase System，OODBS）</p><p>面向对象的数据库系统是支持以对象形式对数据建模的数据库管理系统，包括对对象的类、类属性的继承和子类的支持。</p><p>面向对象数据库系统主要有两个特点：</p><ul><li>面向对象数据模型能完整的描述现实世界的数据结构，能表达数据间的嵌套、递归联系。</li><li>具有面向对象技术的封装性和继承性，提高了软件的可重用性。</li></ul></li><li><p>对象关系数据库系统（Object-Oriented Relation DataBase System，ORDBS）</p><p>在传统的关系数据模型基础上提供元祖、数组、集合等更为丰富的数据类型以及处理新的数据类型操作的能力，这样形成的数据模型被称为“对象关系数据模型”，基于对象关系数据模型的DBS称为对象关系数据库系统</p></li></ul><h2 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>系统开发人员需要通过试图层、逻辑层和物理层三个层次上的抽象来对用户屏蔽系统的复杂性，简化用户与系统的交互。</p><ul><li><p>视图层（view level）</p><p>最该层次的抽象，描述整个系统的某个部分。</p><p>优点：是用户与系统交互简化，而且还可以保证数据的保密性和安全性</p></li><li><p>逻辑层（logical level）</p><p>势必物理层更高一层的抽象，描述数据库中储存什么数据以及这些数据间存在的什么关系。</p><p>逻辑结构层通过相对简单的结构描述了真个数据库。</p></li><li><p>物理层（physical level）</p><p>是最低层次的抽象，描述数据在存储器是如何存储的。物理层详细地描述复杂的底层结构。</p></li></ul><p>数据库系统设计院可在视图层、逻辑层和物理层对数据抽象，通过外模式、概念模式和内模式来描述不同层次上的数据特性。</p><h3 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h3><p>采用“三级模式和两级映像”</p><p>数据库采用三级模式结构，这是数据库管理系统内部的系统结构。数据库有“型”和“值”的概念。</p><p>“型”是指对某一数据的结构和属性的说明</p><p>“值”是型的一个具体赋值</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><p>概念模式</p><p>概念模式也称模式，是数据库中全部数据的逻辑结构和特征的描述。它由若干个概念记录类型组成，只涉及型的描述，不涉及具体的值。</p><p>概念模式的一个具体值称为模式的一个实例，用一个模式可以有很多实例。</p><p>概念模式反映的是数据库的结构及其联系，所以是相对稳定的；而实例反映的是数据库某一时刻的状态，所以是相对改变的。</p><blockquote><p>需要说明的是：</p><p>概念模式不仅描述概念记录类型，还要描述记录间的联系、操作、数据的完整性和安全性等要求。但是概念模式不涉及存储结构、访问技术等细节。只有这样，概念模型才算做到了“物理数据独立性”</p></blockquote><p>描述概念模式的数据定义语言称为“模式DDL（Schema Data Definition Language）”</p></li><li><p>外模式</p><p>外模式也称用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述。它由若干个外部记录类型组成。用户使用数据库操纵语言对数据库进行操作，实际上是对外模式的外部记录进行操作。</p><p>描述外模式的数据定义语言称为“外模式DDL”。</p></li><li><p>内模式</p><p>内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据内部的表示方式。定义所有的呢句记录类型、索引和文件的组织方式，以及数据控制方面的细节。</p><blockquote><p>需要说明的是：</p><p>内部记录并不涉及物理记录，也不涉及设备的约束。比内模式更接近于物理存储和访问的那些软件机制是操作系统的一部分（及文件系统）。例如磁盘上读、写数据。</p></blockquote><p>描述内模式的数据定义语言称为“内模式DDL”。</p></li></ul><p>总之，数据按外模式的描述提供给用户，按内模式的描述存储在磁盘上，儿概念模式提供了链接这两级模式的相对稳定的中间观点，并使两级的任意一级的改变都不受另一级的牵制。</p><h3 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h3><p>数据库系统在三级模式之间提供了两级映像：模式/内模式映像、外模式/模式映像。</p><p>正因为这两级映像保证了数据库中数据具有较高的逻辑独立性和物理独立性。</p><ul><li><p>模式/内模式映像</p><p>存在于概念级和内部级之间，实现了概念模式到内模式之间的相互转换</p></li><li><p>外模式/模式映像</p><p>存在于外部级和概念级之间，实现了外模式到概念模式之间的相互转换</p></li></ul><h3 id="数据的独立性"><a href="#数据的独立性" class="headerlink" title="数据的独立性"></a>数据的独立性</h3><p>数据的独立性是指数据与程序独立，将数据的定义从程序中分离出去，由DBMS负责数据的存储，从而化简应用程序，大大减少了应用程序编制的工作量。数据的独立性是由DBMS的二级映像功能来保证的。</p><p>数据的独立性包括数据的物理独立性和数据的逻辑独立性。</p><ul><li><p>数据的物理独立性</p><p>是指当数据库的内模式发生改变时，数据的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是为了保证应用程序能正常执行，需要修改概念模式/内模式之间的映像。</p></li><li><p>数据的逻辑独立性</p><p>是指用户的应用程序与数据库的逻辑结构是独立的，数据的逻辑结构发生变化后，用户程序也可以不修改。但是为了保证应用程序能正常执行，需要修改外模式/概念模式之间的映像。</p></li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="数据模型的基本概念"><a href="#数据模型的基本概念" class="headerlink" title="数据模型的基本概念"></a>数据模型的基本概念</h2><p>模型就是对现实世界特征的模拟和抽象。最常用的数据模型分为概念数据模和基本数据模型。</p><ul><li><p>概念数据模型</p><p>概念数据模型称为信息模型，是按用户的观点对数和信息建模，是实现现实世界到信息世界的第一层抽象，强调其语义表达功能，用户用户理解，是用户和数据库设计人员的交流的语言，主要用于数据库设计。</p><p>这类模型中最著名的是实体联系模型，简称E-R模型。</p></li><li><p>基本数据模型</p><p>基本数据模型黑暗计算机系统的观点对数据建模，是现实世界数据特征的抽象用于DBMS的实现。</p><p>不同于数据模型具有不同的数据结构新形式，目前最常用的数据结构模型有层次模型、网状模型、关系模型和面向对象数据模型。其中，层次模型和网状模型统称为非关系模型。</p><p>关系数据库系统是采用关系模型作为数据组织方式。</p></li></ul><h2 id="数据模型的三要素"><a href="#数据模型的三要素" class="headerlink" title="数据模型的三要素"></a>数据模型的三要素</h2><p>数据模型结构的基础是数据模型，是用来描述数据的一组概念和定义。</p><p>数据模型的三要素是数据结构、数据操作和数据的约束条件。</p><ul><li><p>数据结构</p><p>是所研究的对象类型的集合，是对系统静态特性的描述。</p></li><li><p>数据操作</p><p>对数据库中各种对象（型）和实例（值）允许执行的操作的集合，包括操作及操作规则。如操作有检索、插入、删除和修改，操作规则有优先级别等。数据操作是对系统动态特性的描述，</p></li><li><p>数据的约束条件</p><p>是一组完整性规则的集合。</p></li></ul><h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>概念模型是对信息世界建模，所以概念模型能够方便、准确地表示信息世界中的常用概念。</p><h3 id="E-R方法"><a href="#E-R方法" class="headerlink" title="E-R方法"></a>E-R方法</h3><p>概念模式汇总最常用的方法为实体-联系方法，简称E-R方法。</p><p>在E-R图中，实体集合作为主码（或主键）的一部分属性下面加下划线标明。另外在实体集与联系的线段上标注联系的类型。</p><p>实体集有时简称实体，联系集有时简称联系。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>在E-R模型中实体用矩形表示，通常矩形框内写明实体名。实体是现实世界中可以区别于其他对象的“事件”或“物体”。实体集是具有相同属性的实体集合。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>在E-R模型中，联系用棱形表示。通常可在棱形框内写明联系名，总用无向边分别于有关实体连接起来，同时在无向边旁标注上联系的类型（1:1、1： <em>）或（****</em>：*****）。实体的联系分为实体内部的联系和实体于实体之间的联系。实体内部的联系反映数据在同一记录内部各字段间的联系。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是实体某方面的特性。</p><p>E-R模型中的属性有如下分类：</p><ul><li><p>简单属性和复合属性</p><p>简单属性是原子的、不可再分的，复合属性可细化分为更小的部分（即划分为别的属性）。有时希望用户访问整个属性，有时希望访问属性的某个成分，那么在模型设计时可采用复合属性。若不特别声明，通常指的是简单属性。</p></li><li><p>单值属性和多值属性</p><p>一个属性对应单一的值或对应一组值。</p></li><li><p>NULL属性</p><p>当属性在某个属性上没有值或属性值未知时，使用NULL值。表示无意义或不知道。</p></li><li><p>派生属性</p><p>派生属性可以型其他属性得来。</p><p>可以由其他属性进行计算来获得的属性。</p></li></ul><h3 id="扩展的E-R模型"><a href="#扩展的E-R模型" class="headerlink" title="扩展的E-R模型"></a>扩展的E-R模型</h3><p>扩充的E-R模型，包括弱实体、特殊化、概括和聚集等概念。</p><ul><li><p>弱实体</p><p>一个实体的存在必须以另一个为前提。其联系属于依赖联系。</p></li><li><p>特殊化</p><p>一个实体集可以按照某种特征区分为几个子实体。</p></li></ul><h2 id="基本的数据模型"><a href="#基本的数据模型" class="headerlink" title="基本的数据模型"></a>基本的数据模型</h2><h3 id="层次模型（Hierarchical-Model）"><a href="#层次模型（Hierarchical-Model）" class="headerlink" title="层次模型（Hierarchical Model）"></a>层次模型（Hierarchical Model）</h3><p>层次模型采用树形结构表示数据与数据间的联系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（二）程序设计语言</title>
    <link href="http://yoursite.com/2021/04/07/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/04/07/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</id>
    <published>2021-04-07T03:48:37.000Z</published>
    <updated>2021-06-03T13:50:43.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h1><h2 id="低级程序语言"><a href="#低级程序语言" class="headerlink" title="低级程序语言"></a>低级程序语言</h2><p>用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。</p><p>是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。</p><p>机器语言具有灵活、直接执行、速度快等特点。</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>为了克服机器语言难读、难遍、难记和易出错的缺点，用于代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码。</p><p>汇编语言是一种使用助记符表示的仍然面向机器的计算机语言，也称为符号语言。</p><p>汇编程序：</p><p>​    输入：是用汇编语言书写的源程序。</p><p>​    输出：是用机器语言表示的目标程序。</p><h2 id="程序语言的分类"><a href="#程序语言的分类" class="headerlink" title="程序语言的分类"></a>程序语言的分类</h2><p>根据设计程序的方法将语言大致分为命令式和结构化的程序设计语言、面向对象的程序设计语言、函数式程序设计语言和逻辑程序设计语言。</p><ul><li><p>命令式程序设计语言</p><p>命令式语言是基于动作的语言，在这种语言中，计算被看成是动作的序列。</p><p>通常所称的结构化程序设计语言属于命令式语言类，其结构特性主要反映在以下几个方面：</p><ul><li>用自顶向下逐步精化的方法编程</li><li>按模块组织的方法编程</li><li>程序只包含顺序、判定（分支）及循环构造（每种构造只允许单入口和单出口）</li></ul><p>特点：结构化的程序结构简单清晰、模块划强，描述方式接近人们的习惯的推理式思维方式，因此可读性强。在软件重用性、软件维护等方面都有所进步，在大型软件开发中曾发挥过重要的作用。</p><p>举例：C语言、Pascal</p></li><li><p>面向对象的程序设计语言</p><p>面对对象的程序设计在很大程度上应归功于从模拟领域发展起来的Simula，其提出了对象和类的概念。</p><p>特点：它们都必须支持新的程序设计技术，如数据隐藏、数据抽象、用户定义类型、继承和多态等。</p><p>举例：C++、Java、Smalltalk</p></li><li><p>函数式程序设计语言</p><p>函数式语言是一种类似。演算为基础的语言，其基本概念来自于LISP。函数是一种对应规则（映射），它使定义域中每个元素的值域中唯一的元素对应。</p><p>优点：对于表达式汇总出现的任何函数都可以用其他函数代替，只要这些函数调用产生相同的值。</p><p>举例：HasKell、Scala、Scheme、APL</p></li></ul><h2 id="编译-解释程序"><a href="#编译-解释程序" class="headerlink" title="编译/解释程序"></a>编译/解释程序</h2><p>解释程序也称为解释器，它或者直接解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行。</p><p>编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。</p><ul><li><p>根本区别：</p><ul><li><p>在编译方式下</p><p>机器上运行的与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程。</p></li><li><p>在解释方式下</p><p>解释程序和源程序（或某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。</p></li></ul></li></ul><div class="note warning flat"><p>简单来说，在解释方式下，翻译程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p></div><h3 id="编译与解释方式的比较"><a href="#编译与解释方式的比较" class="headerlink" title="编译与解释方式的比较"></a>编译与解释方式的比较</h3><p>对于高级语言的编译和解释工作方式，可以从如下几个方面比较：</p><ul><li><p>效率</p><p>编译比解释方式可能取得更高的效率</p></li><li><p>灵活性</p><p>由于解释程序需要反复检查源程序，这也使得解释方式能够比编译方式更灵活。</p><p>另外，当解释器直接在源程序上工作时，它可以多错误进行更精准的定位</p></li><li><p>可移植性</p><p>解释器一般也是用某个程序设计语言编写的，因此只要对解释器进行重新编译，就可以使解释器运行在不同的环境中。</p></li></ul><h2 id="编译程序基本原理"><a href="#编译程序基本原理" class="headerlink" title="编译程序基本原理"></a>编译程序基本原理</h2><h3 id="编译过程概述"><a href="#编译过程概述" class="headerlink" title="编译过程概述"></a>编译过程概述</h3><p>编译程序的作用是把某种高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机器语言形式）。编译程序的工作一般可以分为6个阶段。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是对源程序从前到后（从左到右）逐个字符的扫描，从中识别出一个个“单词”符号。“单词”符号是程序设计语言的基本语法单元，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等，词法分析程序输出的“单词”以二元祖的方式输出，及单词类别和单词自身的值。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单元，如“表达式”“语句”“程序”的等。</p><p>通过语法分析确定整个输入串是否构成一个语法上正确的程序。</p><p>如果程序中没有语法错误，语法分析后就能正确的构造出其语法树。</p><p>否则就指出语法错误，并给出相应的诊断信息。</p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>语义分析阶段分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。</p><p>语义分析的一个主要工作是进行类型分析和检查。</p><p>程序语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。</p><h4 id="中间代码生成阶段"><a href="#中间代码生成阶段" class="headerlink" title="中间代码生成阶段"></a>中间代码生成阶段</h4><p>中间代码生成阶段的工作是根据语义分析的暑促好生成中间代码。</p><p>“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。</p><p>最长用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。</p><p>语义分析和中间代码生成所依据的是语言的语义规则。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>由于生成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间和空间方面的效率较差。当需要生成高效的目标代码，就必须进行优化。优化过程可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行。</p><p>由于中间代码不依赖于具体机器，此时所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关。优化所依据的原则是程序的等价变换规则。</p><h4 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h4><p>目标代码生成是编译器工作的最后一个阶段。任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关。</p><h4 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h4><p>符号表的作用是记录源程序中各符号的必要信息，以辅助语义的正确性检查和代码生成。在编译过程中需要对符号表进行快速有效的查找、插入、修改和删除等操作。</p><p>符号表的建立可始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。</p><h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>源程序的错误大致分为静态错误和动态错误。</p><p>动态错误也称动态语义错误，它们发生在程序运行时。</p><p>静态错误是指编译阶段发现的程序错误，可以分为语法错误和静态语义错误。</p><div class="note warning flat"><p>在编译器的各个阶段，在逻辑上，可以把它们划分为前段和后端两部分。</p><p>前段包括从词法分析到中间代码生成各阶段的工作，后端包括中间代码优化的目标代码生成及优化等阶段。</p><p>因此，以中间代码为分水岭，把编译器分成了与机器有关的部分和无关的部分。</p></div><h2 id="中缀表达式与后缀表达式"><a href="#中缀表达式与后缀表达式" class="headerlink" title="中缀表达式与后缀表达式"></a>中缀表达式与后缀表达式</h2><h2 id="程序语言的基本成分"><a href="#程序语言的基本成分" class="headerlink" title="程序语言的基本成分"></a>程序语言的基本成分</h2><p>程序语言的基本成分包括数据、运算、控制、传输。</p><h3 id="程序设计的数据成分"><a href="#程序设计的数据成分" class="headerlink" title="程序设计的数据成分"></a>程序设计的数据成分</h3><p>程序语言的数据成分指其程序中的数据对象。</p><p>数据是程序操作的对象，具有存储类别、类型、名称、作用域和生存周期等属性，使用时要为它分配内存空间。</p><p>数据名称由用户通过标识符命名，在一些语言中，标识符是由字母、数字和下划线组成的标记；类型说明数据占用内存的大小和存放形式；存储类型说明数据在内存中的位置和生存期；作用域则说明可以使用数据的代码范围；生存期说明数据占用内存的时间范围。</p><p>从不同角度俄将数据进行不同的划分。</p><ul><li><p>常量和变量</p><p>按照成语运行时数据的值能否改变，将程序中的水分为常量和变量。</p><p>程序中的数据对象可以具有左值和（或）右值，左值值存储单元（或地址、容器），右值是值（或内容）。</p><p>变量具有左值和右值，在程序运行过程中其右值可以改变；常量只有右值，在程序运行过程中其右值不能改变。</p></li><li><p>全局变量和局部变量</p><p>按数据的作用域范围，可将其分为全局变量和局部变量。</p><p>系统为全局变量分配的存储空间在程序运行的过程中一般是不改变的，而为局部变量的存储单元是可以动态改变的。</p></li><li><p>数据类型</p><p>按照数据组织形式不同将数据分为基本类型、用户定义类型、构造类型和其他类型。</p><p>以C/C++为例，其数据类型如下：</p><ul><li>基本类型：整形（int）、字符型（char）、实型（float、double）和布尔类型（bool）</li><li>特殊类型：空类型（void）</li><li>用户定义类型：枚举类型（enum）</li><li>构造类型：数组、结构、组合</li><li>指针类型：type*</li><li>抽象数据类型：类类型</li></ul></li></ul><h3 id="程序语言的运算成分"><a href="#程序语言的运算成分" class="headerlink" title="程序语言的运算成分"></a>程序语言的运算成分</h3><p>程序语言的运算成分指明允许使用的运算符号及运算规则。</p><p>大多数高级程序语言的基本云元可以分为算数运算、关系运算、逻辑运算等，有些语言如C/C++还提供位运算。</p><h3 id="程序语言的控制成分"><a href="#程序语言的控制成分" class="headerlink" title="程序语言的控制成分"></a>程序语言的控制成分</h3><p>控制成分指明语言允许表述的控制结构。可以用顺序、选择和循环这三种控制结构来描述。</p><ul><li><p>顺序结构</p><p>用来表示一个计算操作序列。计算过程从多描述的第一个操作开始，按顺序依次执行后续的操作，知道学咧的最后一个操作。</p></li><li><p>选择结构</p><p>提供两个或多种分支中选择其中一个的逻辑。</p><p>基本的选择结构是指指定一条件P，然后根据条件的成立与否决定控制流走计算A还是计算B，从这两个分支选择一个执行。选择结构的计算还可以包含顺序、选择和重复循环。</p></li><li><p>循环结构</p><p>循环结构描述了重复计算的过程，通常由三部分组成：初始化、循环体和循环条件。其中初始化部分有时不进行显示的表现。</p><p>循环结构主要有两种形式：while型循环结构和do-while型循环结构。</p></li></ul><h4 id="C-C-语言中的控制语句"><a href="#C-C-语言中的控制语句" class="headerlink" title="C/C++语言中的控制语句"></a>C/C++语言中的控制语句</h4><ul><li><p>复合语句</p><p>用于描述顺序结构，其作用是昂多条语句组成一个可执行单元。</p><p>复合语句是一个整体，要么全部执行，要么一条语句也不执行。</p></li><li><p>if语句和swith语句</p><ul><li><p>if语句实现的是双分支的选择结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（表达式）语句<span class="number">1</span>；<span class="keyword">else</span> 语句<span class="number">2</span>；</span><br></pre></td></tr></table></figure><p>使用if语句时，需要注意if和else的匹配关系。C/C++语言规定，else总是域距离他最近的尚没有else的if相匹配。</p></li><li><p>swith语句描述了多分支的选择结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swith（表达式）&#123;</span><br><span class="line">case 常量表达式1:语句1;</span><br><span class="line">case 常量表达式2:语句2;</span><br><span class="line">...</span><br><span class="line">case 常量表达式n:语句n;</span><br><span class="line">default:语句n+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行swith语句时，首先计算表达式的值。</p><p>常量表达式通常为字符型或整形。多个常量表达式可以共用一个语句组。</p></li></ul></li><li><p>循环语句</p><ul><li><p>while语句。</p><p>while语句描述了先判断条件再执行循环体的控制结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while（条件表达式）循环体语句;</span><br></pre></td></tr></table></figure><p>执行while语句时，先计算条件表达式的值，当值为非0时，就执行循环体语句，然后重新计算条件表达式的值后再进行判断，否则就结束while语句的执行过程。</p></li><li><p>do-while语句</p><p>do-while语句描述了先制性循环体再判断条件的控制结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">循环体语句;</span><br><span class="line">while（条件表达式）;</span><br></pre></td></tr></table></figure><p>先执行循环体语句，然后再久安表达式的值，若值为非0，则再一次的执行循环体语句。</p></li><li><p>for语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for（表达式1;表达式2;表达式3）循环体语句;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>程序语言的传输成分指明语句允许的数据传输方式，如赋值操作、数据输入/输出等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>函数定义</p><p>函数的定义包括两部分：函数首部和函数体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值的类型 函数名（形式参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首部说明了函数返回值的数据类型、函数的名字和函数运行时所需的参数及类型。</p><p>C/C++程序中多有函数的定义都是独立的，不允许函数的嵌套定义。</p></li><li><p>函数声明</p><p>对于函数，先声明后引用。函数原型用于声明函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名（参数类型表）</span><br></pre></td></tr></table></figure><p>使用函数原型的目的是告诉编译器传递给函数的参数个数、类型以及函数返回值的类型。</p></li><li><p>函数调用</p><p>当在一个函数（称为主函数）汇总需要使用另一个函数（称为被调用函数）实现的功能时，便以名字进行调用，称为函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名（参数表）;</span><br></pre></td></tr></table></figure><p>在C程序的执行过程中，通过函数调用实现函数定义时描述的功能。函数体中若调用自己，则称为递归调用。</p><p>函数调用时实参于形参间交换信息的方式有值调用和引用调用两种。</p><ul><li><p>值调用</p><p>若实现函数调用时实参向形式参数传递相应类型的值，则称为是传值调用，这种方式下形参不能向实参传递信息。</p></li><li><p>引用调用</p><p>引用是C++中增加的数据类型，当形参为引用类型时，形参名实际上是实参的别名，函数中形参的访问和修改实际上就是针对相应实际参数所做的访问和改变。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（一）计算机系统知识</title>
    <link href="http://yoursite.com/2021/04/06/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2021/04/06/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-04-06T06:13:16.000Z</published>
    <updated>2021-06-03T13:50:37.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CPU的相关组件"><a href="#CPU的相关组件" class="headerlink" title="CPU的相关组件"></a>CPU的相关组件</h1><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><ul><li><p>算数逻辑单元（ALU）</p><p><span style ='color: #FF0000;'>功能：负责处理数据，实现对数据的算数运算可逻辑运算。</span></p></li><li><p>累加寄存器（AC）</p><p>AC通常简称为累加器，它是一个通用寄存器</p><p><span style ='color: #FF0000;'>功能：当运算器的算数逻辑单元执行运算或逻辑运算时，为ALU提供一个工作区。</span></p></li><li><p>数据缓冲寄存器（DR）</p><p><span style ='color: #FF0000;'>作用：为CPU的内存、外部设备之间数据传输的中转站以及它们在操作速度上的缓冲；</span>在单累加器的运算器中，数据缓冲寄存器还可兼作操作数寄存器</p></li><li><p>状态条件寄存器（PSW）</p><p><span style ='color: #FF0000;'>功能：PSW保存根据算数指令和逻辑指令运行或测试的结果建立的各种条件码内容。</span></p><p>主要分为状态标志、控制标志</p><ul><li>运算结果进位标志（C）</li><li>运算结果溢出标志（V）</li><li>运算结果为0标志（Z）</li><li>运算结果为负标志（N）</li><li>中断标志（I）</li></ul></li><li><p>方向标志（D）</p><ul><li>单步标志</li></ul><p>注：一个算数结果产生一个运算结果，而一个逻辑产生一个判决。</p></li></ul><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器一般包含指令控制逻辑、时序控制逻辑、总线控制逻辑、中断控制逻辑等。</p><ul><li><p>时序控制逻辑</p><p>为每条指令按时间顺序提供应有的控制信号</p></li><li><p>总线控制逻辑</p><p>为多个功能部件服务的信息脱落通路的控制电路</p></li><li><p>中断控制逻辑</p><p>用于控制各种中断请求，并根据优先级对中断请求进行排序，逐个交给CPU处理</p></li></ul><p>指令控制逻辑要完成取指令、分析指令和执行指令的操作，其过程可分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等操作。</p><p>控制器在工作过程中主要使用如下几个部件：</p><ul><li><p>指令寄存器（IR）</p><p>一般用来保存当前正在执行的一条指令。</p></li><li><p>程序计数器（PC）</p><p>PC具有寄存信息和计数两种功能，又称为指令计数器。</p><p><span style ='color: #FF0000;'>是用于存放下一条指令所在单元的地址的地方。</span> 在程序执行前，必需将程序的起始地址，即程序的一条指令所在单元地址送入程序计数器，当执行指令时，CPU将自动修改程序计数器的内容，即每执行一条指令程序计数器增加一个量，使其指向下一个待指向的指令。程序的转移等操作也是通过该寄存器实现的。</p></li><li><p>地址寄存器（AR）</p><p><span style ='color: #FF0000;'>一般AC保存当前CPU所访问的内存单元的地址，以方便内存的读写操作。</span> </p></li><li><p>指令译码器（ID）</p><p>指令包含操作码和地址码两部分。ID就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。</p></li></ul><h2 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h2><p>略</p><p>&nbsp;</p><h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><p>所谓总线（Bus），是指计算机设备和设备传输信息的公共数据通道。</p><p>重要特征：总线上的所有设备共享</p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><ul><li><p>数据总线（Data Bus，DB）</p><p>用来传输数据，是双向的。</p><p>DB的带宽决定了CPU和计算机其他设备之间每次交换数据的位数。</p></li><li><p>地址总线（Address Bus，AB）</p><p>用于传输CPU发出的地址信息，是单向的。</p><p>地址总线的宽度决定了CPU的最大寻址能力。</p></li><li><p>控制总线（Control Bus，CB）</p><p>用来传送控制信号、时序信号和状态信息等。</p><p>CB中的每一条线的信息传输方向是单向且确定的，但CB作为一个整体是双向的。</p></li></ul><p>与芯片相连接的总线可分为前段总线（FSB）、存储总线、I/O总线、扩展总线等。</p><p>对于目前的计算机结构来说，控制芯片集成在主板上，典型的有南北桥结构和单芯片结构。</p><ul><li><p>南北桥芯片结构</p><p>北桥芯片直接与CPU、内存、显卡、南桥相连，控制CPU的类型、主板的总线频率、内存控制器、显示核心等。前段总线（FSB）是将CPU连接到北桥芯片的总线。内存总线是将内存连接到北桥芯片的总线，用于和北桥之间的通讯。显卡通过I/O总线连接到北桥芯片。</p><p>南桥芯片主要负责外部设备与内部CPU的联系。其中，通过I/O总线将外部I/O设备连接到南桥。扩展总线则是指主板上提供的一些PCI、ISA等插槽。</p></li><li><p>单芯片结构</p><p>单芯片组方式取消了北桥。由于CPU中内置了内存控制器，不再需要北桥来控制，减少了延迟。还有一些CPU集成了显示单元，使得显示芯片的频率更高，延迟更低。</p></li></ul><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><ul><li><p>总线的带宽</p><p>即单位时间内总线上可传输的信息量，单位是MB/s。</p></li><li><p>总线的位宽</p><p>即总线能同时传输的数据位数，有32位、64位等。</p></li><li><p>总线的工作频率</p><p>即总线的时钟频率，它是协调总线上各种操作的时钟频率。</p></li></ul><p>&nbsp;</p><h1 id="输入输出控制"><a href="#输入输出控制" class="headerlink" title="输入输出控制"></a>输入输出控制</h1><h2 id="I-O设备概述"><a href="#I-O设备概述" class="headerlink" title="I/O设备概述"></a>I/O设备概述</h2><p>I/O设备可分为块设备和字符设备两类。</p><p>块设备把信息存放在固定大小的块中，每个块都有自己的地址，独立于其他块，可寻址。</p><p>字符设备以字符为单位接收或发送一个字符流，字符设备不可以寻址。</p><h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><p>程序控制I/O是指外设数据的输入/输出过程是在CPU执行程序的控制下完成的。这种方式分为无条件传送和程序查询方式两种情况。</p><ul><li><p>无条件传送</p><p>此情况下，外设总是准备好的，它可以无条件地随时接收CPU发来的输出数据，也能够无条件地随时向CPU提供需要输入的数据</p></li><li><p>程序查询方式</p><p>通过COU执行程序来查询外设的状态，判断外设是否准备好接受数据或准备好了向CPU输入数据。CPU有针对性地外设的输入/输出服务。</p><p>缺点：1.降低了CPU的效率；2.对外部的突发事件无法做出及时响应。</p></li></ul><h2 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h2><p>利用中断方式完成数据的输入/输出过程为：当系统与外设交换数据时，CPU无须等待也不必起查询I/O设备的状态，而是处理其他事物。与程序控制方式相比，中断方式因为CPU无须等待而提高了效率。</p><p>在系统具有多个中断源的情况下，常用的处理方法如下：</p><ul><li><p>多中断信号线法</p><p>每个中断源都有属于自己的一根中断请求信号线向CPU提出中断请求</p></li><li><p>中断软件查询法</p><p>当CPU检测到一个中断请求信号后，即转入到中断服务程序去轮询每个中断源以确定是谁发出了请求。（设备的响应优先级又软件设定）</p></li><li><p>菊花链法</p><p>实际上是一种硬件查询法。所有的I/O模块共享一根共同的中断请求线，而中断确认信号则以链式在各模块间相连。当CPU检测到中断请求信号时，发出中断确认信号。中断确认信号依次在I/O模块间传递，直到发出请求的模块，该模块则把它的ID送往数据线由CPU读取。</p></li><li><p>总线仲裁法</p><p>设备发出中断请求前必须先获得总线控制权，所以可由总线仲裁机制来裁定谁可以发出中断请求信号。当CPU发出中断响应信号后，该模块则把它的ID送往数据线由CPU读取。</p></li><li><p>中断向量表法</p><p>中断向量用来保存各个中断源的中断服务程序的入口地址。当外设发出中断请求信号（INTR）后，由中断控制器（INTC）确定其中断号，并根据中断号查询中断向量表来取得其中断服务程序的入口地址，同时INTC吧中断请求信号提交给CPU。</p></li></ul><h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p>直接内存存取（Direct Memory Access，DMA）是指数据在内存与I/O设备间直接成块传送，不需要CPU的干涉，只需要CPU在过程开始启动与过程结束时的处理，实际操作由DMA硬件直接执行完成。（CPU放弃总线控制权）</p><p>在DMA传送数据时要占用系统总线，根据占用总线的方法不同，DMA可以分为中央处理器停止法、总线周期分时法、总线周期挪用法。（DMA传送数据时，CPU不能使用总线）</p><h2 id="输入-输出器（IOP）"><a href="#输入-输出器（IOP）" class="headerlink" title="输入/输出器（IOP）"></a>输入/输出器（IOP）</h2><p>DMA方式的出险减少了CPU对I/O操作的控制。使得CPU的效率显著提高，而通道的出现则进一步提高了CPU的效率。</p><p>通道又称输入输出处理器（Input Output Process，IOP）它分担了CPU的一部分功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传输。</p><p>通道方式提高了CPU的工作效率，但其实是以增加更多的硬件为代价的。</p><p>外围处理器（Peripheral Processor Unit，PPU）方式是通道方式的进一步发展，PPU的专用处理机，它根据I/O命令，完成对外设数据的输入输出。（用于分布式多机系统）</p><p>&nbsp;</p><h1 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h1><p>指令集体系结构（Instruction Set Arcitecture，ISA）是指一个处理器支持的指令和指令的字节级编码。</p><h2 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h2><p>复杂指令集计算机（Complex Instruction Set Computer，CISC）的基本思想是进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大而复杂。（例如：微处理器X86的体系结构）</p><ul><li>CISC的主要弊病如下：<ul><li>指令集过分庞大</li><li>微程序技术是CISC的重要支柱，每条负责指令都要执行一段解释性微程序才能完成，这就需要多个CPU周期，从而降低了机器的处理速度</li><li>由于指令系统过分庞大，使高级语言编译程序选择目标指令的范围很大，并使编译程序本省冗长而复杂，从而难以优化编译使之生成真正高效的目标代码</li><li>CISC强调完善的中断控制，势必导致动作繁多，设计复杂，研制周期长</li><li>CISC给芯片设计带来很多困难，是芯片种类增多，出错率增大，成本提高而成品率降低</li></ul></li></ul><h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p>精简指令集计算机（Reduced Instruction Set Computer，RISC）的基本思想是通过减少指令总数的简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译，提高指令的执行速度，采用硬线控制逻辑。优化编译程序，导致机器的和指令系统进一步精炼而简单。（例如：ARM处理器）</p><p>RISC的关键技术如下：</p><ul><li><p>重叠寄存器窗口技术</p><p>其基本思想是在处理机中设置一个数量较大的寄存器堆，并把它们划分为多个窗口。</p></li><li><p>优化编译技术</p><p>RISC使用了大量的寄存器，如何合理分配寄存器、提高寄存器的使用效率及减少访问次数等，都应通过编辑技术的优化来实现</p></li><li><p>超流水线及超标量技术</p><p>其是为了进一步提高流水线速度而采用的技术</p></li><li><p>硬布线逻辑与微程序向结合在微程序技术中</p></li></ul><p>&nbsp;</p><h1 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h1><p>流水线技术是将一个较复杂的处理过程分为m各复杂程度相当、处理时间大致相等的子过程，每个子过程由一个独立的功能部件完成。处理对象在各个子过程连成的线路上连续流动，同一时间，m个部件同时进行不同的操作，完成对不同对象的处理。</p><p>流水处理技术是在重叠、先行控制方式的基础上发展起来的。</p><h2 id="指令控制方式"><a href="#指令控制方式" class="headerlink" title="指令控制方式"></a>指令控制方式</h2><ul><li><p>顺序方式</p><p>指各计算器指令之间顺序串行地执行。</p><p>优点：控制简单</p><p>缺点：速度慢、各部件的利用率低。</p></li><li><p>重叠方式</p><p>是指在解释第K条指令的操作完成之前，即开始解释第K+1条指令。</p><p>优点：速度有所提升，控制也不算太复杂</p><p>缺点：会出现冲突、转移和相关的问题，在设计时必须想办法解决</p></li><li><p>流水方式</p><p>流水（pipe lining）技术是把并行性或并发性嵌入计算机系统的一种形式，它把重复的顺序处理过程分解为若干个子过程，每个子过程能在专用的独立模块上有效的并发工作。</p></li></ul><div class="note warning flat"><p>在概念上，“流水”可以看成是“重叠”的延伸，差别仅在于“一次重叠”只是把一条指令解析分解为两个子过程，而“流水”则是分解为更多的子过程。</p></div><h2 id="流水线的种类"><a href="#流水线的种类" class="headerlink" title="流水线的种类"></a>流水线的种类</h2><ul><li>级别角度：部件级、处理机级、系统级</li><li>功能角度：单功能流水线、多功能流水线</li><li>联接角度：静态流水线、动态流水线</li><li>反馈回路：线性流水线、非线性流水线</li><li>流动顺序：同步流水线、异步流水线</li><li>数据表示：标量流水线、向量流水线</li></ul><h2 id="流水线的相关处理"><a href="#流水线的相关处理" class="headerlink" title="流水线的相关处理"></a>流水线的相关处理</h2><p>RISC采用的流水线技术有三种：超流水线、超标量、超长指令字。</p><ul><li><p>超流水线技术</p><p>超流水线（super pipeline）技术是RISC采用的一种并行处理技术。它通过细化流水、增加级数和提高主频，使得在每个机器周期内完成一个甚至两个浮点操作。其实质是以时间换取空间。</p></li><li><p>超标量技术</p><p>超标量（super scalar）技术是RISC采用的有一种并行处理技术，它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却又更小的CCPI。其实质是以空间换区时间。</p></li><li><p>超长指令字技术</p><p>超长指令字（Very Long Instruction World，VLIW）技术由LIW发展而来。VLIW和超标量都是20世纪80年代出现的概念，其共同点是要同时执行多条指令，其不同于超标量依靠硬件来实现并行处理的调度，VLIW则充分发挥软件的作用，而使硬件简化，性能提高。VLIW有更小的CPI值，但需要有足够的时钟频率。</p></li></ul><h2 id="吞吐率和流水建立的时间"><a href="#吞吐率和流水建立的时间" class="headerlink" title="吞吐率和流水建立的时间"></a>吞吐率和流水建立的时间</h2><p>吞吐率是指单位时间里流水线处理机流出的结果数。对指令而言，就是单位时间里执行的指令数。</p><p>如果流水线的子过程所用的子过程所用时间一样，则吞吐率P应为最长子过程所用时间的倒数。</p><p>流水线开始工作，需经过一段时间才能达到最大吞吐率，这就是建立时间。若m个子过程所用的时间一样，均为t，则建立时间T=mt。</p><p>&nbsp;</p><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><h2 id="计算机可靠性概述"><a href="#计算机可靠性概述" class="headerlink" title="计算机可靠性概述"></a>计算机可靠性概述</h2><p>元件的可靠性分为三个阶段：开始阶段器件工作处于不稳定期，失效率较高；第二阶段器件进入正常工作期，失效率最低，基本保持常数；第三阶段元器件开始老化，失效率有重新增高。这就是所谓的“浴盆曲线”。</p><p>计算机系统的可靠性是指从它开始运行（t=0）到某时刻t这段时间内正常运行的概率，用R(t)表示。所谓失效率是指单位时间内失效元件数与元件总数的比例，用  表示，当。为常数时，可靠性与失效率的关系为：R(t)=e</p><p>两次故障之间系统能正常工作时间的平均值称为平均无故障时间（MTBF），即：</p><p>通常平均修复时间（MTRF）来表示计算机的可维修性，即计算机的维修效率，指从故障发生到机器修复平均所需要的时间。计算机的可用性是指计算机的使用效率，它与系统在执行任务的任意时刻能正常工作的概率A来表示，即：</p><p>计算机的RAS就是指可靠性R、可用性A和可维修性S三个指标衡量一个计算机系统。</p><h2 id="计算机可靠性模型"><a href="#计算机可靠性模型" class="headerlink" title="计算机可靠性模型"></a>计算机可靠性模型</h2><h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a>串联系统</h3><p>假设一个系统由N个子系统组成，当且仅当所有的子系统都能正常运行，系统才能正常工作，这样的系统称为串联系统。</p><h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a>并联系统</h3><p>假设一个系统由N个子系统组成，只要有一个子系统正常工作，系统就能正常工作，这样的系统称为并联系统。</p><h3 id="N模冗余系统"><a href="#N模冗余系统" class="headerlink" title="N模冗余系统"></a>N模冗余系统</h3><p>N模荣誉系统由N个（N=2n+1）相同的子系统和一个表决器组成，表决器把N个子系统汇总占多数相同结果的输出作为系统的输出。</p><div class="note warning flat"><p>提高计算机的可靠性一般采用如下两项措施：</p><ol><li>提高元器件质量，改进加工工艺与工艺结构，完善电路设计。</li><li>发展容错技术，使得在计算机硬件有故障的情况下，计算机仍能继续运行，得出正确的结果。</li></ol></div><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><ul><li><p>立即寻址</p><p>是一种特殊的寻址方式，指令中在操作码字段后面的部分不是通常意义上的操作数地址，而是操作数本身，也就是说数据就包含在指令汇总，只要取出指令，也就取出了可以立即使用的操作数。</p></li><li><p>直接寻址</p><p>在直接寻址中指令中地址码字段给出的地址A就是操作数的有效地址，即形式地址等于有效地址。</p></li><li><p>间接寻址</p><p>间接寻址意味着指令中给出的地址A不是操作数的地址，而是存放操作数的主存单元的地址，简称操作数地址的地址。</p></li><li><p>寄存器寻址</p><p>寄存器寻址指令的地址码部分给出了某一个通用寄存器的编号Ri，这个指定的寄存器汇总存放着操作数。</p></li><li><p>寄存器间接寻址</p><p>在寄存器间接寻址方式中，寄存器内存放的是操作数的地址，而不是操作数本身，即操作数是通过寄存器间接寻址得到的。</p></li><li><p>变址寻址</p><p>变址寻址就是把变址寄存器Rx的内容与指令中给出的形式地址A相加，形式地址数有效地址，即EA=（Rx）+A。</p></li><li><p>基址寻址</p><p>基址寻址睡昂基址寄存器Rb的内容与指令汇总给出的位移向量D相加，形成操作数有效地址，即EA=（Rb）+D。</p></li><li><p>相对寻址</p><p>相对寻址好似基址寻址的一种变通，有程序计数器提供基准地址，指令汇总的地址码字段作为位移量D，两者相加后的到操作数的有效地址，即EA=（PC）+D。</p></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十九）Dom4j</title>
    <link href="http://yoursite.com/2021/03/22/JAVA%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89Dom4j/"/>
    <id>http://yoursite.com/2021/03/22/JAVA%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89Dom4j/</id>
    <published>2021-03-22T03:46:50.000Z</published>
    <updated>2021-03-29T03:20:42.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOM4J介绍"><a href="#DOM4J介绍" class="headerlink" title="DOM4J介绍"></a>DOM4J介绍</h1><p>DOM4J是dom4j.org出品的一个开源的XML解析包。DOM4J应用于Java平台，采用lJava集合框架并完全支持DOM、SAX和JAXP。</p><p>DOM4J使用非常简单。只要了解基本的XML-DOM模型，就能使用。</p><p>Dom：把一个文档作为一个对象。</p><p>DOM4J最大的特点是使用大量的接口，他的主要接口都在org.dom4j里面定义。</p><table><thead><tr><th>接口名</th><th>定义</th></tr></thead><tbody><tr><td>Atribute</td><td>定义了XML的属性</td></tr><tr><td>Branch</td><td>指能够包含字节点的节点。如XML元素（Element）和文档（Document）定义了一个公共的行为</td></tr><tr><td>CDDATA</td><td>定义了XML CDATA区域</td></tr><tr><td>CharacterData</td><td>是一个标识接口，标识基于字符的节点。如CDATA、Comment、Text</td></tr><tr><td>Comment</td><td>定义了XML注释的行为</td></tr><tr><td>Document</td><td>定义了XML文档</td></tr><tr><td>DocumentType</td><td>定义了XML DOCTYPE声明</td></tr><tr><td>Element</td><td>定义了XML元素</td></tr><tr><td>ElementHandler</td><td>定义了Element对象的处理器</td></tr><tr><td>ElementPath</td><td>被ElementHandler使用，用于取得当前正在处理的路径层次信息</td></tr><tr><td>Entity</td><td>定义了XML Entity实例</td></tr><tr><td>Node</td><td>为dom4j中所有的XML节点定义了多态行为</td></tr><tr><td>NodeFilter</td><td>定义了在dom4j节点产生的一个滤镜或谓语的行为（predicate）</td></tr><tr><td>ProcessingInstruction</td><td>定义了XML处理指令</td></tr><tr><td>Text</td><td>定义； XML文本节点</td></tr><tr><td>Visitor</td><td>用于实现Visitor</td></tr><tr><td>XPath</td><td>在分析一个字符串后提供了一个XPath表达式</td></tr></tbody></table><p>各接口的继承关系如下：</p><ul><li>interface java.lang.Cloneable<ul><li>interface org.dom4j.**Node<ul><li> interface org.dom4j.Attribute</li><li>interface org.dom4j.Branch<ul><li>interface org.dom4j.Document</li><li> interface org.dom4j.Element</li></ul></li><li>interface org.dom4j.CharacterData<ul><li>interface org.dom4j.CDATA</li><li> interface org.dom4j.Comment</li><li>interface org.dom4j.Text</li></ul></li><li>interface org.dom4j.DocumentType</li><li>interface org.dom4j.Entity</li><li>interface org.dom4j.ProcessingInstruction</li></ul></li></ul></li></ul><h1 id="XML-文档操作"><a href="#XML-文档操作" class="headerlink" title="XML 文档操作"></a>XML 文档操作</h1><h2 id="读取XML文档"><a href="#读取XML文档" class="headerlink" title="读取XML文档"></a>读取XML文档</h2><p>读写MXL额外拿的那个主要依赖于<code>org.dom4j.io</code>包，有<code>DOMReader</code>和<code>SAXReader</code>两种方式。因为利用了相同的接口，他们的调用方式是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">load</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">  Document doc = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    doc = reader.read(<span class="keyword">new</span> File(filename));</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">load</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">  Document doc = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    doc = reader.read(url));</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取指定的XML文件之后返回一个Document对象，这个对象代表了整个XML文档，用于各种Dom操作。执照XML文件头所定义的编码来转换。</p><h2 id="获取根结点"><a href="#获取根结点" class="headerlink" title="获取根结点"></a>获取根结点</h2><p>根结点是XML分析的开始，任何XML分析工作哦度需要从 根开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="comment">//获取根节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的简称：&quot;</span>);</span><br><span class="line">String Jname = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的id：&quot;</span>);</span><br><span class="line">String id = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的name：&quot;</span>);</span><br><span class="line">String name = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将xml文件转为Doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在根结点上添加新的book节点</span></span><br><span class="line">Element newbook = element.addElement(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">newbook.addAttribute(<span class="string">&quot;name&quot;</span>, Jname);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在book节点中添加数据</span></span><br><span class="line">Element newid = newbook.addElement(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">newid.setText(id);</span><br><span class="line"></span><br><span class="line">Element newname = newbook.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">newname.setText(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of =OutputFormat.createCompactFormat();</span><br><span class="line">of.setEncoding(<span class="string">&quot;uft-8&quot;</span>);</span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>)));</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要删除的节点：&quot;</span>);</span><br><span class="line">String findname = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件转为Doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根结点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">Element element1 = (Element) iterator.next();</span><br><span class="line"><span class="keyword">if</span>(findname.equals(element1.attributeValue(<span class="string">&quot;name&quot;</span>))) &#123;</span><br><span class="line">Element ele = element1;</span><br><span class="line">ele.getParent().remove(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of = OutputFormat.createPrettyPrint();</span><br><span class="line">of.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;filename&quot;</span>),of);</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改节点"><a href="#更改节点" class="headerlink" title="更改节点"></a>更改节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要修改书的简称：&quot;</span>);</span><br><span class="line">String findname = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件转为doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根结点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取字节节点</span></span><br><span class="line">Element element1 = (Element)iterator.next();</span><br><span class="line"><span class="keyword">if</span>(findname.equals(element1.attributeValue(<span class="string">&quot;name&quot;</span>))) &#123;</span><br><span class="line"><span class="comment">//定义新的节点</span></span><br><span class="line">Element ele = element1;</span><br><span class="line"><span class="comment">//创建用于存放数据的list集合</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">List&lt;Element&gt; list = ele.elements();</span><br><span class="line"><span class="keyword">if</span>(list!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;1.编号2.书名&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>+list.get(<span class="number">1</span>));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查无此书&quot;</span>+findname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查到相应书籍</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要修改的序号&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入新的id：&quot;</span>);</span><br><span class="line">list.get(<span class="number">0</span>).setText(sc.next());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入新的name：&quot;</span>);</span><br><span class="line">list.get(<span class="number">1</span>).setText(sc.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of = OutputFormat.createPrettyPrint();</span><br><span class="line">of.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">XMLWriter writer;</span><br><span class="line">writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//定义list集合用来存储数据</span></span><br><span class="line">ArrayList&lt;Book&gt; bookslist = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件封装为doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));<span class="comment">//此处将抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取doc对象的字节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取字节点</span></span><br><span class="line">Element element1 = (Element)iterator.next();</span><br><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">Iterator&lt;?&gt; iterator1 = element1.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Element element2 = (Element)iterator1.next();</span><br><span class="line"><span class="comment">//获取字节点的相关信息</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;id&quot;</span>.equals(element2.getName())) &#123;</span><br><span class="line"><span class="comment">//get.Text():获取相关数据,此处需要转型</span></span><br><span class="line">book.setId(Integer.parseInt(element2.getText()));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(element2.getName())) &#123;</span><br><span class="line">book.setName(element2.getText());</span><br><span class="line">&#125;</span><br><span class="line">&#125;bookslist.add(book);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Book book : bookslist) &#123;</span><br><span class="line">System.out.println(book.getId()+<span class="string">&quot;&quot;</span>+book.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Document对象相关"><a href="#Document对象相关" class="headerlink" title="Document对象相关"></a>Document对象相关</h2><ul><li><p>读取XML文件，获取Document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = <span class="keyword">new</span> reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>解析XML形式的文本，得到document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;&lt;members&gt;&lt;/members&gt;&quot;</span></span><br><span class="line">Document doc =DocumentHelper.praseText(text);</span><br></pre></td></tr></table></figure></li><li><p>主动创建document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = DocumentHelper.createDocument();</span><br><span class="line">Element root = document.addElement(<span class="string">&quot;members&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="节点相关"><a href="#节点相关" class="headerlink" title="节点相关"></a>节点相关</h2><ul><li><p>获取文档的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rootele = document.gerRootElement();</span><br></pre></td></tr></table></figure></li><li><p>获得某节点的单个子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element memberele = root.element(<span class="string">&quot;member&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得节点的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String text = memberele.getText();</span><br><span class="line"><span class="comment">//取得根结点下的name节点的文字</span></span><br><span class="line">String text = root.elementText(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得某节点下指定名称的所有节点并进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List nodes = rootele.elements(<span class="string">&quot;member&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Iterator it = nodes.iterator(); it.hasNext();)&#123;</span><br><span class="line">  Element ele = (Element)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对某节点下的所有子节点进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = root.elementIterator(); it.hasNext();)&#123;</span><br><span class="line">  Element elemetn = (Element) it.next();</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>某节点下添加子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element ageele = newMemberEle.addElement(<span class="string">&quot;age&quot;</span>;)</span><br></pre></td></tr></table></figure></li><li><p>设置节点文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ageele.setText(<span class="string">&quot;12&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除某节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentele.remove(childele);<span class="comment">//parentele是父节点，childele是呆删的子节点</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个CDATA节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element contentele = infoele.addElement(<span class="string">&quot;contect&quot;</span>);</span><br><span class="line">contectele.addCDARA(diary.gerContect());</span><br></pre></td></tr></table></figure></li></ul><h2 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h2><ul><li><p>取得节点的指定的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element root = document.getRootElement();</span><br><span class="line">Attribute attribute = root.attribute(<span class="string">&quot;size&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得属性的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String text = attribute.getText();</span><br><span class="line"><span class="comment">//获取根结点下name子节点的firstname属性的值</span></span><br><span class="line">String text2 = root.element(<span class="string">&quot;name&quot;</span>).attributeValue(<span class="string">&quot;firstname&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>遍历某节点的所有属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Element root = document.getRootElement();</span><br><span class="line"><span class="keyword">for</span>(Iterator it = root.attributeIterator(); it.hasNext();)&#123;</span><br><span class="line">  Attribute attribute = (Attribute) it.next();</span><br><span class="line">  String text = attribute.getText();</span><br><span class="line">  System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置某节点的属性和文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newMemberElm.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sitinspring&quot;</span>);   </span><br></pre></td></tr></table></figure></li><li><p>设置属性的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;name&quot;</span>);      </span><br><span class="line">attribute.setText(<span class="string">&quot;sitinspring&quot;</span>);      </span><br></pre></td></tr></table></figure></li><li><p>删除某属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;size&quot;</span>);<span class="comment">// 属性名name      </span></span><br><span class="line">root.remove(attribute);   </span><br></pre></td></tr></table></figure></li></ul><h2 id="将文档写入XML文件"><a href="#将文档写入XML文件" class="headerlink" title="将文档写入XML文件"></a>将文档写入XML文件</h2><ul><li><p>文档中全为英文,不设置编码,直接写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.xml&quot;</span>));      </span><br><span class="line">writer.write(document);      </span><br><span class="line">writer.close();  </span><br></pre></td></tr></table></figure></li><li><p>文档中含有中文,设置编码格式再写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">format.setEncoding(<span class="string">&quot;GBK&quot;</span>);    <span class="comment">// 指定XML编码</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.xml&quot;</span>),format);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串与XML的转换"><a href="#字符串与XML的转换" class="headerlink" title="字符串与XML的转换"></a>字符串与XML的转换</h2><ul><li><p>字符串与XML的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;&lt;members&gt; &lt;member&gt;sitinspring&lt;/member&gt; &lt;/members&gt;&quot;</span>;      </span><br><span class="line">Document document = DocumentHelper.parseText(text);   </span><br></pre></td></tr></table></figure></li><li><p>将文档或节点的XML转化为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;input.xml&quot;</span>));</span><br><span class="line">Element root=document.getRootElement();</span><br><span class="line">String docXmlText=document.asXML();</span><br><span class="line">String rootXmlText=root.asXML();</span><br><span class="line">Element memberElm=root.element(<span class="string">&quot;member&quot;</span>);</span><br><span class="line">String memberXmlText=memberElm.asXML();</span><br></pre></td></tr></table></figure><p>&nbsp;</p></li></ul><h1 id="DOM4J的类和接口"><a href="#DOM4J的类和接口" class="headerlink" title="DOM4J的类和接口"></a>DOM4J的类和接口</h1><h2 id="类：SAXReader"><a href="#类：SAXReader" class="headerlink" title="类：SAXReader"></a>类：SAXReader</h2><p>当解析到path指定的路径时，将调用参数handler指定的处理器。正对不同的节点可以添加多个handler实例。或者调用默认的HandlersetDefaultJandler(ElementHandler handler);</p><h2 id="接口：ElementHandler"><a href="#接口：ElementHandler" class="headerlink" title="接口：ElementHandler"></a>接口：ElementHandler</h2><p>该方法在解析到元素的开始、结束标签时被调用。</p><h2 id="接口：ElementPath"><a href="#接口：ElementPath" class="headerlink" title="接口：ElementPath"></a>接口：ElementPath</h2><p>该方法与SAXReader类中的addHandler()方法的作用相同。路径path可以是绝对路径（路径以/开头），也可以是相对路径（假设是当前路径的子节点路径）。</p><p>移除指定路径上的ElementHandler实例。路径可以是相对路径，也可以是绝对路径。</p><p>该方法得到当前节点的路径，该方法返回的是完整的绝对路径。</p><h2 id="Element类"><a href="#Element类" class="headerlink" title="Element类"></a>Element类</h2><table><thead><tr><th>方法名</th><th>定义</th></tr></thead><tbody><tr><td>getText()</td><td>元素所罕有的text内容，如果内容为空则返回一个空字符串而不是null</td></tr><tr><td>attributeValue()</td><td>元素的某个指定属性所含有的值</td></tr><tr><td>elementIterator()</td><td>元素属性的iterator，其中每个元素都是Element</td></tr></tbody></table><h2 id="DocumentHelper类"><a href="#DocumentHelper类" class="headerlink" title="DocumentHelper类"></a>DocumentHelper类</h2><p>DocumentHelper是用来生成XML文档的工厂类</p><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十八）XML</title>
    <link href="http://yoursite.com/2021/02/02/JAVA%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89XML/"/>
    <id>http://yoursite.com/2021/02/02/JAVA%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89XML/</id>
    <published>2021-02-02T02:38:02.000Z</published>
    <updated>2021-03-22T03:45:46.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML——（Extensible Markup Language可扩展标记语言）是一种很流行的简单的基于文本的语言来用作应用程序之间的通信模式。它被认为是传输标准装置和存储数据。Java提供了极好的支持和丰富的库来解析，修改或查询XML文档。</p><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML是一种简单的基于文本的语言，它被设计存储和运输以纯文本的数据。它代表着可扩展标记语言和运输以纯文本格式的数据，它代表着可扩展标记语言。</p><ul><li><p>特点</p><p>XML是一种标记语言</p><p>XML标签不像HTML那样定义</p><p>XML标签被设计成自描述性的</p><p>XML是W3C推荐用于数据存储和传输</p></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>技术无关</p><p>作为普通文本，XML是技术独立。它可用于有其他任何技术进行数据的存储和传输的目的。</p></li><li><p>人类可读</p><p>XML使用简单的文本格式，它是人类可读和可以理解的。</p></li><li><p>允许验证</p><p>使用XSD，DTD和XML结构可以很容易的验证</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>冗余的语法</p><p>通常XML文件中包含大量的重复计算。</p></li><li><p>冗余</p><p>作为一个冗长的语言，XML文件大小增加了传输的存储成本</p></li></ul><h1 id="JAVA-XML解析器"><a href="#JAVA-XML解析器" class="headerlink" title="JAVA XML解析器"></a>JAVA XML解析器</h1><p>解析XML是指将通过XML文档访问数据或修改数据的一个操作或方法。</p><h2 id="DOM方式"><a href="#DOM方式" class="headerlink" title="DOM方式"></a>DOM方式</h2><p>更具XML的层级结构在内存中分配一个树形结构，把XML的标签、属性和文本等元素都封装成数的节点对象</p><ul><li>优点：便于实现增、删、改、查</li><li>缺点：XML文件过大可能造成内存溢出</li></ul><h2 id="SAX方式"><a href="#SAX方式" class="headerlink" title="SAX方式"></a>SAX方式</h2><p>采用事件驱动模型边读边解析，从上到下一行行解析，解析到某一元素，调用相应解析方法</p><ul><li>优点：不会造成内存溢出</li><li>缺点：查询不便，但不能实现增、删、改</li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十七）TCP / UDP 通信协议</title>
    <link href="http://yoursite.com/2021/02/01/JAVA%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89TCP%20:%20UDP%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2021/02/01/JAVA%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89TCP%20:%20UDP%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-02-01T05:10:32.000Z</published>
    <updated>2021-03-20T13:34:08.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><p>TCP协议：传输控制层协议，面向有链接，数据可靠</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。在Internet上的主机一般运行了多个服务软件，同时提供集中服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</p><p>应用程序通常通过“套接字”向网络发出请求或应答网络请求。Socket和Serversocket类库位于java.net包中。ServerSocket用于服务端，Socket是创建网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。</p><h3 id="获取本地地址和端口号"><a href="#获取本地地址和端口号" class="headerlink" title="获取本地地址和端口号"></a>获取本地地址和端口号</h3><p>java.net.Scoket为套接字类，其提供了很多方法，其中我们可以通过获取socket获取本地的地址以及端口号。</p><ul><li><p>其方法为：</p><p><code>int getLocalPort();</code> 用于获取本地使用的端口号</p><p><code>InetAddress getLocalAddress();</code> 用于获取套接字绑定的本地地址</p><p>使用InetAddress获取本地的地址方法：</p><p><code>String getCanonicalHostName();</code> 获取此IP地址的完全限定名</p><p><code>String getHostAddress();</code> 返回IP地址字符串（以文本表现形式）</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">InetAddress add = socket.getLocalAddress();<span class="comment">//获取本地信息</span></span><br><span class="line">System.out.println(add.getCanonicalHostName());<span class="comment">// 获取此IP地址的完全限定名</span></span><br><span class="line">System.out.println(add.getHostAddress());<span class="comment">//用于获取套接字绑定的本地地址</span></span><br><span class="line">System.out.println(socket.getLocalPort());<span class="comment">//用于获取本地使用的端口号</span></span><br><span class="line">socket.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="获取远程地址和端口号"><a href="#获取远程地址和端口号" class="headerlink" title="获取远程地址和端口号"></a>获取远程地址和端口号</h3><p>Socket也提供了获取远端的地址以及端口号的方法：</p><ul><li><p>其方法为：</p><p><code>int getPort();</code> 用于获取远端使用的端口号</p><p><code>InetAddress getInetAddress();</code> 用于获取套接字绑定的远端地址</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">InetAddress inetadd = socket.getInetAddress();<span class="comment">//获取远端信息</span></span><br><span class="line">System.out.println(inetadd.getCanonicalHostName());<span class="comment">// 获取此IP地址的完全限定名</span></span><br><span class="line">System.out.println(inetadd.getHostAddress());<span class="comment">//用于获取套接字绑定的远端地址</span></span><br><span class="line">System.out.println(socket.getPort());<span class="comment">//用于获取远端使用的端口号</span></span><br><span class="line">socket.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="获取网络输入-输出流"><a href="#获取网络输入-输出流" class="headerlink" title="获取网络输入/输出流"></a>获取网络输入/输出流</h3><p>通过Socket获取输入流与输出流，这两个方法是使用Socket通讯的关键方法。封装了TCP协议的Socket是基于流进行通讯的，所以我们在创建了双方连接后，只需要获取相应的输入与输出流即可实现通讯。</p><ul><li><p>其方法为：</p><p>InputStream getInputStream(); 该方法用于返回此套接字的输入流。</p><p>OutputStream getOutputStream(); 该方法用于返回此套接字的输出流</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">   InputStream in = socket.getInputStream();</span><br><span class="line">   OutputStream out = socket.getOutputStream();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="close方法"><a href="#close方法" class="headerlink" title="close方法"></a>close方法</h3><p>当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源。</p><ul><li><p>其方法为：</p><p><code>void close();</code> 关闭Socket以释放资源</p></li></ul><p>当关闭了该套接字后也会同时关闭由此获取的输入流与输出流。</p><p>&nbsp;</p><h1 id="Scoket通讯模块"><a href="#Scoket通讯模块" class="headerlink" title="Scoket通讯模块"></a>Scoket通讯模块</h1><h3 id="Server端ServerSocket监听"><a href="#Server端ServerSocket监听" class="headerlink" title="Server端ServerSocket监听"></a>Server端ServerSocket监听</h3><p>java.net.ServerSocket是运行于服务端应用程序中，通过创建ServerSocket需要指定服务端口号，之后监听Socket的连接。</p><ul><li><p>其方法为：</p><p>Socket accept(); </p></li></ul><p>该方法是一个阻塞方法，直到一个客户端通过Socket连接后，accept会封装一个Socket，该Socket封装的表示该客户端的有关信息，通过这个Socket与客户端进行通信。</p><ul><li><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ServerSocket并申请服务端口8088</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line"><span class="comment">//方法会产生阻塞，知道某个Socket连接，并返回请求连接的Socket</span></span><br><span class="line">Socket socket = server.accept();</span><br></pre></td></tr></table></figure></li></ul><h3 id="Client端的Socket连接"><a href="#Client端的Socket连接" class="headerlink" title="Client端的Socket连接"></a>Client端的Socket连接</h3><p>当服务端ServerSocket调用accept方法阻塞等待客户端连接后，可以通过在客户端应用程序中创建Socket来向服务器发起连接。</p><div class="note warning flat"><p>创建Socket的同时就发起连接，若连接异常会抛出异常，我们通常创建Socket时会传入服务端的地址及服务端口号。</p></div><ul><li>代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:服务端的IP地址，参数2:服务端的服务端口</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br></pre></td></tr></table></figure><h3 id="C-S端通信模块"><a href="#C-S端通信模块" class="headerlink" title="C-S端通信模块"></a>C-S端通信模块</h3><p>C-S的全程为（Client-Server）：客户端-服务器端</p><p>客户端与服务端通信模型如下：</p><ul><li>步骤如下：<ol><li>服务端ServerSocket</li><li>通过调用ServerSocket的accept方法监听客户端的连接</li><li>客户端创建Socket并指定服务端的地址以及端口来建立与服务端的连接</li><li>当服务端accept发现客户端连接后，后去对应该客户端的Socket</li><li>双方通过Socket分别获取对应的输入与输出流进行数据通讯</li><li>通讯结束后关闭连接5</li></ol></li></ul><h3 id="Server端多线程模型"><a href="#Server端多线程模型" class="headerlink" title="Server端多线程模型"></a>Server端多线程模型</h3><p>可以创建一个线程类，并将客户端交互的工作全部委托给线程处理，这样就可以实现当一个客户端连接后，启动一线程来负责与客户端的交互，这样我们就可以实现循环不断的监听其他客户端连接。</p><p>&nbsp;</p><h1 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h1><p>UDP协议：用户数据报协议，面向无连接，数据不可靠</p><h2 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h2><h3 id="创建接受包"><a href="#创建接受包" class="headerlink" title="创建接受包"></a>创建接受包</h3><p>DatagramPacket：UDP数据报给予IP建立，没太主机有65535个端口号可以使用。数据报中字结束限制为65535-8，包含8字节的头信息。</p><ul><li><p>构造接受包：</p><p><code>DatagramPacket(byte[] buf, int length);</code> 将数据报中Length长的数据装进Buf数组。</p><p><code>DatagramPacket(byte[] buf, int offset, int lenth);</code> 将数据报中从Offset开始、Length长的数据装进Buf数组。</p></li></ul><h3 id="创建发送包"><a href="#创建发送包" class="headerlink" title="创建发送包"></a>创建发送包</h3><ul><li><p>构造发送包：</p><p><code>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int clientPort);</code> 从buf数组中取出Length长的数据创建数据报对象，目标是clientAddress地址、clientPort端口，常用来发送数据给客户端。</p><p><code>DatagramPacket(byte[] buf, int offset, int length, InetAddress clientAddress, int clientPort);</code> 从buf数组中，取出offset开始、Length长的数据创建数据报对象，目标是clientAddress地址、clientPort端口，常用来发送数据给客户端。</p></li></ul><h2 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h2><h3 id="服务端接受"><a href="#服务端接受" class="headerlink" title="服务端接受"></a>服务端接受</h3><p>DatagramSocket用于接受和发送UDP的Socket实例。</p><ul><li>其语法格式为：<code>DatagramSocket(int port);</code></li></ul><p>创建实例，并固定监听Port端口的报文。</p><ul><li><p>其中方法：</p><p><code>receive (DatagramPacket d);</code> 接受数据报文到d中，receive方法产生“阻塞”。会一直等待直到数据被读取到。</p></li></ul><h3 id="客户端发送"><a href="#客户端发送" class="headerlink" title="客户端发送"></a>客户端发送</h3><p>无参的构造方法DaragramSocket()通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的，程序会让操作系统分配一个可用的端口。</p><ul><li><p>其中方法：</p><p><code>send (DatagramPacket dp);</code> 该方法用于发送报文到目的地。</p></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
