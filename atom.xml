<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOEL-T99</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-13T08:29:28.008Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JOEL-T99</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数工 考点总结</title>
    <link href="http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/04/13/%E6%95%B0%E5%B7%A5%20%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-12T18:34:16.000Z</published>
    <updated>2021-04-13T08:29:28.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机操作类"><a href="#计算机操作类" class="headerlink" title="计算机操作类"></a>计算机操作类</h1><h2 id="计算机系统基础常识"><a href="#计算机系统基础常识" class="headerlink" title="计算机系统基础常识"></a>计算机系统基础常识</h2><h3 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h3><p>二进制数据在计算机系统中的表示方法是最基本的专业知识。补码本身是带符号位的，补码表示的数字中0是唯一的，不想原码有+0和-0之分，也意味着n位二进制编码可以表示（2^n）个不同的数。</p><h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><h3 id="2015-1"><a href="#2015-1" class="headerlink" title="2015"></a>2015</h3><p>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的，其次是Cache、内存的、硬盘（外设）。它们共同组成分级存储体系来解决存储容量、成本和速度之间的矛盾。</p><p>Cache工作时，需要拷贝主存信息到Cache中，就需要建立主存地址和Cache地址的映像关系。Cache的地址映像方法主要有三种，即全相联映像、直接映像和组相联映像。</p><ul><li><p><strong>全相联映像</strong></p><p>全相联映像方式意味着主存的任意一块可以映像到Cache中的任意一块。</p><p><strong>特点：</strong>块冲突概率低，Cache空间利用率高。</p><p><strong>缺点：</strong>相联目录表容量大导致成本高、查表速度慢。</p></li><li><p><strong>直接映像</strong></p><p>直接映像方式是指主存中的每一块只能映像到Cache汇总的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同。</p><p><strong>特点：</strong>硬件简单，不需要相联寄存器，访问速度快（无需地址变换）。</p><p><strong>缺点：</strong>Cache快冲突概率高导致Cache空间利用率很低。</p></li><li><p><strong>组相联映像</strong></p><p>组相联方式是对上述两种方式的折中处理，对Cache分组，实现组间直接映像，组内全相联，从而获取较低的冲突概率、较高的块利用率，同时的到较快的速度和较低的成本。</p></li></ul><p><strong>总线宽度：</strong>指总线的位数，即数据信号的并行传输能力，也体现总线占用物理空间和成本；总线的宽度是指最大传输率，即每秒传输的数据总量。总线的宽度与时钟频率共同决定了总线的带宽。例如：</p><p>32bit/8=4Byte，200MHz/5*4Byte=160MB/s</p><h3 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h3><p>CPU中有一些重要的寄存器：</p><ul><li><p>程序计数器（PC）</p><p>用于存放指令的地址。当程序顺序执行时，没去出一条指令，PC内容自动增加一个值，指向下一条要取的指令。当程序出现转移时，则将转移地址送入PC，然后由PC指出新的指令地址。</p></li><li><p>状态寄存器</p><p>用于记录运算中产生的标志信息。状态寄存器中的每一位单独使用，称为标识位。标志位的取值反映了ALU当前的各种状态，可以作为条件转移指令的转移条件。典型的标志位有以下几位：进位标志位（C）、零标志位（Z）、符号标志位（S）、溢出标志位（V）、奇偶标志位（P）。</p></li><li><p>通用寄存器组</p><p>是CPU中的一组工作寄存器，运算时用于暂存操作数或地址。在程序中使用通用寄存器可以减少访问内存的次数，提高运算速度。</p></li><li><p>累加器</p><p>是一个数据寄存器，在运算过程中暂时存放操作数和中间运算结果，不能用于长时间地保存一个数据。</p></li></ul><h2 id="计算机组成原理的基础知识"><a href="#计算机组成原理的基础知识" class="headerlink" title="计算机组成原理的基础知识"></a>计算机组成原理的基础知识</h2><h3 id="2015-2"><a href="#2015-2" class="headerlink" title="2015"></a>2015</h3><p><strong>中断相应时间：</strong>是指从发出中断请求到开始进入中断服务程序所需的时间。</p><h2 id="计算机系统结构基础知识"><a href="#计算机系统结构基础知识" class="headerlink" title="计算机系统结构基础知识"></a>计算机系统结构基础知识</h2><h3 id="2015-3"><a href="#2015-3" class="headerlink" title="2015"></a>2015</h3><p>对指令流水性能的度量有吞吐率、加速比和效率等指标。因此要使加速比效率最大化应该对流水线各级采用相同的运行时间。另外，流水线采用异步控制法并不会给流水线性能带来改善，反而会增加控制电路的复杂性。</p><ul><li><p><strong>吞吐率</strong></p><p>是指单位时间流水线所完成的任务数或输出结果的数量，最大吞吐率则是在达到稳定状态后所得到的吞吐率，它取决于流水线中最慢一段所需的时间，所以该段称为流水线的瓶颈。</p></li><li><p>加速比</p><p>是指等功能的非流水线执行时间与流水线执行时间之比，加速比与吞吐率成正比，如果流水线断流，实际吞吐率将会明显下降，则加速比也会明显下降。</p></li><li><p><strong>效率</strong></p><p>是指流水线的设备利用率，从时空图上看效率就是n个任务所占的时空区与m个段总的时空区之比。</p></li></ul><h1 id="网络安全类"><a href="#网络安全类" class="headerlink" title="网络安全类"></a>网络安全类</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="2015-4"><a href="#2015-4" class="headerlink" title="2015"></a>2015</h3><p>终端设备与远程站点之间建立安全连接的协议是SSH。SSH意为Secure Shell的缩写是由IETF制定的建立在应用层和传输层基础上的安全协议。SSH是专门远程登录会话和其他网络服务提供安全性的协议。</p><p><strong>安全需求分为：</strong>物理线路安全、网络安全、系统安全和应用安全。机房安全属于物理安全、入侵检测属于网络安全、漏洞补丁管理属于系统安全、数据库安全是应用安全。</p><p>把局域网划分为多个不同的VLAN，使得网络接入不再局限于物理地址的约束，这样做就简化了在网络中增加、移除和移动主机的配置，特别是动态配置VLAN，物理主机在哪里，它都属于自己的VLAN中。VLAN内部可以相互通信，VLAN之间不能直接通信，必须经过特殊配制的路由器才可以连通。这样做的结果是，通过在较大的局域网中创建不同的VLAN，可以抵御广播风暴的影响，也可以通过设置防火墙来提高网络的安全性。VLAN并不能直接增强网络的安全性。</p><h2 id="URL的基础知识"><a href="#URL的基础知识" class="headerlink" title="URL的基础知识"></a>URL的基础知识</h2><h3 id="2015-5"><a href="#2015-5" class="headerlink" title="2015"></a>2015</h3><p><strong>URL由三部分组成：</strong>资源类型、存放资源的主机域名、资源文件名。一般情况下，一个URL可以采用“主机名.域名”的形式打开指定的页面，也可以单独使用“域名”来打开指定的页面，但是这样实现的前提是需要进行相应的设置和对应。</p><h2 id="DHCP和FTP的两个应用协议"><a href="#DHCP和FTP的两个应用协议" class="headerlink" title="DHCP和FTP的两个应用协议"></a>DHCP和FTP的两个应用协议</h2><h3 id="2015-6"><a href="#2015-6" class="headerlink" title="2015"></a>2015</h3><p><strong>DHCP协议的功能：</strong>自动分配IP地址。</p><p><strong>FTP协议的作用：</strong>文件传输，使用的传输协议为TCP。</p><h1 id="知识产权类"><a href="#知识产权类" class="headerlink" title="知识产权类"></a>知识产权类</h1><h3 id="2015-7"><a href="#2015-7" class="headerlink" title="2015"></a>2015</h3><p>当两个以上的申请人分别就同样的发明创造申请专利的，专利授予最先申请的人。</p><h1 id="软件工程类"><a href="#软件工程类" class="headerlink" title="软件工程类"></a>软件工程类</h1><h2 id="软件工程的基本概念"><a href="#软件工程的基本概念" class="headerlink" title="软件工程的基本概念"></a>软件工程的基本概念</h2><h3 id="2015-8"><a href="#2015-8" class="headerlink" title="2015"></a>2015</h3><p><strong>软件工程的基本要素包括：</strong>方法、工具和过程。方法是产生某些结果的形式化过程；工具是用更好的方式完成某件事情的设备或自动化过程；过程是把工具和方法结合起来，定义涉及活动、约束和资源使用的一系列步骤，来达到某种想要的输出。</p><p>从工程管理角度，可以将软件设计分为两个阶段：<strong>概要设计阶段和详细设计阶段</strong>。结构化设计方法汇中，概要设计阶段进行软件体系结构的设计、数据设计和接口设计；详细设计阶段进行数据结构和算法的设计。面向对象设计中，概要设计阶段进行体系结构设计、初步的类设计/数据设计、结构设计；详细设计阶段进行构件设计。</p><p>结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序；面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p><h2 id="软件项目管理的基础知识"><a href="#软件项目管理的基础知识" class="headerlink" title="软件项目管理的基础知识"></a>软件项目管理的基础知识</h2><h3 id="2015-9"><a href="#2015-9" class="headerlink" title="2015"></a>2015</h3><p><strong>活动图</strong>是描述一个项目中各个工作任务相互依赖关系的一种模型，项目的很多重要特性可以通过分析活动图得到，如估算项目完成时间、计算关键路径和关键活动等。</p><p>在进行风险管理时，根据风险的优先级来确定风险控制策略，而优先级是根据风险暴露来确定的。风险暴露是一种量化风险影响的指标，等于风险影响乘以风险概率。风险影响是当风险发生时造成的损失。风险概率是风险管理的一个重要活动。</p><h1 id="程序语言类"><a href="#程序语言类" class="headerlink" title="程序语言类"></a>程序语言类</h1><h2 id="程序语言基础知识"><a href="#程序语言基础知识" class="headerlink" title="程序语言基础知识"></a>程序语言基础知识</h2><h3 id="2015-10"><a href="#2015-10" class="headerlink" title="2015"></a>2015</h3><p>程序设计语言的基本成分包括<strong>数据、运算、控制和传输</strong>等。</p><p>高级语言不依赖于具体的机器硬件。</p><p>局部变量只能在函数内部使用，其作用域是从定义位置到函数体或复合语句体结束为止。局部变量的值通常在其生存期内是变化的。</p><p>程序中的常量的值在运行时是不可改变的。</p><p>程序运行时的用户内存空间一般划分为代码区、静态数据区、栈区和堆区，其中栈区和堆区也称为动态数据区。全局变量的存储空间在静态数据区。</p><h2 id="软件过程模型的基础知识"><a href="#软件过程模型的基础知识" class="headerlink" title="软件过程模型的基础知识"></a>软件过程模型的基础知识</h2><h3 id="2015-11"><a href="#2015-11" class="headerlink" title="2015"></a>2015</h3><p>瀑布模型：将软件生存周期各个活动规定为线形顺序连接的若干阶段的模型。这是一种理想的现象开发模型，缺乏灵活性，无法解决软件需求不明确或不准确的问题。</p><p>原型模型：从初始的原型逐渐演化成为最红软件产品，特别适用于对软件需求缺乏准确的认识的情况。</p><p>增量开发：是把软件产品作为一系列的增量构件来设计、编码、集成和测试，可以在增量开发过程中逐步理解需求。</p><p>螺旋将瀑布模型与快速原型结合起来，并且加入了两种模型均忽略了的风险分析，适用于复杂的大型软件。</p><h1 id="系统开发和运行类"><a href="#系统开发和运行类" class="headerlink" title="系统开发和运行类"></a>系统开发和运行类</h1><h2 id="数据流图的概念和应用"><a href="#数据流图的概念和应用" class="headerlink" title="数据流图的概念和应用"></a>数据流图的概念和应用</h2><h3 id="2015-12"><a href="#2015-12" class="headerlink" title="2015"></a>2015</h3><p>数据流图或称数据流程图（Data Flow Diagram，DFD）是一种便于客户理解、分析系统数据流程的图形工具。数据流图描述堆数据的处理流程，着重系统信息的流向和处理过程。它摆脱了系统的物理内容，精确的在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p><h1 id="关系数据库类"><a href="#关系数据库类" class="headerlink" title="关系数据库类"></a>关系数据库类</h1><h2 id="关系数据库基础知识"><a href="#关系数据库基础知识" class="headerlink" title="关系数据库基础知识"></a>关系数据库基础知识</h2><h3 id="2015-13"><a href="#2015-13" class="headerlink" title="2015"></a>2015</h3><p><strong>简单属性</strong>是原子的、不可再分割的，<strong>复合属性</strong>可以细分为更小的部分（即划分为别的属性）。</p><h2 id="关系数据库中键的基本概念"><a href="#关系数据库中键的基本概念" class="headerlink" title="关系数据库中键的基本概念"></a>关系数据库中键的基本概念</h2><h3 id="2015-14"><a href="#2015-14" class="headerlink" title="2015"></a>2015</h3><p>关系数据库中，全码（All-key）指关系模型的所有属性组是这个关系模型的候选键。</p><h2 id="关系数据库E-R模型的相关知识"><a href="#关系数据库E-R模型的相关知识" class="headerlink" title="关系数据库E-R模型的相关知识"></a>关系数据库E-R模型的相关知识</h2><h3 id="2015-15"><a href="#2015-15" class="headerlink" title="2015"></a>2015</h3><p><strong>多对多联系向关系模式的转换的规则是：</strong>多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的主键及联系的属性，关系的码是多方实体的主键构成的属性组。</p><h2 id="数据表示基础知识"><a href="#数据表示基础知识" class="headerlink" title="数据表示基础知识"></a>数据表示基础知识</h2><h3 id="2014-1"><a href="#2014-1" class="headerlink" title="2014"></a>2014</h3><p>机器字长位n，最高位为标志位，则删除的n-1位用来表示数值，其最大是这n-1位都位都位1，也就是（2^（n-1）-1）。                                                                                        </p><h1 id="数据库技术基础类"><a href="#数据库技术基础类" class="headerlink" title="数据库技术基础类"></a>数据库技术基础类</h1><h2 id="数据挖掘基础知识"><a href="#数据挖掘基础知识" class="headerlink" title="数据挖掘基础知识"></a>数据挖掘基础知识</h2><h3 id="2015-16"><a href="#2015-16" class="headerlink" title="2015"></a>2015</h3><p>可以说，数据挖掘是深层次的数据分析。从功能上可以将数据挖掘的分析方法划分为四种，即关联分析、序列模式分析、分析类分析和聚类分析。在时间应用的DM系统中，这四种方法有着不同的使用范围，因此经常被综合运用。</p><ul><li><p><strong>关联分析</strong>（Association）</p><p>目的是挖掘出隐藏在数据间的相互关系。</p></li><li><p><strong>序列模式分析</strong>（Sequential Patterns）</p><p>目的也是挖掘出隐藏在数据间的相互关系，它的侧重点在于分析数据间的前后关系（因果关系）。在进行序列模式分析时也因计算置信度和支持度。</p></li><li><p><strong>分类分析</strong>（Classifiers）</p><p>和搜寻爱你为每一个记录赋予一个标记（一组具有不同特征的类别），即按标记分类记录，然后检查这些标记的记录，描述出这些记录的特性。</p></li><li><p><strong>聚类分析</strong>（Clustering）</p><p>聚类分析法是分类分析法的逆过程，它的输入集是一组未标记的记录，即输入的记录没有任何处理。目的是根据一定的规则，合理地划分记录集合，并用显式或隐式的方法描述不同的类别。</p></li></ul><h2 id="数据库模型的基础知识"><a href="#数据库模型的基础知识" class="headerlink" title="数据库模型的基础知识"></a>数据库模型的基础知识</h2><h3 id="2015-17"><a href="#2015-17" class="headerlink" title="2015"></a>2015</h3><p>概念模型是信息的描述方式，逻辑模型是数据的逻辑结构，数据模型是指数据的物理组织方式。逻辑模型（E-R图）中的联系描述的是实体间的关联关系，主要是现实世界的事件，包括参与者和事件自身的属性。在关系模型中，取参与联系的实体的码（唯一代表具体的参与者）和事件自身的属性，构成记录即关系的形式来描述。</p><p>索引是为了提高查询效率而引入的机制。</p><p>基于历史数据预测新数据所属的类型，类型已知，这就是一个典型的分类问题。</p><p>贝叶斯信念网络是一个分类算法，Apriori是一个关联规则挖掘算法，K-means和EM都是聚类算法。</p><p>K-means和DBSCAN是两个经典的聚类算法，将相似的数据对象归类一组，不相似的数据对象分开。K-means算法基于对象之间的聚类进行聚类，需要传入聚类的个数。DBSCAN算法基于密度进行聚类，需要确定阈值，两者的聚类结构均与输入参数关系很大。DBSCAN可以处理不同大小形状的簇，而K-means算法则不适用。若数据分布密度变化大，则这两种算法都不适用。</p><h2 id="扩展E-R图的基础知识"><a href="#扩展E-R图的基础知识" class="headerlink" title="扩展E-R图的基础知识"></a>扩展E-R图的基础知识</h2><h3 id="2015-18"><a href="#2015-18" class="headerlink" title="2015"></a>2015</h3><p>派生属性是指可以由其他属性来获取的属性。</p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="数据库的基础知识"><a href="#数据库的基础知识" class="headerlink" title="数据库的基础知识"></a>数据库的基础知识</h2><h3 id="2015-19"><a href="#2015-19" class="headerlink" title="2015"></a>2015</h3><p><strong>数据字典</strong>（Data Dictionary，DD）是各类数据藐视的集合，它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典包括数据项、数据结构、数据流、数据存储和处理过程5个过程。其中“数据项”通常包括数据项名，数据项含义说明、别名、数据类型、长度、取值范围、取之含义、与其他数据项的逻辑关系。</p><h2 id="数据库应用系统的基础知识"><a href="#数据库应用系统的基础知识" class="headerlink" title="数据库应用系统的基础知识"></a>数据库应用系统的基础知识</h2><h3 id="2015-20"><a href="#2015-20" class="headerlink" title="2015"></a>2015</h3><p>数据库的运行维护是由专门的数据库管理系统软件（DBMS）来负责的。C/S结构又称两层结构，由客户端运行应用程序；B/S结构分为三层，客户端只需要浏览器显示的简单的页面处理，Web服务器上的应用程序负责业务处理并与数据库交互。</p><h1 id="事务管理类"><a href="#事务管理类" class="headerlink" title="事务管理类"></a>事务管理类</h1><h2 id="数据库事务处理方面的基础知识"><a href="#数据库事务处理方面的基础知识" class="headerlink" title="数据库事务处理方面的基础知识"></a>数据库事务处理方面的基础知识</h2><h3 id="2015-21"><a href="#2015-21" class="headerlink" title="2015"></a>2015</h3><p>并发事务如果不加以控制，会破坏事务的隔离性和一致性。控制的手段就是加锁，在事务执行时限制其他事务堆数据的读取。在并发控制中引入两种锁：排他锁（Exclusive Locks，简称X锁）和共享锁（Share Locks，简称S锁）。</p><ul><li><p><strong>排他锁</strong></p><p>又称为写锁，用于对数据进行写操作时进行锁定。如果事务T对数据A加上X锁后，就只允许事务T读取和修改数据A，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。</p></li><li><p><strong>共享锁</strong></p><p>又称为读锁，用于对数据进行数据读操作时进行锁定。如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改，其他事务可以再对数据A加S锁来读取，只要数据上有S锁，其他事务只能再对其加S锁读取而不能加X锁修改。</p></li></ul><h2 id="事务程序的基础知识"><a href="#事务程序的基础知识" class="headerlink" title="事务程序的基础知识"></a>事务程序的基础知识</h2><h3 id="2015-22"><a href="#2015-22" class="headerlink" title="2015"></a>2015</h3><p>事务的结束语句是ROLLBACK和COMMIT，当事务执行中出错时，使用ROLLBACK对的当前事务对数据库已做的更新进行撤销；事务所有指令执行完成后，用COMMIT语句对数据库所做的更改提交。COMMITWORK 和 ROLLBACK WORK 中的WORK可省略。</p><h2 id="事务调度知识"><a href="#事务调度知识" class="headerlink" title="事务调度知识"></a>事务调度知识</h2><h3 id="2015-23"><a href="#2015-23" class="headerlink" title="2015"></a>2015</h3><p>事务的执行由DBMS进行调度，在执行事务的过程中加入相关锁指令一控制事务满足ACID属性。常用的方式是两段锁协议（2PL）。即事务的加锁和解锁分为两个阶段，第一节阶段为锁增长阶段，只能加锁不能解锁，第二阶段为锁的减少阶段，只能解锁不能加锁。</p><p>死锁的解除由DBMS来完成。需要在造成死锁的多个事务中选择一个回滚代价最小的事务进行强制回滚，并将该事务置于事务队列稍后执行。</p><h2 id="数据库恢复的基础知识"><a href="#数据库恢复的基础知识" class="headerlink" title="数据库恢复的基础知识"></a>数据库恢复的基础知识</h2><h3 id="2015-24"><a href="#2015-24" class="headerlink" title="2015"></a>2015</h3><p>数据库故障会造成数据不一致。数据库的更新是由事务驱动的，事务的ACID属性被破坏的数据不一致的根本原因。系统重启会使内存中更新过的数据未写入硬盘而丢失，破坏了事务的持久性，即事务一经提交，其对数据库的运影响会体现在数据库中。</p><p>为了保证事务发生故障后可恢复，DBMS使用日志。即在对数据更新前，现将欲做的修改在日志中记录并写入硬盘，然后再进行数据更新。当系统重启时，根据日志文件对数据进行恢复。</p><h1 id="数据库主流应用技术类"><a href="#数据库主流应用技术类" class="headerlink" title="数据库主流应用技术类"></a>数据库主流应用技术类</h1><h2 id="面向对象数据库的基础知识"><a href="#面向对象数据库的基础知识" class="headerlink" title="面向对象数据库的基础知识"></a>面向对象数据库的基础知识</h2><h3 id="2015-25"><a href="#2015-25" class="headerlink" title="2015"></a>2015</h3><p>面向对象数据库中的数据模型充分利用了面向对象的核心概念。一个对象通常对应实际领域的一个实体，有唯一的标识，即对象标识OID。但是对用户而言，OID不可以修改。</p><h1 id="非关系型数据库类"><a href="#非关系型数据库类" class="headerlink" title="非关系型数据库类"></a>非关系型数据库类</h1><h2 id="NoSQL的相关知识"><a href="#NoSQL的相关知识" class="headerlink" title="NoSQL的相关知识"></a>NoSQL的相关知识</h2><h3 id="2015-26"><a href="#2015-26" class="headerlink" title="2015"></a>2015</h3><p>NoSQL是指非关系型数据库，是不同于传统的关系型数据库DBMS的统称。有几种典型的NoSQL数据库：</p><ul><li><p><strong>文档存储数据库</strong></p><p>是指一文档为存储信息的基本单位，如BaseX、CouchDB、MongoDB等。</p></li><li><p><strong>键值存储数据库</strong></p><p>支持简单的键值存储和提取，具有极高的并发读写能力，如Dynamo、Memcached、Redis等。</p></li><li><p><strong>图形存储数据库</strong></p><p>利用计算机将点、线、面等图形基本元素按照一定的数据结构进行存储，如FlockDB、Neo4j等。</p></li></ul><p>多值数据库系统是一种分布式数据库系统，提供了一个通用的数据集成与访问平台，屏蔽了各种数据库系统不同的访问方式和用户界面，给用户呈现出一个访问多种数据库的公共接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（六）数据库技术基础</title>
    <link href="http://yoursite.com/2021/04/08/%E6%95%B0%E5%B7%A5%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/04/08/%E6%95%B0%E5%B7%A5%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-08T09:42:03.000Z</published>
    <updated>2021-04-08T12:24:45.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h2><p>数据库系统（DataBase System，DBS）是一种采用了数据库技术，有组织地、动态地存储大量相关联数据方便多用户访问的计算机系统，。广义上讲是由数据库、硬件、软件和人员组成的。</p><ul><li><p>数据库（DataBase，DB）</p><p>数据库是统一管理的、长期存储在计算机的、有组织的相关数据的集合。</p><p>其特点是数据间联系紧密、冗余度小、独立性强、易扩展，并且可为各类用户共享。</p></li><li><p>硬件（hardware）</p><p>硬件是构成计算机系统的各种物理设备，包括存储数据所需的外设。硬件的配置应满足整个数据库系统的需要。</p></li><li><p>软件（software）</p><p>软件包括操作系统、数据管理系统及应用程序。数据库管理系统（DataBase Management System，DBMS）是数据系统的核心软件，是由一组相关联的数据的集合和一组用以访问这些数据的软件组成。</p><p>功能：数据定义功能、数据操纵功能、数据库的运行管理和数据的建立与维护。</p></li><li><p>人员</p><ul><li>第一类：系统分析员和数据库设计人员</li><li>第二类：应用程序员</li><li>第三类：最终客户</li><li>第四类：数据库管理员（DataBase Administrator，DBA）</li></ul></li></ul><h2 id="DBMS的功能和特点"><a href="#DBMS的功能和特点" class="headerlink" title="DBMS的功能和特点"></a>DBMS的功能和特点</h2><p>DBMS主要是实现对共享数据有效地组织、管理与存取。</p><h3 id="DBMS功能"><a href="#DBMS功能" class="headerlink" title="DBMS功能"></a>DBMS功能</h3><ul><li><p>数据定义</p><p>DBMS提供数据定义语言（Data Definition Language，DDL），用户可以对数据库的结构描述，包括外模式、模式和内模式定义；数据库的完整性定义；安全保密定义等。</p></li><li><p>数据库操作</p><p>DBMS向用户提供数据操作语言（Data Manipulation Language，DML），实现对数据库中数据的基本操作，如检索、插入、修改和删除。</p><p>DML分为两类：宿主型和自含型：</p><ul><li>宿主型：将DML语句嵌入某种主语言（如C、Java、COBOL等）中使用</li><li>自含型：可以单独使用DML语句，供用户交互使用</li></ul></li><li><p>数据库运行管理</p><p>数据库在运行期间多用户环境下的并发控制、安全性检查和存取控制、完整性检查和执行、运行日志的组织管理、事物管理和自动恢复等是DBMS的重要组成部分。</p></li><li><p>数据组织、存储和管理</p><p>DBMS分类组织、存储和管理各种数据，需要实现数据间的联系、数据组织和存储，基本目标是提高存储空间的利用率。</p></li><li><p>数据库的建立与维护</p><p>数据库的建立和维护包括数据库的初始建立、数据转换、数据库的转储和恢复、数据库的重组和重构、性能监测和分析等。</p></li><li><p>其他功能</p><p>如DBMS与网络中其他软件系统的通行功能，一个DBMS与另一个DBMS或文件系统的数据转换功能等。</p></li></ul><h3 id="DBMS特点"><a href="#DBMS特点" class="headerlink" title="DBMS特点"></a>DBMS特点</h3><ul><li><p>数据库结构化且统一管理</p><p>数据库中的数据由DBMS统一管理。由于数据库系统采用复杂的数据模型表示数据结构，数据模型不仅描述数据本身的特点，还描述数据之间的联系。</p><p>数据不在面向某个应用，而是面向整个系统。</p><p>数据易维护、易扩展，数据荣誉明显减少，真正实现了数据的共享。</p></li><li><p>有较高的数据独立性</p><p>数据独立性是指数据与程序独立，将收据的定义操你个程序中分离出去，由DBMS负责数据的存储，应用程序关心的是数据逻辑结构，无须了解数据在磁盘上的数据库汇总的存储形式，从而简化应用程序，大大减少了应用程序编制的工作量。</p><p>数据的独立性包括啊物理独立性和数据的逻辑独立性</p></li><li><p>数据控制功能</p><p>DBMS提供了数据控制功能，以适应共享数据的环境。</p><p>数据的控制功能如下：</p><ul><li><p>数据的安全性（security）</p><p>是指保护数据库以防止不合法的使用造成数据泄漏、更改和破坏。</p></li><li><p>数据完整性（integrality）</p><p>指数据库正确性和相容性，是防止合法用户使用数据库时向数据库加入不符合语义的数据。</p><p>保证数据库中数据是正确的，避免非法的更新。</p></li><li><p>并发控制（concurrency control）</p><p>指在多用户共享的系统中，许多用户可能同时对同一数据进行操作。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据</p></li><li><p>故障恢复（recovery from failure）</p><p>数据库中的4类故障是事务内部故障、系统故障、介质故障及计算机病毒。</p><p>恢复的原理：建立冗余（redundancy）数据。</p><p>冗余是物理级的，通常认为逻辑级是没有冗余的。</p></li></ul></li></ul><h3 id="DBMS特点-1"><a href="#DBMS特点-1" class="headerlink" title="DBMS特点"></a>DBMS特点</h3><ul><li><p>关系数据库系统（Relation DataBase Systems，RDBS）</p><p>关系数据库系统时间里在关系数据模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据。</p><p>目前主流的关系数据库由Oracle、Db2、Sybase、Microsoft SQL Server、Microsoft Access、MySQL等。</p><p>在关系模型中，实体以及实体间的联系都是用关系表示的。</p><p>在一个给定的现实世界领域汇总，相应的所有实体及实体之间联系的关系的集合构成以关系数据库，有型和值之分。</p><ul><li><p>关系数据库的型也称为关系数据库模式，它是对关系数据库的描述，是关系模式的集合。</p></li><li><p>关系数据库的值也称为关系数据库，是关系的集合</p></li><li><p>关系数据库模式与关系数据库通常统称为关系数据库。</p></li></ul></li><li><p>面向对象的数据库系统（Object-Oriented DataBase System，OODBS）</p><p>面向对象的数据库系统是支持以对象形式对数据建模的数据库管理系统，包括对对象的类、类属性的继承和子类的支持。</p><p>面向对象数据库系统主要有两个特点：</p><ul><li>面向对象数据模型能完整的描述现实世界的数据结构，能表达数据间的嵌套、递归联系。</li><li>具有面向对象技术的封装性和继承性，提高了软件的可重用性。</li></ul></li><li><p>对象关系数据库系统（Object-Oriented Relation DataBase System，ORDBS）</p><p>在传统的关系数据模型基础上提供元祖、数组、集合等更为丰富的数据类型以及处理新的数据类型操作的能力，这样形成的数据模型被称为“对象关系数据模型”，基于对象关系数据模型的DBS称为对象关系数据库系统</p></li></ul><h2 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h2><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>系统开发人员需要通过试图层、逻辑层和物理层三个层次上的抽象来对用户屏蔽系统的复杂性，简化用户与系统的交互。</p><ul><li><p>视图层（view level）</p><p>最该层次的抽象，描述整个系统的某个部分。</p><p>优点：是用户与系统交互简化，而且还可以保证数据的保密性和安全性</p></li><li><p>逻辑层（logical level）</p><p>势必物理层更高一层的抽象，描述数据库中储存什么数据以及这些数据间存在的什么关系。</p><p>逻辑结构层通过相对简单的结构描述了真个数据库。</p></li><li><p>物理层（physical level）</p><p>是最低层次的抽象，描述数据在存储器是如何存储的。物理层详细地描述复杂的底层结构。</p></li></ul><p>数据库系统设计院可在视图层、逻辑层和物理层对数据抽象，通过外模式、概念模式和内模式来描述不同层次上的数据特性。</p><h3 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h3><p>采用“三级模式和两级映像”</p><p>数据库采用三级模式结构，这是数据库管理系统内部的系统结构。数据库有“型”和“值”的概念。</p><p>“型”是指对某一数据的结构和属性的说明</p><p>“值”是型的一个具体赋值</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><p>概念模式</p><p>概念模式也称模式，是数据库中全部数据的逻辑结构和特征的描述。它由若干个概念记录类型组成，只涉及型的描述，不涉及具体的值。</p><p>概念模式的一个具体值称为模式的一个实例，用一个模式可以有很多实例。</p><p>概念模式反映的是数据库的结构及其联系，所以是相对稳定的；而实例反映的是数据库某一时刻的状态，所以是相对改变的。</p><blockquote><p>需要说明的是：</p><p>概念模式不仅描述概念记录类型，还要描述记录间的联系、操作、数据的完整性和安全性等要求。但是概念模式不涉及存储结构、访问技术等细节。只有这样，概念模型才算做到了“物理数据独立性”</p></blockquote><p>描述概念模式的数据定义语言称为“模式DDL（Schema Data Definition Language）”</p></li><li><p>外模式</p><p>外模式也称用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述。它由若干个外部记录类型组成。用户使用数据库操纵语言对数据库进行操作，实际上是对外模式的外部记录进行操作。</p><p>描述外模式的数据定义语言称为“外模式DDL”。</p></li><li><p>内模式</p><p>内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据内部的表示方式。定义所有的呢句记录类型、索引和文件的组织方式，以及数据控制方面的细节。</p><blockquote><p>需要说明的是：</p><p>内部记录并不涉及物理记录，也不涉及设备的约束。比内模式更接近于物理存储和访问的那些软件机制是操作系统的一部分（及文件系统）。例如磁盘上读、写数据。</p></blockquote><p>描述内模式的数据定义语言称为“内模式DDL”。</p></li></ul><p>总之，数据按外模式的描述提供给用户，按内模式的描述存储在磁盘上，儿概念模式提供了链接这两级模式的相对稳定的中间观点，并使两级的任意一级的改变都不受另一级的牵制。</p><h3 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h3><p>数据库系统在三级模式之间提供了两级映像：模式/内模式映像、外模式/模式映像。</p><p>正因为这两级映像保证了数据库中数据具有较高的逻辑独立性和物理独立性。</p><ul><li><p>模式/内模式映像</p><p>存在于概念级和内部级之间，实现了概念模式到内模式之间的相互转换</p></li><li><p>外模式/模式映像</p><p>存在于外部级和概念级之间，实现了外模式到概念模式之间的相互转换</p></li></ul><h3 id="数据的独立性"><a href="#数据的独立性" class="headerlink" title="数据的独立性"></a>数据的独立性</h3><p>数据的独立性是指数据与程序独立，将数据的定义从程序中分离出去，由DBMS负责数据的存储，从而化简应用程序，大大减少了应用程序编制的工作量。数据的独立性是由DBMS的二级映像功能来保证的。</p><p>数据的独立性包括数据的物理独立性和数据的逻辑独立性。</p><ul><li><p>数据的物理独立性</p><p>是指当数据库的内模式发生改变时，数据的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是为了保证应用程序能正常执行，需要修改概念模式/内模式之间的映像。</p></li><li><p>数据的逻辑独立性</p><p>是指用户的应用程序与数据库的逻辑结构是独立的，数据的逻辑结构发生变化后，用户程序也可以不修改。但是为了保证应用程序能正常执行，需要修改外模式/概念模式之间的映像。</p></li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="数据模型的基本概念"><a href="#数据模型的基本概念" class="headerlink" title="数据模型的基本概念"></a>数据模型的基本概念</h2><p>模型就是对现实世界特征的模拟和抽象。最常用的数据模型分为概念数据模和基本数据模型。</p><ul><li><p>概念数据模型</p><p>概念数据模型称为信息模型，是按用户的观点对数和信息建模，是实现现实世界到信息世界的第一层抽象，强调其语义表达功能，用户用户理解，是用户和数据库设计人员的交流的语言，主要用于数据库设计。</p><p>这类模型中最著名的是实体联系模型，简称E-R模型。</p></li><li><p>基本数据模型</p><p>基本数据模型黑暗计算机系统的观点对数据建模，是现实世界数据特征的抽象用于DBMS的实现。</p><p>不同于数据模型具有不同的数据结构新形式，目前最常用的数据结构模型有层次模型、网状模型、关系模型和面向对象数据模型。其中，层次模型和网状模型统称为非关系模型。</p><p>关系数据库系统是采用关系模型作为数据组织方式。</p></li></ul><h2 id="数据模型的三要素"><a href="#数据模型的三要素" class="headerlink" title="数据模型的三要素"></a>数据模型的三要素</h2><p>数据模型结构的基础是数据模型，是用来描述数据的一组概念和定义。</p><p>数据模型的三要素是数据结构、数据操作和数据的约束条件。</p><ul><li><p>数据结构</p><p>是所研究的对象类型的集合，是对系统静态特性的描述。</p></li><li><p>数据操作</p><p>对数据库中各种对象（型）和实例（值）允许执行的操作的集合，包括操作及操作规则。如操作有检索、插入、删除和修改，操作规则有优先级别等。数据操作是对系统动态特性的描述，</p></li><li><p>数据的约束条件</p><p>是一组完整性规则的集合。</p></li></ul><h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>概念模型是对信息世界建模，所以概念模型能够方便、准确地表示信息世界中的常用概念。</p><h3 id="E-R方法"><a href="#E-R方法" class="headerlink" title="E-R方法"></a>E-R方法</h3><p>概念模式汇总最常用的方法为实体-联系方法，简称E-R方法。</p><p>在E-R图中，实体集合作为主码（或主键）的一部分属性下面加下划线标明。另外在实体集与联系的线段上标注联系的类型。</p><p>实体集有时简称实体，联系集有时简称联系。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>在E-R模型中实体用矩形表示，通常矩形框内写明实体名。实体是现实世界中可以区别于其他对象的“事件”或“物体”。实体集是具有相同属性的实体集合。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>在E-R模型中，联系用棱形表示。通常可在棱形框内写明联系名，总用无向边分别于有关实体连接起来，同时在无向边旁标注上联系的类型（1:1、1： <em>）或（****</em>：*****）。实体的联系分为实体内部的联系和实体于实体之间的联系。实体内部的联系反映数据在同一记录内部各字段间的联系。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是实体某方面的特性。</p><p>E-R模型中的属性有如下分类：</p><ul><li><p>简单属性和复合属性</p><p>简单属性是原子的、不可再分的，复合属性可细化分为更小的部分（即划分为别的属性）。有时希望用户访问整个属性，有时希望访问属性的某个成分，那么在模型设计时可采用复合属性。若不特别声明，通常指的是简单属性。</p></li><li><p>单值属性和多值属性</p><p>一个属性对应单一的值或对应一组值。</p></li><li><p>NULL属性</p><p>当属性在某个属性上没有值或属性值未知时，使用NULL值。表示无意义或不知道。</p></li><li><p>派生属性</p><p>派生属性可以型其他属性得来。</p><p>可以由其他属性进行计算来获得的属性。</p></li></ul><h3 id="扩展的E-R模型"><a href="#扩展的E-R模型" class="headerlink" title="扩展的E-R模型"></a>扩展的E-R模型</h3><p>扩充的E-R模型，包括弱实体、特殊化、概括和聚集等概念。</p><ul><li><p>弱实体</p><p>一个实体的存在必须以另一个为前提。其联系属于依赖联系。</p></li><li><p>特殊化</p><p>一个实体集可以按照某种特征区分为几个子实体。</p></li></ul><h2 id="基本的数据模型"><a href="#基本的数据模型" class="headerlink" title="基本的数据模型"></a>基本的数据模型</h2><h3 id="层次模型（Hierarchical-Model）"><a href="#层次模型（Hierarchical-Model）" class="headerlink" title="层次模型（Hierarchical Model）"></a>层次模型（Hierarchical Model）</h3><p>层次模型采用树形结构表示数据与数据间的联系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（二）程序设计语言</title>
    <link href="http://yoursite.com/2021/04/07/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/04/07/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</id>
    <published>2021-04-07T03:48:37.000Z</published>
    <updated>2021-04-08T09:43:10.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h1><h2 id="低级程序语言"><a href="#低级程序语言" class="headerlink" title="低级程序语言"></a>低级程序语言</h2><p>用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。</p><p>是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。</p><p>机器语言具有灵活、直接执行、速度快等特点。</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>为了克服机器语言难读、难遍、难记和易出错的缺点，用于代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码。</p><p>汇编语言是一种使用助记符表示的仍然面向机器的计算机语言，也称为符号语言。</p><p>汇编程序：</p><p>​    输入：是用汇编语言书写的源程序。</p><p>​    输出：是用机器语言表示的目标程序。</p><h2 id="程序语言的分类"><a href="#程序语言的分类" class="headerlink" title="程序语言的分类"></a>程序语言的分类</h2><p>根据设计程序的方法将语言大致分为命令式和结构化的程序设计语言、面向对象的程序设计语言、函数式程序设计语言和逻辑程序设计语言。</p><ul><li><p>命令式程序设计语言</p><p>命令式语言是基于动作的语言，在这种语言中，计算被看成是动作的序列。</p><p>通常所称的结构化程序设计语言属于命令式语言类，其结构特性主要反映在以下几个方面：</p><ul><li>用自顶向下逐步精化的方法编程</li><li>按模块组织的方法编程</li><li>程序只包含顺序、判定（分支）及循环构造（每种构造只允许单入口和单出口）</li></ul><p>特点：结构化的程序结构简单清晰、模块划强，描述方式接近人们的习惯的推理式思维方式，因此可读性强。在软件重用性、软件维护等方面都有所进步，在大型软件开发中曾发挥过重要的作用。</p><p>举例：C语言、Pascal</p></li><li><p>面向对象的程序设计语言</p><p>面对对象的程序设计在很大程度上应归功于从模拟领域发展起来的Simula，其提出了对象和类的概念。</p><p>特点：它们都必须支持新的程序设计技术，如数据隐藏、数据抽象、用户定义类型、继承和多态等。</p><p>举例：C++、Java、Smalltalk</p></li><li><p>函数式程序设计语言</p><p>函数式语言是一种类似。演算为基础的语言，其基本概念来自于LISP。函数是一种对应规则（映射），它使定义域中每个元素的值域中唯一的元素对应。</p><p>优点：对于表达式汇总出现的任何函数都可以用其他函数代替，只要这些函数调用产生相同的值。</p><p>举例：HasKell、Scala、Scheme、APL</p></li></ul><h2 id="编译-解释程序"><a href="#编译-解释程序" class="headerlink" title="编译/解释程序"></a>编译/解释程序</h2><p>解释程序也称为解释器，它或者直接解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行。</p><p>编译程序（编译器）则是将源程序翻译成目标语言程序，然后在计算机上运行目标程序。</p><ul><li><p>根本区别：</p><ul><li><p>在编译方式下</p><p>机器上运行的与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程。</p></li><li><p>在解释方式下</p><p>解释程序和源程序（或某种等价表示）要参与到程序的运行过程中，运行程序的控制权在解释程序。</p></li></ul></li></ul><div class="note warning flat"><p>简单来说，在解释方式下，翻译程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p></div><h3 id="编译与解释方式的比较"><a href="#编译与解释方式的比较" class="headerlink" title="编译与解释方式的比较"></a>编译与解释方式的比较</h3><p>对于高级语言的编译和解释工作方式，可以从如下几个方面比较：</p><ul><li><p>效率</p><p>编译比解释方式可能取得更高的效率</p></li><li><p>灵活性</p><p>由于解释程序需要反复检查源程序，这也使得解释方式能够比编译方式更灵活。</p><p>另外，当解释器直接在源程序上工作时，它可以多错误进行更精准的定位</p></li><li><p>可移植性</p><p>解释器一般也是用某个程序设计语言编写的，因此只要对解释器进行重新编译，就可以使解释器运行在不同的环境中。</p></li></ul><h2 id="编译程序基本原理"><a href="#编译程序基本原理" class="headerlink" title="编译程序基本原理"></a>编译程序基本原理</h2><h3 id="编译过程概述"><a href="#编译过程概述" class="headerlink" title="编译过程概述"></a>编译过程概述</h3><p>编译程序的作用是把某种高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机器语言形式）。编译程序的工作一般可以分为6个阶段。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析阶段是编译过程的第一个阶段，这个阶段的任务是对源程序从前到后（从左到右）逐个字符的扫描，从中识别出一个个“单词”符号。“单词”符号是程序设计语言的基本语法单元，如关键字（或称保留字）、标识符、常数、运算符和分隔符（如标点符号、左右括号）等，词法分析程序输出的“单词”以二元祖的方式输出，及单词类别和单词自身的值。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析的任务是在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单元，如“表达式”“语句”“程序”的等。</p><p>通过语法分析确定整个输入串是否构成一个语法上正确的程序。</p><p>如果程序中没有语法错误，语法分析后就能正确的构造出其语法树。</p><p>否则就指出语法错误，并给出相应的诊断信息。</p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>语义分析阶段分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。</p><p>语义分析的一个主要工作是进行类型分析和检查。</p><p>程序语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。</p><h4 id="中间代码生成阶段"><a href="#中间代码生成阶段" class="headerlink" title="中间代码生成阶段"></a>中间代码生成阶段</h4><p>中间代码生成阶段的工作是根据语义分析的暑促好生成中间代码。</p><p>“中间代码”是一种简单且含义明确的记号系统，可以有若干种形式，它们的共同特征是与具体的机器无关。</p><p>最长用的一种中间代码是与汇编语言的指令非常相似的三地址码，其实现方式常采用四元式。</p><p>语义分析和中间代码生成所依据的是语言的语义规则。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>由于生成中间代码的工作是机械的、按固定模式进行的，因此，生成的中间代码往往在时间和空间方面的效率较差。当需要生成高效的目标代码，就必须进行优化。优化过程可以在中间代码生成阶段进行，也可以在目标代码生成阶段进行。</p><p>由于中间代码不依赖于具体机器，此时所做的优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关。优化所依据的原则是程序的等价变换规则。</p><h4 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h4><p>目标代码生成是编译器工作的最后一个阶段。任务是把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关。</p><h4 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h4><p>符号表的作用是记录源程序中各符号的必要信息，以辅助语义的正确性检查和代码生成。在编译过程中需要对符号表进行快速有效的查找、插入、修改和删除等操作。</p><p>符号表的建立可始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码的运行阶段。</p><h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>源程序的错误大致分为静态错误和动态错误。</p><p>动态错误也称动态语义错误，它们发生在程序运行时。</p><p>静态错误是指编译阶段发现的程序错误，可以分为语法错误和静态语义错误。</p><div class="note warning flat"><p>在编译器的各个阶段，在逻辑上，可以把它们划分为前段和后端两部分。</p><p>前段包括从词法分析到中间代码生成各阶段的工作，后端包括中间代码优化的目标代码生成及优化等阶段。</p><p>因此，以中间代码为分水岭，把编译器分成了与机器有关的部分和无关的部分。</p></div><h2 id="中缀表达式与后缀表达式"><a href="#中缀表达式与后缀表达式" class="headerlink" title="中缀表达式与后缀表达式"></a>中缀表达式与后缀表达式</h2><h2 id="程序语言的基本成分"><a href="#程序语言的基本成分" class="headerlink" title="程序语言的基本成分"></a>程序语言的基本成分</h2><p>程序语言的基本成分包括数据、运算、控制、传输。</p><h3 id="程序设计的数据成分"><a href="#程序设计的数据成分" class="headerlink" title="程序设计的数据成分"></a>程序设计的数据成分</h3><p>程序语言的数据成分指其程序中的数据对象。</p><p>数据是程序操作的对象，具有存储类别、类型、名称、作用域和生存周期等属性，使用时要为它分配内存空间。</p><p>数据名称由用户通过标识符命名，在一些语言中，标识符是由字母、数字和下划线组成的标记；类型说明数据占用内存的大小和存放形式；存储类型说明数据在内存中的位置和生存期；作用域则说明可以使用数据的代码范围；生存期说明数据占用内存的时间范围。</p><p>从不同角度俄将数据进行不同的划分。</p><ul><li><p>常量和变量</p><p>按照成语运行时数据的值能否改变，将程序中的水分为常量和变量。</p><p>程序中的数据对象可以具有左值和（或）右值，左值值存储单元（或地址、容器），右值是值（或内容）。</p><p>变量具有左值和右值，在程序运行过程中其右值可以改变；常量只有右值，在程序运行过程中其右值不能改变。</p></li><li><p>全局变量和局部变量</p><p>按数据的作用域范围，可将其分为全局变量和局部变量。</p><p>系统为全局变量分配的存储空间在程序运行的过程中一般是不改变的，而为局部变量的存储单元是可以动态改变的。</p></li><li><p>数据类型</p><p>按照数据组织形式不同将数据分为基本类型、用户定义类型、构造类型和其他类型。</p><p>以C/C++为例，其数据类型如下：</p><ul><li>基本类型：整形（int）、字符型（char）、实型（float、double）和布尔类型（bool）</li><li>特殊类型：空类型（void）</li><li>用户定义类型：枚举类型（enum）</li><li>构造类型：数组、结构、组合</li><li>指针类型：type*</li><li>抽象数据类型：类类型</li></ul></li></ul><h3 id="程序语言的运算成分"><a href="#程序语言的运算成分" class="headerlink" title="程序语言的运算成分"></a>程序语言的运算成分</h3><p>程序语言的运算成分指明允许使用的运算符号及运算规则。</p><p>大多数高级程序语言的基本云元可以分为算数运算、关系运算、逻辑运算等，有些语言如C/C++还提供位运算。</p><h3 id="程序语言的控制成分"><a href="#程序语言的控制成分" class="headerlink" title="程序语言的控制成分"></a>程序语言的控制成分</h3><p>控制成分指明语言允许表述的控制结构。可以用顺序、选择和循环这三种控制结构来描述。</p><ul><li><p>顺序结构</p><p>用来表示一个计算操作序列。计算过程从多描述的第一个操作开始，按顺序依次执行后续的操作，知道学咧的最后一个操作。</p></li><li><p>选择结构</p><p>提供两个或多种分支中选择其中一个的逻辑。</p><p>基本的选择结构是指指定一条件P，然后根据条件的成立与否决定控制流走计算A还是计算B，从这两个分支选择一个执行。选择结构的计算还可以包含顺序、选择和重复循环。</p></li><li><p>循环结构</p><p>循环结构描述了重复计算的过程，通常由三部分组成：初始化、循环体和循环条件。其中初始化部分有时不进行显示的表现。</p><p>循环结构主要有两种形式：while型循环结构和do-while型循环结构。</p></li></ul><h4 id="C-C-语言中的控制语句"><a href="#C-C-语言中的控制语句" class="headerlink" title="C/C++语言中的控制语句"></a>C/C++语言中的控制语句</h4><ul><li><p>复合语句</p><p>用于描述顺序结构，其作用是昂多条语句组成一个可执行单元。</p><p>复合语句是一个整体，要么全部执行，要么一条语句也不执行。</p></li><li><p>if语句和swith语句</p><ul><li><p>if语句实现的是双分支的选择结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（表达式）语句<span class="number">1</span>；<span class="keyword">else</span> 语句<span class="number">2</span>；</span><br></pre></td></tr></table></figure><p>使用if语句时，需要注意if和else的匹配关系。C/C++语言规定，else总是域距离他最近的尚没有else的if相匹配。</p></li><li><p>swith语句描述了多分支的选择结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swith（表达式）&#123;</span><br><span class="line">case 常量表达式1:语句1;</span><br><span class="line">case 常量表达式2:语句2;</span><br><span class="line">...</span><br><span class="line">case 常量表达式n:语句n;</span><br><span class="line">default:语句n+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行swith语句时，首先计算表达式的值。</p><p>常量表达式通常为字符型或整形。多个常量表达式可以共用一个语句组。</p></li></ul></li><li><p>循环语句</p><ul><li><p>while语句。</p><p>while语句描述了先判断条件再执行循环体的控制结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while（条件表达式）循环体语句;</span><br></pre></td></tr></table></figure><p>执行while语句时，先计算条件表达式的值，当值为非0时，就执行循环体语句，然后重新计算条件表达式的值后再进行判断，否则就结束while语句的执行过程。</p></li><li><p>do-while语句</p><p>do-while语句描述了先制性循环体再判断条件的控制结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">循环体语句;</span><br><span class="line">while（条件表达式）;</span><br></pre></td></tr></table></figure><p>先执行循环体语句，然后再久安表达式的值，若值为非0，则再一次的执行循环体语句。</p></li><li><p>for语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for（表达式1;表达式2;表达式3）循环体语句;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>程序语言的传输成分指明语句允许的数据传输方式，如赋值操作、数据输入/输出等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>函数定义</p><p>函数的定义包括两部分：函数首部和函数体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值的类型 函数名（形式参数表）</span><br><span class="line">&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首部说明了函数返回值的数据类型、函数的名字和函数运行时所需的参数及类型。</p><p>C/C++程序中多有函数的定义都是独立的，不允许函数的嵌套定义。</p></li><li><p>函数声明</p><p>对于函数，先声明后引用。函数原型用于声明函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名（参数类型表）</span><br></pre></td></tr></table></figure><p>使用函数原型的目的是告诉编译器传递给函数的参数个数、类型以及函数返回值的类型。</p></li><li><p>函数调用</p><p>当在一个函数（称为主函数）汇总需要使用另一个函数（称为被调用函数）实现的功能时，便以名字进行调用，称为函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名（参数表）;</span><br></pre></td></tr></table></figure><p>在C程序的执行过程中，通过函数调用实现函数定义时描述的功能。函数体中若调用自己，则称为递归调用。</p><p>函数调用时实参于形参间交换信息的方式有值调用和引用调用两种。</p><ul><li><p>值调用</p><p>若实现函数调用时实参向形式参数传递相应类型的值，则称为是传值调用，这种方式下形参不能向实参传递信息。</p></li><li><p>引用调用</p><p>引用是C++中增加的数据类型，当形参为引用类型时，形参名实际上是实参的别名，函数中形参的访问和修改实际上就是针对相应实际参数所做的访问和改变。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>数工（一）计算机系统知识</title>
    <link href="http://yoursite.com/2021/04/06/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2021/04/06/%E6%95%B0%E5%B7%A5%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-04-06T06:13:16.000Z</published>
    <updated>2021-04-08T09:42:53.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CPU的相关组件"><a href="#CPU的相关组件" class="headerlink" title="CPU的相关组件"></a>CPU的相关组件</h1><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><ul><li><p>算数逻辑单元（ALU）</p><p><span style ='color: #FF0000;'>功能：负责处理数据，实现对数据的算数运算可逻辑运算。</span></p></li><li><p>累加寄存器（AC）</p><p>AC通常简称为累加器，它是一个通用寄存器</p><p><span style ='color: #FF0000;'>功能：当运算器的算数逻辑单元执行运算或逻辑运算时，为ALU提供一个工作区。</span></p></li><li><p>数据缓冲寄存器（DR）</p><p><span style ='color: #FF0000;'>作用：为CPU的内存、外部设备之间数据传输的中转站以及它们在操作速度上的缓冲；</span>在单累加器的运算器中，数据缓冲寄存器还可兼作操作数寄存器</p></li><li><p>状态条件寄存器（PSW）</p><p><span style ='color: #FF0000;'>功能：PSW保存根据算数指令和逻辑指令运行或测试的结果建立的各种条件码内容。</span></p><p>主要分为状态标志、控制标志</p><ul><li>运算结果进位标志（C）</li><li>运算结果溢出标志（V）</li><li>运算结果为0标志（Z）</li><li>运算结果为负标志（N）</li><li>中断标志（I）</li></ul></li><li><p>方向标志（D）</p><ul><li>单步标志</li></ul><p>注：一个算数结果产生一个运算结果，而一个逻辑产生一个判决。</p></li></ul><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>控制器一般包含指令控制逻辑、时序控制逻辑、总线控制逻辑、中断控制逻辑等。</p><ul><li><p>时序控制逻辑</p><p>为每条指令按时间顺序提供应有的控制信号</p></li><li><p>总线控制逻辑</p><p>为多个功能部件服务的信息脱落通路的控制电路</p></li><li><p>中断控制逻辑</p><p>用于控制各种中断请求，并根据优先级对中断请求进行排序，逐个交给CPU处理</p></li></ul><p>指令控制逻辑要完成取指令、分析指令和执行指令的操作，其过程可分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等操作。</p><p>控制器在工作过程中主要使用如下几个部件：</p><ul><li><p>指令寄存器（IR）</p><p>一般用来保存当前正在执行的一条指令。</p></li><li><p>程序计数器（PC）</p><p>PC具有寄存信息和计数两种功能，又称为指令计数器。</p><p><span style ='color: #FF0000;'>是用于存放下一条指令所在单元的地址的地方。</span> 在程序执行前，必需将程序的起始地址，即程序的一条指令所在单元地址送入程序计数器，当执行指令时，CPU将自动修改程序计数器的内容，即每执行一条指令程序计数器增加一个量，使其指向下一个待指向的指令。程序的转移等操作也是通过该寄存器实现的。</p></li><li><p>地址寄存器（AR）</p><p><span style ='color: #FF0000;'>一般AC保存当前CPU所访问的内存单元的地址，以方便内存的读写操作。</span> </p></li><li><p>指令译码器（ID）</p><p>指令包含操作码和地址码两部分。ID就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。</p></li></ul><h2 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h2><p>略</p><p>&nbsp;</p><h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><p>所谓总线（Bus），是指计算机设备和设备传输信息的公共数据通道。</p><p>重要特征：总线上的所有设备共享</p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><ul><li><p>数据总线（Data Bus，DB）</p><p>用来传输数据，是双向的。</p><p>DB的带宽决定了CPU和计算机其他设备之间每次交换数据的位数。</p></li><li><p>地址总线（Address Bus，AB）</p><p>用于传输CPU发出的地址信息，是单向的。</p><p>地址总线的宽度决定了CPU的最大寻址能力。</p></li><li><p>控制总线（Control Bus，CB）</p><p>用来传送控制信号、时序信号和状态信息等。</p><p>CB中的每一条线的信息传输方向是单向且确定的，但CB作为一个整体是双向的。</p></li></ul><p>与芯片相连接的总线可分为前段总线（FSB）、存储总线、I/O总线、扩展总线等。</p><p>对于目前的计算机结构来说，控制芯片集成在主板上，典型的有南北桥结构和单芯片结构。</p><ul><li><p>南北桥芯片结构</p><p>北桥芯片直接与CPU、内存、显卡、南桥相连，控制CPU的类型、主板的总线频率、内存控制器、显示核心等。前段总线（FSB）是将CPU连接到北桥芯片的总线。内存总线是将内存连接到北桥芯片的总线，用于和北桥之间的通讯。显卡通过I/O总线连接到北桥芯片。</p><p>南桥芯片主要负责外部设备与内部CPU的联系。其中，通过I/O总线将外部I/O设备连接到南桥。扩展总线则是指主板上提供的一些PCI、ISA等插槽。</p></li><li><p>单芯片结构</p><p>单芯片组方式取消了北桥。由于CPU中内置了内存控制器，不再需要北桥来控制，减少了延迟。还有一些CPU集成了显示单元，使得显示芯片的频率更高，延迟更低。</p></li></ul><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><ul><li><p>总线的带宽</p><p>即单位时间内总线上可传输的信息量，单位是MB/s。</p></li><li><p>总线的位宽</p><p>即总线能同时传输的数据位数，有32位、64位等。</p></li><li><p>总线的工作频率</p><p>即总线的时钟频率，它是协调总线上各种操作的时钟频率。</p></li></ul><p>&nbsp;</p><h1 id="输入输出控制"><a href="#输入输出控制" class="headerlink" title="输入输出控制"></a>输入输出控制</h1><h2 id="I-O设备概述"><a href="#I-O设备概述" class="headerlink" title="I/O设备概述"></a>I/O设备概述</h2><p>I/O设备可分为块设备和字符设备两类。</p><p>块设备把信息存放在固定大小的块中，每个块都有自己的地址，独立于其他块，可寻址。</p><p>字符设备以字符为单位接收或发送一个字符流，字符设备不可以寻址。</p><h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><p>程序控制I/O是指外设数据的输入/输出过程是在CPU执行程序的控制下完成的。这种方式分为无条件传送和程序查询方式两种情况。</p><ul><li><p>无条件传送</p><p>此情况下，外设总是准备好的，它可以无条件地随时接收CPU发来的输出数据，也能够无条件地随时向CPU提供需要输入的数据</p></li><li><p>程序查询方式</p><p>通过COU执行程序来查询外设的状态，判断外设是否准备好接受数据或准备好了向CPU输入数据。CPU有针对性地外设的输入/输出服务。</p><p>缺点：1.降低了CPU的效率；2.对外部的突发事件无法做出及时响应。</p></li></ul><h2 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h2><p>利用中断方式完成数据的输入/输出过程为：当系统与外设交换数据时，CPU无须等待也不必起查询I/O设备的状态，而是处理其他事物。与程序控制方式相比，中断方式因为CPU无须等待而提高了效率。</p><p>在系统具有多个中断源的情况下，常用的处理方法如下：</p><ul><li><p>多中断信号线法</p><p>每个中断源都有属于自己的一根中断请求信号线向CPU提出中断请求</p></li><li><p>中断软件查询法</p><p>当CPU检测到一个中断请求信号后，即转入到中断服务程序去轮询每个中断源以确定是谁发出了请求。（设备的响应优先级又软件设定）</p></li><li><p>菊花链法</p><p>实际上是一种硬件查询法。所有的I/O模块共享一根共同的中断请求线，而中断确认信号则以链式在各模块间相连。当CPU检测到中断请求信号时，发出中断确认信号。中断确认信号依次在I/O模块间传递，直到发出请求的模块，该模块则把它的ID送往数据线由CPU读取。</p></li><li><p>总线仲裁法</p><p>设备发出中断请求前必须先获得总线控制权，所以可由总线仲裁机制来裁定谁可以发出中断请求信号。当CPU发出中断响应信号后，该模块则把它的ID送往数据线由CPU读取。</p></li><li><p>中断向量表法</p><p>中断向量用来保存各个中断源的中断服务程序的入口地址。当外设发出中断请求信号（INTR）后，由中断控制器（INTC）确定其中断号，并根据中断号查询中断向量表来取得其中断服务程序的入口地址，同时INTC吧中断请求信号提交给CPU。</p></li></ul><h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p>直接内存存取（Direct Memory Access，DMA）是指数据在内存与I/O设备间直接成块传送，不需要CPU的干涉，只需要CPU在过程开始启动与过程结束时的处理，实际操作由DMA硬件直接执行完成。（CPU放弃总线控制权）</p><p>在DMA传送数据时要占用系统总线，根据占用总线的方法不同，DMA可以分为中央处理器停止法、总线周期分时法、总线周期挪用法。（DMA传送数据时，CPU不能使用总线）</p><h2 id="输入-输出器（IOP）"><a href="#输入-输出器（IOP）" class="headerlink" title="输入/输出器（IOP）"></a>输入/输出器（IOP）</h2><p>DMA方式的出险减少了CPU对I/O操作的控制。使得CPU的效率显著提高，而通道的出现则进一步提高了CPU的效率。</p><p>通道又称输入输出处理器（Input Output Process，IOP）它分担了CPU的一部分功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传输。</p><p>通道方式提高了CPU的工作效率，但其实是以增加更多的硬件为代价的。</p><p>外围处理器（Peripheral Processor Unit，PPU）方式是通道方式的进一步发展，PPU的专用处理机，它根据I/O命令，完成对外设数据的输入输出。（用于分布式多机系统）</p><p>&nbsp;</p><h1 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h1><p>指令集体系结构（Instruction Set Arcitecture，ISA）是指一个处理器支持的指令和指令的字节级编码。</p><h2 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h2><p>复杂指令集计算机（Complex Instruction Set Computer，CISC）的基本思想是进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大而复杂。（例如：微处理器X86的体系结构）</p><ul><li>CISC的主要弊病如下：<ul><li>指令集过分庞大</li><li>微程序技术是CISC的重要支柱，每条负责指令都要执行一段解释性微程序才能完成，这就需要多个CPU周期，从而降低了机器的处理速度</li><li>由于指令系统过分庞大，使高级语言编译程序选择目标指令的范围很大，并使编译程序本省冗长而复杂，从而难以优化编译使之生成真正高效的目标代码</li><li>CISC强调完善的中断控制，势必导致动作繁多，设计复杂，研制周期长</li><li>CISC给芯片设计带来很多困难，是芯片种类增多，出错率增大，成本提高而成品率降低</li></ul></li></ul><h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p>精简指令集计算机（Reduced Instruction Set Computer，RISC）的基本思想是通过减少指令总数的简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译，提高指令的执行速度，采用硬线控制逻辑。优化编译程序，导致机器的和指令系统进一步精炼而简单。（例如：ARM处理器）</p><p>RISC的关键技术如下：</p><ul><li><p>重叠寄存器窗口技术</p><p>其基本思想是在处理机中设置一个数量较大的寄存器堆，并把它们划分为多个窗口。</p></li><li><p>优化编译技术</p><p>RISC使用了大量的寄存器，如何合理分配寄存器、提高寄存器的使用效率及减少访问次数等，都应通过编辑技术的优化来实现</p></li><li><p>超流水线及超标量技术</p><p>其是为了进一步提高流水线速度而采用的技术</p></li><li><p>硬布线逻辑与微程序向结合在微程序技术中</p></li></ul><p>&nbsp;</p><h1 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h1><p>流水线技术是将一个较复杂的处理过程分为m各复杂程度相当、处理时间大致相等的子过程，每个子过程由一个独立的功能部件完成。处理对象在各个子过程连成的线路上连续流动，同一时间，m个部件同时进行不同的操作，完成对不同对象的处理。</p><p>流水处理技术是在重叠、先行控制方式的基础上发展起来的。</p><h2 id="指令控制方式"><a href="#指令控制方式" class="headerlink" title="指令控制方式"></a>指令控制方式</h2><ul><li><p>顺序方式</p><p>指各计算器指令之间顺序串行地执行。</p><p>优点：控制简单</p><p>缺点：速度慢、各部件的利用率低。</p></li><li><p>重叠方式</p><p>是指在解释第K条指令的操作完成之前，即开始解释第K+1条指令。</p><p>优点：速度有所提升，控制也不算太复杂</p><p>缺点：会出现冲突、转移和相关的问题，在设计时必须想办法解决</p></li><li><p>流水方式</p><p>流水（pipe lining）技术是把并行性或并发性嵌入计算机系统的一种形式，它把重复的顺序处理过程分解为若干个子过程，每个子过程能在专用的独立模块上有效的并发工作。</p></li></ul><div class="note warning flat"><p>在概念上，“流水”可以看成是“重叠”的延伸，差别仅在于“一次重叠”只是把一条指令解析分解为两个子过程，而“流水”则是分解为更多的子过程。</p></div><h2 id="流水线的种类"><a href="#流水线的种类" class="headerlink" title="流水线的种类"></a>流水线的种类</h2><ul><li>级别角度：部件级、处理机级、系统级</li><li>功能角度：单功能流水线、多功能流水线</li><li>联接角度：静态流水线、动态流水线</li><li>反馈回路：线性流水线、非线性流水线</li><li>流动顺序：同步流水线、异步流水线</li><li>数据表示：标量流水线、向量流水线</li></ul><h2 id="流水线的相关处理"><a href="#流水线的相关处理" class="headerlink" title="流水线的相关处理"></a>流水线的相关处理</h2><p>RISC采用的流水线技术有三种：超流水线、超标量、超长指令字。</p><ul><li><p>超流水线技术</p><p>超流水线（super pipeline）技术是RISC采用的一种并行处理技术。它通过细化流水、增加级数和提高主频，使得在每个机器周期内完成一个甚至两个浮点操作。其实质是以时间换取空间。</p></li><li><p>超标量技术</p><p>超标量（super scalar）技术是RISC采用的有一种并行处理技术，它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却又更小的CCPI。其实质是以空间换区时间。</p></li><li><p>超长指令字技术</p><p>超长指令字（Very Long Instruction World，VLIW）技术由LIW发展而来。VLIW和超标量都是20世纪80年代出现的概念，其共同点是要同时执行多条指令，其不同于超标量依靠硬件来实现并行处理的调度，VLIW则充分发挥软件的作用，而使硬件简化，性能提高。VLIW有更小的CPI值，但需要有足够的时钟频率。</p></li></ul><h2 id="吞吐率和流水建立的时间"><a href="#吞吐率和流水建立的时间" class="headerlink" title="吞吐率和流水建立的时间"></a>吞吐率和流水建立的时间</h2><p>吞吐率是指单位时间里流水线处理机流出的结果数。对指令而言，就是单位时间里执行的指令数。</p><p>如果流水线的子过程所用的子过程所用时间一样，则吞吐率P应为最长子过程所用时间的倒数。</p><p>流水线开始工作，需经过一段时间才能达到最大吞吐率，这就是建立时间。若m个子过程所用的时间一样，均为t，则建立时间T=mt。</p><p>&nbsp;</p><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><h2 id="计算机可靠性概述"><a href="#计算机可靠性概述" class="headerlink" title="计算机可靠性概述"></a>计算机可靠性概述</h2><p>元件的可靠性分为三个阶段：开始阶段器件工作处于不稳定期，失效率较高；第二阶段器件进入正常工作期，失效率最低，基本保持常数；第三阶段元器件开始老化，失效率有重新增高。这就是所谓的“浴盆曲线”。</p><p>计算机系统的可靠性是指从它开始运行（t=0）到某时刻t这段时间内正常运行的概率，用R(t)表示。所谓失效率是指单位时间内失效元件数与元件总数的比例，用  表示，当。为常数时，可靠性与失效率的关系为：R(t)=e</p><p>两次故障之间系统能正常工作时间的平均值称为平均无故障时间（MTBF），即：</p><p>通常平均修复时间（MTRF）来表示计算机的可维修性，即计算机的维修效率，指从故障发生到机器修复平均所需要的时间。计算机的可用性是指计算机的使用效率，它与系统在执行任务的任意时刻能正常工作的概率A来表示，即：</p><p>计算机的RAS就是指可靠性R、可用性A和可维修性S三个指标衡量一个计算机系统。</p><h2 id="计算机可靠性模型"><a href="#计算机可靠性模型" class="headerlink" title="计算机可靠性模型"></a>计算机可靠性模型</h2><h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a>串联系统</h3><p>假设一个系统由N个子系统组成，当且仅当所有的子系统都能正常运行，系统才能正常工作，这样的系统称为串联系统。</p><h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a>并联系统</h3><p>假设一个系统由N个子系统组成，只要有一个子系统正常工作，系统就能正常工作，这样的系统称为并联系统。</p><h3 id="N模冗余系统"><a href="#N模冗余系统" class="headerlink" title="N模冗余系统"></a>N模冗余系统</h3><p>N模荣誉系统由N个（N=2n+1）相同的子系统和一个表决器组成，表决器把N个子系统汇总占多数相同结果的输出作为系统的输出。</p><div class="note warning flat"><p>提高计算机的可靠性一般采用如下两项措施：</p><ol><li>提高元器件质量，改进加工工艺与工艺结构，完善电路设计。</li><li>发展容错技术，使得在计算机硬件有故障的情况下，计算机仍能继续运行，得出正确的结果。</li></ol></div><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><ul><li><p>立即寻址</p><p>是一种特殊的寻址方式，指令中在操作码字段后面的部分不是通常意义上的操作数地址，而是操作数本身，也就是说数据就包含在指令汇总，只要取出指令，也就取出了可以立即使用的操作数。</p></li><li><p>直接寻址</p><p>在直接寻址中指令中地址码字段给出的地址A就是操作数的有效地址，即形式地址等于有效地址。</p></li><li><p>间接寻址</p><p>间接寻址意味着指令中给出的地址A不是操作数的地址，而是存放操作数的主存单元的地址，简称操作数地址的地址。</p></li><li><p>寄存器寻址</p><p>寄存器寻址指令的地址码部分给出了某一个通用寄存器的编号Ri，这个指定的寄存器汇总存放着操作数。</p></li><li><p>寄存器间接寻址</p><p>在寄存器间接寻址方式中，寄存器内存放的是操作数的地址，而不是操作数本身，即操作数是通过寄存器间接寻址得到的。</p></li><li><p>变址寻址</p><p>变址寻址就是把变址寄存器Rx的内容与指令中给出的形式地址A相加，形式地址数有效地址，即EA=（Rx）+A。</p></li><li><p>基址寻址</p><p>基址寻址睡昂基址寄存器Rb的内容与指令汇总给出的位移向量D相加，形成操作数有效地址，即EA=（Rb）+D。</p></li><li><p>相对寻址</p><p>相对寻址好似基址寻址的一种变通，有程序计数器提供基准地址，指令汇总的地址码字段作为位移量D，两者相加后的到操作数的有效地址，即EA=（PC）+D。</p></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="-数工" scheme="http://yoursite.com/tags/%E6%95%B0%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十九）Dom4j</title>
    <link href="http://yoursite.com/2021/03/22/JAVA%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89Dom4j/"/>
    <id>http://yoursite.com/2021/03/22/JAVA%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89Dom4j/</id>
    <published>2021-03-22T03:46:50.000Z</published>
    <updated>2021-03-29T03:20:42.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOM4J介绍"><a href="#DOM4J介绍" class="headerlink" title="DOM4J介绍"></a>DOM4J介绍</h1><p>DOM4J是dom4j.org出品的一个开源的XML解析包。DOM4J应用于Java平台，采用lJava集合框架并完全支持DOM、SAX和JAXP。</p><p>DOM4J使用非常简单。只要了解基本的XML-DOM模型，就能使用。</p><p>Dom：把一个文档作为一个对象。</p><p>DOM4J最大的特点是使用大量的接口，他的主要接口都在org.dom4j里面定义。</p><table><thead><tr><th>接口名</th><th>定义</th></tr></thead><tbody><tr><td>Atribute</td><td>定义了XML的属性</td></tr><tr><td>Branch</td><td>指能够包含字节点的节点。如XML元素（Element）和文档（Document）定义了一个公共的行为</td></tr><tr><td>CDDATA</td><td>定义了XML CDATA区域</td></tr><tr><td>CharacterData</td><td>是一个标识接口，标识基于字符的节点。如CDATA、Comment、Text</td></tr><tr><td>Comment</td><td>定义了XML注释的行为</td></tr><tr><td>Document</td><td>定义了XML文档</td></tr><tr><td>DocumentType</td><td>定义了XML DOCTYPE声明</td></tr><tr><td>Element</td><td>定义了XML元素</td></tr><tr><td>ElementHandler</td><td>定义了Element对象的处理器</td></tr><tr><td>ElementPath</td><td>被ElementHandler使用，用于取得当前正在处理的路径层次信息</td></tr><tr><td>Entity</td><td>定义了XML Entity实例</td></tr><tr><td>Node</td><td>为dom4j中所有的XML节点定义了多态行为</td></tr><tr><td>NodeFilter</td><td>定义了在dom4j节点产生的一个滤镜或谓语的行为（predicate）</td></tr><tr><td>ProcessingInstruction</td><td>定义了XML处理指令</td></tr><tr><td>Text</td><td>定义； XML文本节点</td></tr><tr><td>Visitor</td><td>用于实现Visitor</td></tr><tr><td>XPath</td><td>在分析一个字符串后提供了一个XPath表达式</td></tr></tbody></table><p>各接口的继承关系如下：</p><ul><li>interface java.lang.Cloneable<ul><li>interface org.dom4j.**Node<ul><li> interface org.dom4j.Attribute</li><li>interface org.dom4j.Branch<ul><li>interface org.dom4j.Document</li><li> interface org.dom4j.Element</li></ul></li><li>interface org.dom4j.CharacterData<ul><li>interface org.dom4j.CDATA</li><li> interface org.dom4j.Comment</li><li>interface org.dom4j.Text</li></ul></li><li>interface org.dom4j.DocumentType</li><li>interface org.dom4j.Entity</li><li>interface org.dom4j.ProcessingInstruction</li></ul></li></ul></li></ul><h1 id="XML-文档操作"><a href="#XML-文档操作" class="headerlink" title="XML 文档操作"></a>XML 文档操作</h1><h2 id="读取XML文档"><a href="#读取XML文档" class="headerlink" title="读取XML文档"></a>读取XML文档</h2><p>读写MXL额外拿的那个主要依赖于<code>org.dom4j.io</code>包，有<code>DOMReader</code>和<code>SAXReader</code>两种方式。因为利用了相同的接口，他们的调用方式是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">load</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">  Document doc = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    doc = reader.read(<span class="keyword">new</span> File(filename));</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">load</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">  Document doc = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    doc = reader.read(url));</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取指定的XML文件之后返回一个Document对象，这个对象代表了整个XML文档，用于各种Dom操作。执照XML文件头所定义的编码来转换。</p><h2 id="获取根结点"><a href="#获取根结点" class="headerlink" title="获取根结点"></a>获取根结点</h2><p>根结点是XML分析的开始，任何XML分析工作哦度需要从 根开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"><span class="comment">//获取根节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的简称：&quot;</span>);</span><br><span class="line">String Jname = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的id：&quot;</span>);</span><br><span class="line">String id = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入添加书的name：&quot;</span>);</span><br><span class="line">String name = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将xml文件转为Doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在根结点上添加新的book节点</span></span><br><span class="line">Element newbook = element.addElement(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">newbook.addAttribute(<span class="string">&quot;name&quot;</span>, Jname);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在book节点中添加数据</span></span><br><span class="line">Element newid = newbook.addElement(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">newid.setText(id);</span><br><span class="line"></span><br><span class="line">Element newname = newbook.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">newname.setText(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of =OutputFormat.createCompactFormat();</span><br><span class="line">of.setEncoding(<span class="string">&quot;uft-8&quot;</span>);</span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>)));</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要删除的节点：&quot;</span>);</span><br><span class="line">String findname = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件转为Doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根结点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">Element element1 = (Element) iterator.next();</span><br><span class="line"><span class="keyword">if</span>(findname.equals(element1.attributeValue(<span class="string">&quot;name&quot;</span>))) &#123;</span><br><span class="line">Element ele = element1;</span><br><span class="line">ele.getParent().remove(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of = OutputFormat.createPrettyPrint();</span><br><span class="line">of.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;filename&quot;</span>),of);</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改节点"><a href="#更改节点" class="headerlink" title="更改节点"></a>更改节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要修改书的简称：&quot;</span>);</span><br><span class="line">String findname = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件转为doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根结点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取字节节点</span></span><br><span class="line">Element element1 = (Element)iterator.next();</span><br><span class="line"><span class="keyword">if</span>(findname.equals(element1.attributeValue(<span class="string">&quot;name&quot;</span>))) &#123;</span><br><span class="line"><span class="comment">//定义新的节点</span></span><br><span class="line">Element ele = element1;</span><br><span class="line"><span class="comment">//创建用于存放数据的list集合</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">List&lt;Element&gt; list = ele.elements();</span><br><span class="line"><span class="keyword">if</span>(list!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;1.编号2.书名&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>+list.get(<span class="number">1</span>));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查无此书&quot;</span>+findname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查到相应书籍</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入需要修改的序号&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入新的id：&quot;</span>);</span><br><span class="line">list.get(<span class="number">0</span>).setText(sc.next());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入新的name：&quot;</span>);</span><br><span class="line">list.get(<span class="number">1</span>).setText(sc.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputFormat of = OutputFormat.createPrettyPrint();</span><br><span class="line">of.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">XMLWriter writer;</span><br><span class="line">writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">writer.write(doc);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//定义list集合用来存储数据</span></span><br><span class="line">ArrayList&lt;Book&gt; bookslist = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将XML文件封装为doc对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>));<span class="comment">//此处将抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取doc对象的字节点</span></span><br><span class="line">Element element = doc.getRootElement();</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;?&gt; iterator = element.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取字节点</span></span><br><span class="line">Element element1 = (Element)iterator.next();</span><br><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">Iterator&lt;?&gt; iterator1 = element1.elementIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Element element2 = (Element)iterator1.next();</span><br><span class="line"><span class="comment">//获取字节点的相关信息</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;id&quot;</span>.equals(element2.getName())) &#123;</span><br><span class="line"><span class="comment">//get.Text():获取相关数据,此处需要转型</span></span><br><span class="line">book.setId(Integer.parseInt(element2.getText()));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(element2.getName())) &#123;</span><br><span class="line">book.setName(element2.getText());</span><br><span class="line">&#125;</span><br><span class="line">&#125;bookslist.add(book);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Book book : bookslist) &#123;</span><br><span class="line">System.out.println(book.getId()+<span class="string">&quot;&quot;</span>+book.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Document对象相关"><a href="#Document对象相关" class="headerlink" title="Document对象相关"></a>Document对象相关</h2><ul><li><p>读取XML文件，获取Document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = <span class="keyword">new</span> reader.read(<span class="keyword">new</span> File(<span class="string">&quot;filename&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>解析XML形式的文本，得到document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;&lt;members&gt;&lt;/members&gt;&quot;</span></span><br><span class="line">Document doc =DocumentHelper.praseText(text);</span><br></pre></td></tr></table></figure></li><li><p>主动创建document对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document doc = DocumentHelper.createDocument();</span><br><span class="line">Element root = document.addElement(<span class="string">&quot;members&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="节点相关"><a href="#节点相关" class="headerlink" title="节点相关"></a>节点相关</h2><ul><li><p>获取文档的根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rootele = document.gerRootElement();</span><br></pre></td></tr></table></figure></li><li><p>获得某节点的单个子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element memberele = root.element(<span class="string">&quot;member&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得节点的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String text = memberele.getText();</span><br><span class="line"><span class="comment">//取得根结点下的name节点的文字</span></span><br><span class="line">String text = root.elementText(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得某节点下指定名称的所有节点并进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List nodes = rootele.elements(<span class="string">&quot;member&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Iterator it = nodes.iterator(); it.hasNext();)&#123;</span><br><span class="line">  Element ele = (Element)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对某节点下的所有子节点进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = root.elementIterator(); it.hasNext();)&#123;</span><br><span class="line">  Element elemetn = (Element) it.next();</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>某节点下添加子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element ageele = newMemberEle.addElement(<span class="string">&quot;age&quot;</span>;)</span><br></pre></td></tr></table></figure></li><li><p>设置节点文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ageele.setText(<span class="string">&quot;12&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除某节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentele.remove(childele);<span class="comment">//parentele是父节点，childele是呆删的子节点</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个CDATA节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element contentele = infoele.addElement(<span class="string">&quot;contect&quot;</span>);</span><br><span class="line">contectele.addCDARA(diary.gerContect());</span><br></pre></td></tr></table></figure></li></ul><h2 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h2><ul><li><p>取得节点的指定的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element root = document.getRootElement();</span><br><span class="line">Attribute attribute = root.attribute(<span class="string">&quot;size&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取得属性的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String text = attribute.getText();</span><br><span class="line"><span class="comment">//获取根结点下name子节点的firstname属性的值</span></span><br><span class="line">String text2 = root.element(<span class="string">&quot;name&quot;</span>).attributeValue(<span class="string">&quot;firstname&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>遍历某节点的所有属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Element root = document.getRootElement();</span><br><span class="line"><span class="keyword">for</span>(Iterator it = root.attributeIterator(); it.hasNext();)&#123;</span><br><span class="line">  Attribute attribute = (Attribute) it.next();</span><br><span class="line">  String text = attribute.getText();</span><br><span class="line">  System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置某节点的属性和文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newMemberElm.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sitinspring&quot;</span>);   </span><br></pre></td></tr></table></figure></li><li><p>设置属性的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;name&quot;</span>);      </span><br><span class="line">attribute.setText(<span class="string">&quot;sitinspring&quot;</span>);      </span><br></pre></td></tr></table></figure></li><li><p>删除某属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;size&quot;</span>);<span class="comment">// 属性名name      </span></span><br><span class="line">root.remove(attribute);   </span><br></pre></td></tr></table></figure></li></ul><h2 id="将文档写入XML文件"><a href="#将文档写入XML文件" class="headerlink" title="将文档写入XML文件"></a>将文档写入XML文件</h2><ul><li><p>文档中全为英文,不设置编码,直接写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.xml&quot;</span>));      </span><br><span class="line">writer.write(document);      </span><br><span class="line">writer.close();  </span><br></pre></td></tr></table></figure></li><li><p>文档中含有中文,设置编码格式再写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">format.setEncoding(<span class="string">&quot;GBK&quot;</span>);    <span class="comment">// 指定XML编码</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.xml&quot;</span>),format);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串与XML的转换"><a href="#字符串与XML的转换" class="headerlink" title="字符串与XML的转换"></a>字符串与XML的转换</h2><ul><li><p>字符串与XML的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;&lt;members&gt; &lt;member&gt;sitinspring&lt;/member&gt; &lt;/members&gt;&quot;</span>;      </span><br><span class="line">Document document = DocumentHelper.parseText(text);   </span><br></pre></td></tr></table></figure></li><li><p>将文档或节点的XML转化为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;input.xml&quot;</span>));</span><br><span class="line">Element root=document.getRootElement();</span><br><span class="line">String docXmlText=document.asXML();</span><br><span class="line">String rootXmlText=root.asXML();</span><br><span class="line">Element memberElm=root.element(<span class="string">&quot;member&quot;</span>);</span><br><span class="line">String memberXmlText=memberElm.asXML();</span><br></pre></td></tr></table></figure><p>&nbsp;</p></li></ul><h1 id="DOM4J的类和接口"><a href="#DOM4J的类和接口" class="headerlink" title="DOM4J的类和接口"></a>DOM4J的类和接口</h1><h2 id="类：SAXReader"><a href="#类：SAXReader" class="headerlink" title="类：SAXReader"></a>类：SAXReader</h2><p>当解析到path指定的路径时，将调用参数handler指定的处理器。正对不同的节点可以添加多个handler实例。或者调用默认的HandlersetDefaultJandler(ElementHandler handler);</p><h2 id="接口：ElementHandler"><a href="#接口：ElementHandler" class="headerlink" title="接口：ElementHandler"></a>接口：ElementHandler</h2><p>该方法在解析到元素的开始、结束标签时被调用。</p><h2 id="接口：ElementPath"><a href="#接口：ElementPath" class="headerlink" title="接口：ElementPath"></a>接口：ElementPath</h2><p>该方法与SAXReader类中的addHandler()方法的作用相同。路径path可以是绝对路径（路径以/开头），也可以是相对路径（假设是当前路径的子节点路径）。</p><p>移除指定路径上的ElementHandler实例。路径可以是相对路径，也可以是绝对路径。</p><p>该方法得到当前节点的路径，该方法返回的是完整的绝对路径。</p><h2 id="Element类"><a href="#Element类" class="headerlink" title="Element类"></a>Element类</h2><table><thead><tr><th>方法名</th><th>定义</th></tr></thead><tbody><tr><td>getText()</td><td>元素所罕有的text内容，如果内容为空则返回一个空字符串而不是null</td></tr><tr><td>attributeValue()</td><td>元素的某个指定属性所含有的值</td></tr><tr><td>elementIterator()</td><td>元素属性的iterator，其中每个元素都是Element</td></tr></tbody></table><h2 id="DocumentHelper类"><a href="#DocumentHelper类" class="headerlink" title="DocumentHelper类"></a>DocumentHelper类</h2><p>DocumentHelper是用来生成XML文档的工厂类</p><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十八）XML</title>
    <link href="http://yoursite.com/2021/02/02/JAVA%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89XML/"/>
    <id>http://yoursite.com/2021/02/02/JAVA%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89XML/</id>
    <published>2021-02-02T02:38:02.000Z</published>
    <updated>2021-03-22T03:45:46.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML——（Extensible Markup Language可扩展标记语言）是一种很流行的简单的基于文本的语言来用作应用程序之间的通信模式。它被认为是传输标准装置和存储数据。Java提供了极好的支持和丰富的库来解析，修改或查询XML文档。</p><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML是一种简单的基于文本的语言，它被设计存储和运输以纯文本的数据。它代表着可扩展标记语言和运输以纯文本格式的数据，它代表着可扩展标记语言。</p><ul><li><p>特点</p><p>XML是一种标记语言</p><p>XML标签不像HTML那样定义</p><p>XML标签被设计成自描述性的</p><p>XML是W3C推荐用于数据存储和传输</p></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>技术无关</p><p>作为普通文本，XML是技术独立。它可用于有其他任何技术进行数据的存储和传输的目的。</p></li><li><p>人类可读</p><p>XML使用简单的文本格式，它是人类可读和可以理解的。</p></li><li><p>允许验证</p><p>使用XSD，DTD和XML结构可以很容易的验证</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>冗余的语法</p><p>通常XML文件中包含大量的重复计算。</p></li><li><p>冗余</p><p>作为一个冗长的语言，XML文件大小增加了传输的存储成本</p></li></ul><h1 id="JAVA-XML解析器"><a href="#JAVA-XML解析器" class="headerlink" title="JAVA XML解析器"></a>JAVA XML解析器</h1><p>解析XML是指将通过XML文档访问数据或修改数据的一个操作或方法。</p><h2 id="DOM方式"><a href="#DOM方式" class="headerlink" title="DOM方式"></a>DOM方式</h2><p>更具XML的层级结构在内存中分配一个树形结构，把XML的标签、属性和文本等元素都封装成数的节点对象</p><ul><li>优点：便于实现增、删、改、查</li><li>缺点：XML文件过大可能造成内存溢出</li></ul><h2 id="SAX方式"><a href="#SAX方式" class="headerlink" title="SAX方式"></a>SAX方式</h2><p>采用事件驱动模型边读边解析，从上到下一行行解析，解析到某一元素，调用相应解析方法</p><ul><li>优点：不会造成内存溢出</li><li>缺点：查询不便，但不能实现增、删、改</li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十七）TCP / UDP 通信协议</title>
    <link href="http://yoursite.com/2021/02/01/JAVA%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89TCP%20:%20UDP%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2021/02/01/JAVA%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89TCP%20:%20UDP%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-02-01T05:10:32.000Z</published>
    <updated>2021-03-20T13:34:08.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><p>TCP协议：传输控制层协议，面向有链接，数据可靠</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。在Internet上的主机一般运行了多个服务软件，同时提供集中服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。</p><p>应用程序通常通过“套接字”向网络发出请求或应答网络请求。Socket和Serversocket类库位于java.net包中。ServerSocket用于服务端，Socket是创建网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。</p><h3 id="获取本地地址和端口号"><a href="#获取本地地址和端口号" class="headerlink" title="获取本地地址和端口号"></a>获取本地地址和端口号</h3><p>java.net.Scoket为套接字类，其提供了很多方法，其中我们可以通过获取socket获取本地的地址以及端口号。</p><ul><li><p>其方法为：</p><p><code>int getLocalPort();</code> 用于获取本地使用的端口号</p><p><code>InetAddress getLocalAddress();</code> 用于获取套接字绑定的本地地址</p><p>使用InetAddress获取本地的地址方法：</p><p><code>String getCanonicalHostName();</code> 获取此IP地址的完全限定名</p><p><code>String getHostAddress();</code> 返回IP地址字符串（以文本表现形式）</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">InetAddress add = socket.getLocalAddress();<span class="comment">//获取本地信息</span></span><br><span class="line">System.out.println(add.getCanonicalHostName());<span class="comment">// 获取此IP地址的完全限定名</span></span><br><span class="line">System.out.println(add.getHostAddress());<span class="comment">//用于获取套接字绑定的本地地址</span></span><br><span class="line">System.out.println(socket.getLocalPort());<span class="comment">//用于获取本地使用的端口号</span></span><br><span class="line">socket.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="获取远程地址和端口号"><a href="#获取远程地址和端口号" class="headerlink" title="获取远程地址和端口号"></a>获取远程地址和端口号</h3><p>Socket也提供了获取远端的地址以及端口号的方法：</p><ul><li><p>其方法为：</p><p><code>int getPort();</code> 用于获取远端使用的端口号</p><p><code>InetAddress getInetAddress();</code> 用于获取套接字绑定的远端地址</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">InetAddress inetadd = socket.getInetAddress();<span class="comment">//获取远端信息</span></span><br><span class="line">System.out.println(inetadd.getCanonicalHostName());<span class="comment">// 获取此IP地址的完全限定名</span></span><br><span class="line">System.out.println(inetadd.getHostAddress());<span class="comment">//用于获取套接字绑定的远端地址</span></span><br><span class="line">System.out.println(socket.getPort());<span class="comment">//用于获取远端使用的端口号</span></span><br><span class="line">socket.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="获取网络输入-输出流"><a href="#获取网络输入-输出流" class="headerlink" title="获取网络输入/输出流"></a>获取网络输入/输出流</h3><p>通过Socket获取输入流与输出流，这两个方法是使用Socket通讯的关键方法。封装了TCP协议的Socket是基于流进行通讯的，所以我们在创建了双方连接后，只需要获取相应的输入与输出流即可实现通讯。</p><ul><li><p>其方法为：</p><p>InputStream getInputStream(); 该方法用于返回此套接字的输入流。</p><p>OutputStream getOutputStream(); 该方法用于返回此套接字的输出流</p></li><li><p>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br><span class="line">   InputStream in = socket.getInputStream();</span><br><span class="line">   OutputStream out = socket.getOutputStream();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="close方法"><a href="#close方法" class="headerlink" title="close方法"></a>close方法</h3><p>当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源。</p><ul><li><p>其方法为：</p><p><code>void close();</code> 关闭Socket以释放资源</p></li></ul><p>当关闭了该套接字后也会同时关闭由此获取的输入流与输出流。</p><p>&nbsp;</p><h1 id="Scoket通讯模块"><a href="#Scoket通讯模块" class="headerlink" title="Scoket通讯模块"></a>Scoket通讯模块</h1><h3 id="Server端ServerSocket监听"><a href="#Server端ServerSocket监听" class="headerlink" title="Server端ServerSocket监听"></a>Server端ServerSocket监听</h3><p>java.net.ServerSocket是运行于服务端应用程序中，通过创建ServerSocket需要指定服务端口号，之后监听Socket的连接。</p><ul><li><p>其方法为：</p><p>Socket accept(); </p></li></ul><p>该方法是一个阻塞方法，直到一个客户端通过Socket连接后，accept会封装一个Socket，该Socket封装的表示该客户端的有关信息，通过这个Socket与客户端进行通信。</p><ul><li><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ServerSocket并申请服务端口8088</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line"><span class="comment">//方法会产生阻塞，知道某个Socket连接，并返回请求连接的Socket</span></span><br><span class="line">Socket socket = server.accept();</span><br></pre></td></tr></table></figure></li></ul><h3 id="Client端的Socket连接"><a href="#Client端的Socket连接" class="headerlink" title="Client端的Socket连接"></a>Client端的Socket连接</h3><p>当服务端ServerSocket调用accept方法阻塞等待客户端连接后，可以通过在客户端应用程序中创建Socket来向服务器发起连接。</p><div class="note warning flat"><p>创建Socket的同时就发起连接，若连接异常会抛出异常，我们通常创建Socket时会传入服务端的地址及服务端口号。</p></div><ul><li>代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:服务端的IP地址，参数2:服务端的服务端口</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8088</span>);</span><br></pre></td></tr></table></figure><h3 id="C-S端通信模块"><a href="#C-S端通信模块" class="headerlink" title="C-S端通信模块"></a>C-S端通信模块</h3><p>C-S的全程为（Client-Server）：客户端-服务器端</p><p>客户端与服务端通信模型如下：</p><ul><li>步骤如下：<ol><li>服务端ServerSocket</li><li>通过调用ServerSocket的accept方法监听客户端的连接</li><li>客户端创建Socket并指定服务端的地址以及端口来建立与服务端的连接</li><li>当服务端accept发现客户端连接后，后去对应该客户端的Socket</li><li>双方通过Socket分别获取对应的输入与输出流进行数据通讯</li><li>通讯结束后关闭连接5</li></ol></li></ul><h3 id="Server端多线程模型"><a href="#Server端多线程模型" class="headerlink" title="Server端多线程模型"></a>Server端多线程模型</h3><p>可以创建一个线程类，并将客户端交互的工作全部委托给线程处理，这样就可以实现当一个客户端连接后，启动一线程来负责与客户端的交互，这样我们就可以实现循环不断的监听其他客户端连接。</p><p>&nbsp;</p><h1 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h1><p>UDP协议：用户数据报协议，面向无连接，数据不可靠</p><h2 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h2><h3 id="创建接受包"><a href="#创建接受包" class="headerlink" title="创建接受包"></a>创建接受包</h3><p>DatagramPacket：UDP数据报给予IP建立，没太主机有65535个端口号可以使用。数据报中字结束限制为65535-8，包含8字节的头信息。</p><ul><li><p>构造接受包：</p><p><code>DatagramPacket(byte[] buf, int length);</code> 将数据报中Length长的数据装进Buf数组。</p><p><code>DatagramPacket(byte[] buf, int offset, int lenth);</code> 将数据报中从Offset开始、Length长的数据装进Buf数组。</p></li></ul><h3 id="创建发送包"><a href="#创建发送包" class="headerlink" title="创建发送包"></a>创建发送包</h3><ul><li><p>构造发送包：</p><p><code>DatagramPacket(byte[] buf, int length, InetAddress clientAddress, int clientPort);</code> 从buf数组中取出Length长的数据创建数据报对象，目标是clientAddress地址、clientPort端口，常用来发送数据给客户端。</p><p><code>DatagramPacket(byte[] buf, int offset, int length, InetAddress clientAddress, int clientPort);</code> 从buf数组中，取出offset开始、Length长的数据创建数据报对象，目标是clientAddress地址、clientPort端口，常用来发送数据给客户端。</p></li></ul><h2 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h2><h3 id="服务端接受"><a href="#服务端接受" class="headerlink" title="服务端接受"></a>服务端接受</h3><p>DatagramSocket用于接受和发送UDP的Socket实例。</p><ul><li>其语法格式为：<code>DatagramSocket(int port);</code></li></ul><p>创建实例，并固定监听Port端口的报文。</p><ul><li><p>其中方法：</p><p><code>receive (DatagramPacket d);</code> 接受数据报文到d中，receive方法产生“阻塞”。会一直等待直到数据被读取到。</p></li></ul><h3 id="客户端发送"><a href="#客户端发送" class="headerlink" title="客户端发送"></a>客户端发送</h3><p>无参的构造方法DaragramSocket()通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的，程序会让操作系统分配一个可用的端口。</p><ul><li><p>其中方法：</p><p><code>send (DatagramPacket dp);</code> 该方法用于发送报文到目的地。</p></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十六）多线程</title>
    <link href="http://yoursite.com/2021/01/31/JAVA%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/31/JAVA%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-01-31T11:55:47.000Z</published>
    <updated>2021-03-29T03:57:54.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>计算机中独立运行的应用程序。</p><p><strong>所谓进程（process）就是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。进程中所包含的一个或多个执行单元为线程（thread）。进程中还拥有一个私有的虚拟地址空间，该空间仅能被所有包含的线程访问。</strong></p><p>线程只能归属于一个进程并且它只能访问该进程所拥有的资源。当操作系统创建一个进程后，该进程会自动申请一个名为主线程或首要线程的进程。操作系统中有若干个线程在“同时”运行。通常，操作系统上运行的每一个应用程序都运行在一个进程中。</p><div class="note warning flat"><p>进程并不是真正意义上的同时运行，而是并发运行。</p></div><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><strong>一个线程是一个进程的顺序执行流。同类的多个线程共享一块内空间和一组系统资源，线程本身有一个供程序执行时的堆栈。</strong>线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。</p><p>线程就是进程中的一个或多个执行流。如果一个进程序列包含多个线程，我们就说这个程序是多个线程的。</p><div class="note warning flat"><p>切换——线程并发时的一种现象。</p></div><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程与线程最大的区别：资源共享。</p><ul><li>其区别主要包括：<ol><li>一个进程至少包含一个线程。线程的规划尺度小于进程，使得多个线程程序的并发性高。</li><li>线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口</li><li>从逻辑上看，多线程的意义在于一个应用程序中，有多个执行部分可以“同时”执行。</li></ol></li></ul><h2 id="并发原理"><a href="#并发原理" class="headerlink" title="并发原理"></a>并发原理</h2><p>多个线程或进程“同时”运行只是人为感官上的理解。</p><p>进程和线程是并发运行的，OS的时间调度机制将时间划分为很多<strong>时间片段</strong>（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有的进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发，但是不是绝对意义上的“同时发生”。</p><p>注：</p><ol><li>之所以这样做是因为CPU只有一个，同一时间只能做一件事情。但随着计算机的发展，出现了多核心CPU。（例如两核心的CPU可以实现真正意义上的两个线程同时运行，但因为CPU的时间片段分配给那个线程或进程是由线程调度决定，所以不一定两个线程是属于同一个进程的，无论如何线程或进程是并发运行的）</li><li>OS：Operating System 操作系统</li><li>线程调度机制是OS提供的一个用于并发处理的程序。Java虚拟机自身也提供了线程调度机制，用于减轻OS切换线程带来的更多负担。</li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>对于程序而言，我们实际上关心的是线程而非进程。</p><ul><li>线程在其生命周期中的各个状态：<ol><li><code>New</code>（新建状态）：当创建一个线程时，该线程并没有纳入线程调度，其处于一个new状态。</li><li><code>Runnable</code>（就绪状态）：当调用线程start方法后，该线程将纳入线程调度的控制，其处于一个可运行状态，等待分配时间片段以并发运行。</li><li><code>Running</code>（运行状态）：当该线程分配到了时间片段后被CPU运行，这时线程处于running状态。</li><li><code>Blocked</code>（阻塞状态）：当线程在运行过程中可能会出现阻塞状态，比如等待用户输入信息等。但阻塞状态不是百分百出现的，具体要看代码中是否有相关需求。</li><li><code>Dead</code>（死亡状态）：当线程的任务全部运行完毕，或在运行过程中抛出一个未捕获的异常，那么线程结束，等待GC回收。</li></ol></li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="使用Thread创建并启动线程"><a href="#使用Thread创建并启动线程" class="headerlink" title="使用Thread创建并启动线程"></a>使用Thread创建并启动线程</h3><p>java.lang.Thread类是线程类，其每一个实例表示一个可以并发运行的线程。我们<strong>通过继承该类并重写run方法来定义一个具体的线程</strong>。其中重写run方法的目的是定义该线程要执行的逻辑。启动线程时调用线程的start()方法而非直接调用run() 方法。start()方法会将当前线程纳入线程调度，适当的线程可以并发运行。当线程获取时间片段后自动开始执行run方法中的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Thread创建线程，需要继承Thread</span></span><br><span class="line">  <span class="comment">//创建和启动线程：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadTest th = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">th.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是线程&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Runnable创建并启动线程"><a href="#使用Runnable创建并启动线程" class="headerlink" title="使用Runnable创建并启动线程"></a>使用Runnable创建并启动线程</h3><p>实现Runnable接口并重写run方法来定义线程体，在创建线程的时候将Runnable的实例传入并启动线程。</p><p>这样做的好处在于可以将线程要执行的任务分离开减少耦合，同时Java单单继承的，定义一个类实现Runnable接口这样的做法可以更好的去实现其他父类或接口，因为接口是多继承关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">RunnableTest rt = <span class="keyword">new</span> RunnableTest();</span><br><span class="line"><span class="comment">//重写了run()方法，而其是Thread的方法</span></span><br><span class="line">Thread th = <span class="keyword">new</span> Thread(rt);</span><br><span class="line">th.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是Runnable！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用内部类创建线程"><a href="#使用内部类创建线程" class="headerlink" title="使用内部类创建线程"></a>使用内部类创建线程</h3><p>通常我们可以通过匿名内部类的方式创建线程，使用该方法可以简化编写代码的复杂度，当一个线程仅需要一个实例时我们通常使用这种方式来创建。</p><ul><li><p>例如：</p><ol><li><p>继承Thread方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">System.out.println(<span class="string">&quot;我是Thread匿名类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承Runnable方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">System.out.println(<span class="string">&quot;我是Runnable匿名类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="Thread-currentThread方法"><a href="#Thread-currentThread方法" class="headerlink" title="Thread.currentThread方法"></a>Thread.currentThread方法</h3><p>Thread的静态方法currentThread方法可以用来获取运行当前代码片段的线程。</p><ul><li><p>其语法格式为：</p><p><code>Thread th  = Thread.currentThread();</code></p></li></ul><h3 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h3><ul><li>Thread提供了获取线程信息的相关方法：<ol><li><code>long getId();</code> 返回该线程的标识符</li><li><code>String getName();</code> 返回该线程的名称</li><li><code>int getPriority();</code> 返回该线程的优先级</li><li><code>Thread.state getState();</code> 获取线程的状态</li><li><code>boolean isAlive();</code> 测试线程是否处于活动状态</li><li><code>boolean isDaemon();</code> 测试线程是否为守护线程</li><li><code>boolean isInterrupted();</code> 测试线程是否已经中断</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentThreadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread th = Thread.currentThread();</span><br><span class="line">System.out.println(<span class="string">&quot;运行main方法&quot;</span>+Thread.currentThread());</span><br><span class="line">System.out.println(th.getId());<span class="comment">//返回该线程的标识符</span></span><br><span class="line">System.out.println(th.getName());<span class="comment">//返回该线程的名称</span></span><br><span class="line">System.out.println(th.getPriority());<span class="comment">//返回该线程的优先级</span></span><br><span class="line">Thread.State state = th.getState();<span class="comment">//获取该线程的状态</span></span><br><span class="line">System.out.println(state);</span><br><span class="line">System.out.println(th.isAlive());<span class="comment">//线程是否处于活动状态</span></span><br><span class="line">System.out.println(th.isDaemon());<span class="comment">//测试线程是否为守护线程</span></span><br><span class="line">System.out.println(th.isInterrupted());<span class="comment">//测试线程是否中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的切换是由线程调度控制的，虽然无法通过代码干涉，但是可以提高线程的优先级来最大程度的改善线程获取时间片的几率。</p><p>线程优先级被划分为10级，值分别为1～10，其中1最低、10最高。</p><ul><li>线程提供了三个常量来表示最低、最高以及默认优先级：<ol><li>Thread.Min_PRIORITY</li><li>Thread.Max_PRIORITY</li><li>Thread.NORM_PRIORITY</li></ol></li><li>设置优先级的方法：<br><code>void setPriority(int priority);</code></li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程（后台线程）与普通线程在表现上没有区别，其特点是当那个线程中只剩下守护线程时，所有守护线程强行终止。</p><ul><li><p>其语法格式为：<code>void setDaemon(boolean b);</code></p><p>当参数为true时该线程为守护线程</p></li></ul><div class="note warning flat"><p>设置线程为后台线程要在该线程启动之前设置。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>Thread的静态方法sleep用于使当前线程进入阻塞状态。</p><ul><li>其语法格式为：<code>static void sleep(long ms);</code></li></ul><p>该方法会使当前线程进入阻塞状态指定毫秒，当指定毫秒阻塞后，当前线程会重新进入Runnable状态，等待分配时间片。</p><p>该方法声明抛出一个InterruptException。所以使用该方法时需要捕获这个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread th = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;守护线程&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();<span class="comment">//在日志中输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;;</span><br><span class="line">th.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">th.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//该方法是一个阻塞方法</span></span><br><span class="line"><span class="comment">//当指定的时间过后，当前线程会重新进入Runnable状态，等待分配时间片</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;main线程结束了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>Thread的静态方法yield方法用于使当前线程主动让出当前CPU时间片回到Runnable状态，等待分配时间片。</p><ul><li>其语法格式为：static void yield();</li></ul><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>Thread的方法join方法用于等待当前进程结束，此方法是一个阻塞方法。</p><ul><li><p>其语法格式为：void join();</p><p>该方法声明抛出InterruptException。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadPhoto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;t1正在下载图片：&quot;</span>+i*<span class="number">10</span>+<span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.getStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;下载完毕&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;等待图片下载完毕&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t1.join();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.getStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;打开图片&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>ArrayList是非线程同步的。<strong>多个线程并发读写同一个临界资源时会发生“线程并发安全问题”。</strong></p><ul><li>常见的临界资源：<ol><li>多线程共享实例变量</li><li>多线程共享静态公共变量</li></ol></li></ul><p>若想解决线程安全问题，需要将异步的操作变为同步操作。</p><ul><li><p>同步与异步</p><p>所谓异步操作是指多线程并发的操作，相当于各干各的</p><p>所谓同步操作是指有先后顺序的操作，相当于你干完我再干</p></li></ul><p>Java中有一个关键字名为synchronized，该关键字是同步锁，用于将某段代码变为同步操作，从而解决线程并发安全问题。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>Java提供了一种内置的锁机制来支持原子性：<strong>同步代码块</strong>（synchronized关键字）</p><p>同步代码块包含两部分：一个作为锁的对象的引用，一个作为由这个锁保护的代码块。</p><ul><li><p>其语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器——锁对象的引用)&#123;</span><br><span class="line">  ...<span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>若方法所有代码都需要同步也可以给方法直接加锁。</p><p>注：每个Java对象都可以用作一个实现同步的锁，线程静如同步代码块之前会自动获得锁，并且在退出同步代码块时释放锁，而且无论是通过正常路径退出锁还是通过抛出异常退出都一样，获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟售票</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dell</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟100张票</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一把锁</span></span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//假设t1抢到时间片，t1进来</span></span><br><span class="line"><span class="comment">//t2又抢到时间片，t2要进来发现又锁则等待</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="keyword">if</span>(tick&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在出售第 &quot;</span>+(tick--)+<span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Dell d = <span class="keyword">new</span> Dell();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择合适的锁对象-范围"><a href="#选择合适的锁对象-范围" class="headerlink" title="选择合适的锁对象/范围"></a>选择合适的锁对象/范围</h3><h4 id="选择合适的锁对象"><a href="#选择合适的锁对象" class="headerlink" title="选择合适的锁对象"></a>选择合适的锁对象</h4><p>使用synchronized需要对一个锁对象上锁保证线程同步。</p><div class="note warning flat"><p>这个锁对象应当注意多个需要同步的线程在访问该同步块时，看到的应该是同一个锁对象的引用，否则达不到同步的效果。通常我们会使用this来作为锁对象。</p></div><h4 id="选择合适的锁范围"><a href="#选择合适的锁范围" class="headerlink" title="选择合适的锁范围"></a>选择合适的锁范围</h4><p>在使用同步块时，应当尽量在允许的情况下减少同步范围，以提高并发的执行效率。</p><h3 id="静态方法锁"><a href="#静态方法锁" class="headerlink" title="静态方法锁"></a>静态方法锁</h3><p>当我们对一个静态方法加锁，如：<code>public synchronized static void XXX()&#123;...&#125;</code></p><p>那么该方法锁的对象时类对象。每个类都有唯一的一个类对象。获取对象的方式：<code>ClassName.class;</code></p><p>静态方法与非静态方法同时声明了synchronized，他们之间时非互斥关系的。原因在于，静态方法锁是类对象而非静态方法锁是当前方法所属对象。</p><h2 id="线程安全API与非线程安全API"><a href="#线程安全API与非线程安全API" class="headerlink" title="线程安全API与非线程安全API"></a>线程安全API与非线程安全API</h2><p>StringBuffer 是同步的 synchronized append(); 安全的</p><p>StringBuilder 不是同步的 append();</p><p>相对而言StringBuffer在处理上稍逊于StringBuilder,但是其是线程安全的。当不存在并发时首选应当使用StringBuilder。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h3><p>当一个程序中若创建大量线程，并在任务结束后销毁，会给系统带来过度消耗资源，以及过度切换线程的危险，从而可能导致系统崩溃。为此我们应使用线程池来解决这个问题。</p><ul><li>线程池有两个主要作用:<ol><li>控制线程数量</li><li>重用线程</li></ol></li></ul><p>线程池的概念：首先创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。</p><p>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p><h3 id="线程池的管理"><a href="#线程池的管理" class="headerlink" title="线程池的管理"></a>线程池的管理</h3><p>ExecutorService是java提供的用于管理线程池的类。</p><ul><li>线程池有以下几种实现策略:<ol><li>Executors.newCachedThreadPool()<br>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</li><li>Executors.newFixedThreadPool(int nThreads)<br>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线 程。</li><li>Executors.newScheduledThreadPool(int corePoolSize)<br>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li><li>Executors.newSingleThreadExecutor()<br>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建具有30个线程的线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runable()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">...<span class="comment">//线程体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将任务交给线程池，其会分配空闲线程来运行这个任务。</span></span><br><span class="line">threadPool.execute(r1);</span><br></pre></td></tr></table></figure><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十五）异常处理</title>
    <link href="http://yoursite.com/2021/01/31/JAVA%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2021/01/31/JAVA%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-01-31T09:31:25.000Z</published>
    <updated>2021-03-20T10:00:28.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h2><h3 id="使用返回值状态标识异常"><a href="#使用返回值状态标识异常" class="headerlink" title="使用返回值状态标识异常"></a>使用返回值状态标识异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">abc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">      returen str;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>当程序中抛出一个异常后，程序从程序中导致异常的代码处跳出，Java虚拟机检测寻找try关键字匹配的处理异常的catch块。</p><h2 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a>异常的捕获和处理</h2><h3 id="Throwble-Error-Exception"><a href="#Throwble-Error-Exception" class="headerlink" title="Throwble / Error / Exception"></a>Throwble / Error / Exception</h3><p>Java异常结构中定义有Throwable类，Exception和Error是派生的两个子类。</p><p>Exception表示：网络故障、文件损坏、设备错误、用户输入非法等情况导致的异常，这类异常是可以通过Java异常捕获机制处理的。</p><p>Error表示：Java运行时环境出现的异常，例如JVM内存溢出等。</p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try_catch"></a>try_catch</h3><p>try{…}语句指定类一段代码，该代码块可以一次捕获并处理范围内的多个异常。在程序执行过程中，该代码块可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句分别对这些异常作出相应的处理。</p><p>如果没有异常产生，所有的catch语句都将被略过不执行。</p><p>在catch语句块中是对异常进行处理的代码。catch中声明的异常对<code>&#123;catch(Exception e)&#125;</code>封装了异常事件发生的信息，在catch语句块中可以使用这个对象的一些方法获取这些信息。</p><ul><li><p>其语法结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...<span class="comment">//可能出现的异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  ...<span class="comment">//处理该异常的代码块</span></span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="多个catch"><a href="#多个catch" class="headerlink" title="多个catch"></a>多个catch</h3><p>每个catch语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常。catch捕获的异常类型由上至下的捕获异常类型的顺序应是子类到父类（即小到大）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;<span class="comment">//子类异常应在上面捕获</span></span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(RunTimeException e)&#123;<span class="comment">//父类异常在下面捕获</span></span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//捕获Exception的异常放最下面</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常在书代码写时，应当做最后一个catch中捕获Exception，这样可以保证代码不会因为出现一个未在catch中声明的异常而导致捕获失败使得程序终止。</p><h3 id="finally的作用"><a href="#finally的作用" class="headerlink" title="finally的作用"></a>finally的作用</h3><p>finally语句为异常处理提供一个统一的出口，使得在控制流程到程序其他部分以前，能够对程序的状态统一管理。</p><p>无论try所指定的程序块中是否抛出异常，finally所指定的代码都要被执行，通常在finally语句中可以进行资源的消除工作，如：关闭打开的文件、删除临时文件等。</p><p><strong>finally语句块只能定义在try语句块之后，或者是最后一个catch语句块之后，且只能定义一次。</strong></p><h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>当程序发生错误而无法处理时，会抛出对应的异常对象，除此之外，在某些时刻，会想要自行抛出异常，例如在异常处理结束后，再将异常抛出，让下一层异常处理区块来捕捉。若想自从抛出异常，可以使用“throw”关键词，并生成指定的异常对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringToDate</span><span class="params">(String str)</span> throw PraseException</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="throws方法的重写"><a href="#throws方法的重写" class="headerlink" title="throws方法的重写"></a>throws方法的重写</h3><p>当使用继承时，在父类的某个方法上生声明了throws抛出某些异常，而在子类中重写该方法时，我们可以使用以下的操作：</p><ol><li>不处理异常（重写方法时不声明throws）</li><li>可仅在throws中声明父类中声明的部分异常</li><li>可以在throws中声明父类方法汇总抛出的异常的子类异常。</li></ol><p>但是不能进行以下操作：</p><ol><li>重写方法时在throws中声明抛出额外的异常</li><li>重写方法时在throws中声明父类方法中声明的抛出异常的父类异常</li></ol><h2 id="Java异常的API"><a href="#Java异常的API" class="headerlink" title="Java异常的API"></a>Java异常的API</h2><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><p><strong>Java 异常可以分为可检测异常和非检测异常。</strong></p><p>可检测异常：可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理或声明规则，不捕捉这个异常编译器就不通过，不允许编译。</p><p>非检测异常：非检测异常不遵循处理或声明规则。在产生此类异常时，不一定非要采用任何适当操作，编译器不会检测是否已经解决了这样的一个异常。</p><h3 id="常见RuntimeException"><a href="#常见RuntimeException" class="headerlink" title="常见RuntimeException"></a>常见RuntimeException</h3><ul><li><p>常见的其异常包括：</p><p><code>IllegalArgumentException;</code> 抛出的异常表明方法传递了一个不合法或不正确的参数</p><p><code>NullPointerException;</code> 当应用程序试图在需要的地方使用 null 时，抛出该异常</p><p><code>ArrayIndexOutOfBoundsException;</code> 当使用的数组下标超出数组允许范围时，抛出该异常</p><p><code>ClassCastException;</code> 当时图将对象强制转化为不是实例的子类时，抛出该异常</p><p><code>NumberFormatException;</code> 当程序员试图将字符串转换成一种数值类型，但格式不适当时，抛出该异常</p></li></ul><h2 id="Exception常用API"><a href="#Exception常用API" class="headerlink" title="Exception常用API"></a>Exception常用API</h2><h3 id="printStackTrace"><a href="#printStackTrace" class="headerlink" title="printStackTrace"></a>printStackTrace</h3><p>Throwable中定义了一个方法可以输出错误信息，用来跟踪异常事件发生时执行堆栈的内容。</p><ul><li><p>该方法的定义为：</p><p><code>void printStackTrace();</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();<span class="comment">//输出执行堆栈信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getMessage"><a href="#getMessage" class="headerlink" title="getMessage"></a>getMessage</h3><p>Throwbale中定义了一个方法可以得到有关异常事件的信息。</p><ul><li>该方法的定义为：<br><code>String GetMessage();</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getCause"><a href="#getCause" class="headerlink" title="getCause"></a>getCause</h3><p>很对时候，当一个异常由另一个异常导致异常而被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。这时，日志记录和打印根异常就变的非常重要。Java异常提供了getCause()方法来检索导致异常的原因，这些可以对异常根层次的原因提供更多的信息。该Java功能对代码的调试或故障排除有很大的帮助。另外，如果要把一个异常包装成另一种异常，构造一个新异常就要传递源异常。</p><ul><li><p>该方法的定义为：</p><p><code>Throwable getCause();</code> 获取该异常出现的原因</p></li></ul><h2 id="自定义Exception"><a href="#自定义Exception" class="headerlink" title="自定义Exception"></a>自定义Exception</h2><h3 id="自定义异常的意义"><a href="#自定义异常的意义" class="headerlink" title="自定义异常的意义"></a>自定义异常的意义</h3><p>Java异常机制可以保证程序更安全和更健壮。虽然Java类库已经提供了很多可以直接处理异常的类，但是有时候<strong>为了更加精准地捕获和处理异常以呈现更好的用户体验</strong>，需要开发者自定义异常。</p><h3 id="继承Exception自定义异常"><a href="#继承Exception自定义异常" class="headerlink" title="继承Exception自定义异常"></a>继承Exception自定义异常</h3><p>创建自定义异常类，语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class [自定义异常类名] extends Exception&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="其构造方法的编写"><a href="#其构造方法的编写" class="headerlink" title="其构造方法的编写"></a>其构造方法的编写</h3><p>当定义好自定义异常后，我们可以通过Ecplice来自动生成相应的构造方法。</p><p>具体步骤如下：</p><ol><li>声明个类并继承自Exception</li><li>右键点击score</li><li>选择Generate Constructors form Superclass</li><li>选择父类中所有构造方法后确认生成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="title">exdents</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message, Throwable cause)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message, cause);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(Throwable cause)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十四）IO操作</title>
    <link href="http://yoursite.com/2021/01/27/JAVA%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89IO%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2021/01/27/JAVA%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89IO%E6%93%8D%E4%BD%9C/</id>
    <published>2021-01-27T11:46:22.000Z</published>
    <updated>2021-03-19T14:18:12.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本IO操作"><a href="#基本IO操作" class="headerlink" title="基本IO操作"></a>基本IO操作</h1><h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul><li><p><strong>什么是输入：</strong>输入是一个从外界进入到程序的方向，通常我们需要“读取”外界的数据时，使用输入，所以输入是用来读取数据的。</p></li><li><p><strong>什么是输出：</strong>输出是一个从程序发送到外界的方向，通常我们需要“写出”数据到外界时，使用输出，所以输出是用来写出数据的。</p></li></ul><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><p>按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分别为节点流和处理流。</p><ul><li><strong>节点流：</strong>可以从或向一个特定的地方（节点）读写数据。</li><li><strong>处理流：</strong>是对一个已经存在的流的连接和封装，通过所封装的功能调用实现数据读写。</li></ul><p>处理流的构造方法总是带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称之为流的连接。</p><h3 id="其常用方法"><a href="#其常用方法" class="headerlink" title="其常用方法"></a>其常用方法</h3><p>InputStream是所有<strong>字节输入流</strong>的父类，其定义流基础的读取方法。</p><ul><li><p>常用的方法如下：</p><p><code>int read();</code> 读取一个字节，以int形式返回，该int的“低八位”有效，若返回值为-1则表示EOF。</p><p><code>int read(byte[] d);</code> 尝试最多读取给定数组的length个字节并存入该数组，返回值为实际读取到的字节量。</p></li></ul><p>OutputStream是所有<strong>字节输出流</strong>的父类，其定义流基础的写出方法。</p><ul><li><p>常用的方法如下：</p><p><code>void write(int d);</code> 写出一个字节，写的是给定的int的“低八位”。</p><p><code>void write(byte[] d);</code> 将给定的字节数组中的所有字节全部写出。</p></li></ul><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="创建FOS对象（重写模式）"><a href="#创建FOS对象（重写模式）" class="headerlink" title="创建FOS对象（重写模式）"></a>创建FOS对象（重写模式）</h3><p>FileOutputStream是文件的<strong>字节输出流</strong>，我们使用该流可以以字节为单位将数据写入文件。</p><ul><li><p>其构造方法为：</p><p><code>FileOutputStream(File file);</code> 创建一个指定File对象表示文件中写入数据的文件输出流。</p><p><code>FileOutputStream(String name);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo.txts&quot;</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br></pre></td></tr></table></figure><p><code>FileOutputStream(String filename);</code> 创建一个向具有指定名称的文件中写入数据的输出文件流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><div class="note warning flat"><p>若指定的文件已经包含内容，那么当使用FOS对其写入数据时，会将该文件中原有的数据全部去除。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//File file = new File(&quot;demo.txts&quot;);</span></span><br><span class="line"><span class="comment">//FileOutputStream fos = new FileOutputStream(file);</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">fos.write(<span class="string">&quot;helloworld&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="comment">//关闭此文件输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时可以查看创建的demo.txt文件，里面内容为helloworld</p><ul><li>字节输出流操作步骤：<ol><li>创建字节输出流对象（文件）</li><li>写数据</li><li>释放资源</li></ol></li><li>最后为什么一定要调用close()呢？<ol><li>让流对象变成垃圾，这样就可以被垃圾回收器回收了（GC）</li><li>通知系统去释放跟该文件相关的资源</li></ol></li></ul></blockquote><h3 id="创建FOS对象（追加模式）"><a href="#创建FOS对象（追加模式）" class="headerlink" title="创建FOS对象（追加模式）"></a>创建FOS对象（追加模式）</h3><p>若想在文件的原有数据之后追加新数据则需要以下构造方法创建FOS。</p><ul><li><p>其构造方法为：</p><p><code>FileOutputStream(String file, boolean append);</code>  创建一个指定File对象表示的文件中写入数据文件输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo.txts&quot;</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><code>FileOutputStream(String filename, boolean append);</code>  创建一个具有指定名称的文件中写入数据的输出文件流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>其成员方法为：</p><p><code>public int read();</code> 一次读取一个字节</p><p><code>public int read(byte[] b);</code> 一次读取一个字节数组</p></li></ul><div class="note warning flat"><p>以上两个构造方法中，第二个参数若为true，那么通过该FOS写出的数据都是在文件末尾追加的。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//第二个参数若为true，那么通过FOS写出的数据都是在文件末尾追加的</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//在上述文件中追加内容</span></span><br><span class="line">fos.write(<span class="string">&quot;NiHao&quot;</span>.getBytes());</span><br><span class="line">   <span class="comment">//释放资源</span></span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建FIS对象"><a href="#创建FIS对象" class="headerlink" title="创建FIS对象"></a>创建FIS对象</h3><p>FileInputStream是文件的<strong>字节输入流</strong>，我们使用该流可以以字节为单位读取文件内容。</p><ul><li><p>其构造方法为：</p><p><code>FileInputStream(File file);</code> 创建用于读取给定的File对象所表示的文件FIS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo.txts&quot;</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure><p><code>FileInputStream(String name);</code> 创建用于读取给定的文件系统中路径名name所指定的文件的FIS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//FileInputStream fis = new FileInputStream(new File(&quot;demo.txt&quot;));</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建字节输入流对象</span></span><br><span class="line">   FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> d = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//得到每一个字节，一个一个获取</span></span><br><span class="line"><span class="comment">//int read()： 读取一个字节</span></span><br><span class="line">   <span class="comment">//读取 判断 赋值</span></span><br><span class="line"><span class="keyword">while</span>((d=fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>)d);<span class="comment">//强转为char额</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//释放资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>字节输入流的操作步骤<ol><li>创建字节输入流对象</li><li>调用read()读取数据，将数据显示到控制台</li><li>释放资源</li></ol></li></ul></blockquote><h3 id="read-和write-int-d-方法"><a href="#read-和write-int-d-方法" class="headerlink" title="read()和write(int d)方法"></a>read()和write(int d)方法</h3><p>FileInputStream继承自InputStream，其提供了以字节为单位读取文件数据的方法read.</p><ul><li><p>其语法格式为：</p><p><code>int read();</code> 从此输入流中读取一个字节，若返回-1则表示EOF（End Of File）</p></li></ul><p>FileOutputStream继承自OutputStream，其提供了以字节为单位向文件写数据的方法write.</p><ul><li><p>其语法格式为：</p><p><code>void write(int d);</code> 将指定字节写入此文件输出流，这里只写给定的int值的“低八位”</p><p><code>void write(byte[] b);</code> 将给定的字节数组写入此文件输出流</p><p><code>void write(byte[] b,int off,int len);</code> 将给定字节的一部分写入文件输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件输出流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用write(int d)方法</span></span><br><span class="line">fos.write(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//注意：char占用两个字节，但这里只写了一个字节</span></span><br><span class="line">fos.write(<span class="number">97</span>);<span class="comment">//输出结果是97 -- 底层二进制数据 -- 通过记事本打开 -- 找97对应的字符值 -- a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//public void write(byte[] b):写一个字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bys=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">fos.write(bys);<span class="comment">//输出结果是abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//public void write(byte[] b,int off,int len):写一个字节数组的一部分</span></span><br><span class="line">fos.write(bys,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//输出结果是bcd</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="read-byte-d-和write-byte-d-方法"><a href="#read-byte-d-和write-byte-d-方法" class="headerlink" title="read(byte[] d)和write(byte[] d)方法"></a>read(byte[] d)和write(byte[] d)方法</h3><p>FileInputStream也支持批量读取字节数据的方法。</p><ul><li><p>其语法格式为：</p><p><code>int read(byte[] d);</code> 从此输入流中将最多d.length个字节的数据读入一个byte数组中</p></li></ul><p>FileOutputStream也支持批量读取字节数据的方法。</p><ul><li><p>其语法格式为：</p><p><code>void write(byte[] d);</code> 将d.length个字节从指定byte数组写入此文件输出流中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demotxt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="string">&quot;HelloWorld&quot;</span>.getBytes();</span><br><span class="line">fos.write(buf);<span class="comment">//会将HelloWorld的所有字节写入文件</span></span><br></pre></td></tr></table></figure></li><li><p>将指定byte数组中从偏移量off开始的len个字节写入文件输出流的方法：</p><p><code>void write(byte[] d, int offset, int len);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demotxt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="string">&quot;HelloWorld&quot;</span>.getBytes();</span><br><span class="line">fos.write(buf,<span class="number">5</span>,<span class="number">5</span>);<span class="comment">//只会将World这个5个字节写入文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="字节流复制数据"><a href="#字节流复制数据" class="headerlink" title="字节流复制数据"></a>字节流复制数据</h3><ul><li><p>数据源：从哪里来</p><p>a.txt 从中读取数据 FileInputStream</p><p>b.txt 向其写入数据 FileOutputStream</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line"><span class="comment">//封装目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>)</span><br><span class="line"><span class="comment">//读取数据并输入</span></span><br><span class="line"><span class="keyword">int</span> by = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((by.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(by);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>上述代码将文件a.tx复制为了一个名为b.txt的文件。</p><p>当我们开发中负责一个文件的话，不这样写，我们需要用一次读取一个字节数组的方法来写，一次读取大量数据，增加读写效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装数据</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream();</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream();</span><br><span class="line"><span class="comment">//一次读取1024个字节的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] <span class="keyword">byte</span> = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=<span class="keyword">byte</span>.fis.read(<span class="keyword">byte</span>)) != -<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(<span class="keyword">byte</span>,<span class="number">0</span>,len)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">fis.close;</span><br><span class="line">fos.close;</span><br></pre></td></tr></table></figure><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="BOS基本工作原理"><a href="#BOS基本工作原理" class="headerlink" title="BOS基本工作原理"></a>BOS基本工作原理</h3><p>与缓冲输出流相似，在向硬件设备做写出操作时，增大写出次数无疑会降低写出效率，为此我们可以使用缓冲输出流来一次性批量写出若干数据减少写出次数来提高写出效率。</p><ul><li><p><code>BufferedOutputStream</code> <strong>缓冲字节输出流</strong></p><p>其内部维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。</p></li></ul><h3 id="BOS的flush方法"><a href="#BOS的flush方法" class="headerlink" title="BOS的flush方法"></a>BOS的flush方法</h3><p>使用缓冲输出流可以提高写出效率，但会存在一个问题，即写书数据缺乏即时性。有时需要在执行完某些写出操作后，就希望将这些数据确实写出，而非在缓冲区保存知道缓冲区满后才写出。这时我们可以使用缓冲流的flash方法。</p><ul><li><p>其语法结构为：</p><p><code>void flash();</code> <strong>清空缓冲区</strong>，将缓冲区中的数据强制写出。</p></li></ul><h3 id="BIS基本工作原理"><a href="#BIS基本工作原理" class="headerlink" title="BIS基本工作原理"></a>BIS基本工作原理</h3><p>在读取数据时若以字节为单位读取数据，会导致读取次数过于频繁从而大大降低读取效率。为此我们可以通过提高一次读取的字节量减少读取次数来提高读取的效率。</p><ul><li><p><code>BufferedInputStream</code> <strong>缓冲字节输入流</strong></p><p>其内部维护着一个缓冲区（字节数组），使用该流在读取一个字节时，该流会尽可能多的一次性读取若干字节并存入缓冲区，然后逐一将字节返回，直到缓冲区中的数据被全部读取完毕，会再次读取若干字节从而反复。这样就减少了读取的次数，从而提高了读取效率。</p></li></ul><p>BIS是一个处理流，该流为我们提供了缓冲功能。</p><h3 id="实现缓冲输入输出"><a href="#实现缓冲输入输出" class="headerlink" title="实现缓冲输入输出"></a>实现缓冲输入输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo1.txt&quot;</span>);</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"><span class="keyword">int</span> d = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((d=bis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(d);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;复制完毕&quot;</span>);</span><br><span class="line">bos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><h3 id="对象序列化-反序列化"><a href="#对象序列化-反序列化" class="headerlink" title="对象序列化/反序列化"></a>对象序列化/反序列化</h3><p>对象是存在于内存中的。有时候我们需要将对象保存到硬盘上，有时候我们需要将对象传输到另一台计算机上等等这样的操作。这时我们需要将对象转换为一个字节序列，而这个过程就称为对象序列化。相反，我们有这样一个字节序列需要将其转换为对应的对象，这个过程就称为对象的反序列化。</p><h3 id="使用OOS实现对象序列化"><a href="#使用OOS实现对象序列化" class="headerlink" title="使用OOS实现对象序列化"></a>使用OOS实现对象序列化</h3><p>ObjectOutputStream是用来对对象进行序列化的输出流。</p><ul><li><p>其序列化方法为：</p><p><code>void writeObject(Object o);</code> 该方法可以将给定的对象转换为一个字节序列后写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Emp.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"><span class="comment">//new一个emp对象</span></span><br><span class="line">   Emp emp = <span class="keyword">new</span> Emp(<span class="string">&quot;张三&quot;</span>,<span class="number">24</span>,<span class="string">&quot;男&quot;</span>,<span class="number">12000.0</span>);</span><br><span class="line"><span class="comment">//将 emp 对象序列化后写入文件</span></span><br><span class="line">   oos.writeObject(emp);</span><br><span class="line">System.out.println(<span class="string">&quot;序列化完毕&quot;</span>);</span><br><span class="line">oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用OIS实现对象反序列化"><a href="#使用OIS实现对象反序列化" class="headerlink" title="使用OIS实现对象反序列化"></a>使用OIS实现对象反序列化</h3><p>ObjecInputStream是用来对对对象进行反序列化的输入流。</p><ul><li><p>其反序列化方法为：</p><p><code>Object readObject();</code> 该方法可以从流中读取字节并且转换为对应的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Emp.txt&quot;</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">   <span class="comment">//将 Emp 对象从文件中读取并反序列</span></span><br><span class="line">Emp emp = (Emp)ois.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;反序列化完毕&quot;</span>);</span><br><span class="line">System.out.println(emp);</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>ObjectInputStream在对对象进行序列化时有一个要求，就是需要序列化的对象所属的类必需实现Serializable接口。</p><p>实现该接口不需要重写任何方法，其只是作为可序列化的标志。</p><p>通常实现该接口的类需要提供一个常量SerialVersionUID，表明该类的版本。若不显示的声明，在对象序列化时会根据当前类的各个方面计算该类的默认SerialVersionUID，但不同平台编译器实现有所不同，所以若想跨平台，都应显示的声明版本号。</p><p>如果声明的类序列化存到硬盘上，之后随着需求的变化更改了类别的属性（增加或减少或改名），那么当反序列化时，就会出现InvalidClassException,这样就会造成不兼容的问题。但当serialVersionUID相同时，它就会将不一样的file以type的预设值反序列，可避免不兼容性问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>对象在序列化后得到的字节序列往往比较大，有时我们在对一个对象进行序列化时可以忽略某些不必要的属性，从而对序列化后得到的字节序列“瘦身”。</p><ul><li><p>关键字：</p><p><code>transient</code> （短暂的）被该关键字修饰的属性在序列化时其值将被忽略。·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//通常实现该接口的类需要提供一个常量serialVersionUID，表明该类的版本</span></span><br><span class="line"><span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> age;<span class="comment">//该属性在序列化时将被忽略</span></span><br><span class="line">String gender;</span><br><span class="line"><span class="keyword">double</span> salary;</span><br></pre></td></tr></table></figure><h1 id="文件数据IO操作"><a href="#文件数据IO操作" class="headerlink" title="文件数据IO操作"></a>文件数据IO操作</h1><h2 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h2><h3 id="字符流原理"><a href="#字符流原理" class="headerlink" title="字符流原理"></a>字符流原理</h3><p>Reader是所有<strong>字符输入流</strong>的父类，而Writer是所有<strong>字符输出流</strong>的父类。字符流是以字符（char）为单位读写数据的。一次处理一个unicode。字符流都是高级流，其底层都是依靠字节流进行读写数据的，所以底层仍然是基于字节读取数据。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>Reader的常用方法：</p><p>int read(); 读取一个字符，返回int值“低16”有效。</p><p>int read(char[] chs); 从该流中读取一个字符数组length个字符并存入该数组，返回值为实际读取到的字符量。</p></li><li><p>Writer的常用方法：</p><p>void write(int c); 写出一个字符，写出给定int值“低16位“表示的字符</p><p>void write(char[] chs); 将给定字符数组中所有字符写出</p><p>void write(String str); 将给定的字符串写出</p><p>void write(char[] chs, int offset, int len ); 将给定的字符数组中从offset处开始连续的len个字符写出</p></li></ul><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="字符转换流原理"><a href="#字符转换流原理" class="headerlink" title="字符转换流原理"></a>字符转换流原理</h3><p>InputStreamReader：<strong>字符输入流</strong>，使用该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并输出。</p><p>OutputStreamWriter：<strong>字符输出流</strong>，使用该流可以设置字符集 ，并按照指定的字符集将字符转换为对应字节后通过该流写出。</p><h3 id="指定字符编码"><a href="#指定字符编码" class="headerlink" title="指定字符编码"></a>指定字符编码</h3><ul><li><p>InputStreamReader的构造方法允许我们设置字符集：</p><p>InputStreamReader(InputStream, String charsetName); 基于给定的字节输入流以及字符编码创建isr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>​              InputStreamReader(InputStream in); 会根据系统默认字符集创建isr</p></li><li><p>OutputStreamWriter的构造方法为：<br>OutputStreamWriter(OutputStream, String charsetName); //基于给定的字节输出流以及字符编码创建osw</p><p>   OutputStreamWriter(OutputStream out); 会根据系统默认字符集创建osw</p></li></ul><h3 id="使用OutputStreamWriter"><a href="#使用OutputStreamWriter" class="headerlink" title="使用OutputStreamWriter"></a>使用OutputStreamWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//通过创建PrintWriter向文件输出内容</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//PrintWriter(OutputStream boolean auto)</span></span><br><span class="line"><span class="comment">//为true时，覆盖原有内容</span></span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(osw,<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">&quot;你好啊!&quot;</span>);</span><br><span class="line">pw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用InputStreamReader"><a href="#使用InputStreamReader" class="headerlink" title="使用InputStreamReader"></a>使用InputStreamReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//缓冲字符出入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//String readLine():连续读取一行</span></span><br><span class="line"><span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; </span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrintWriter的重载方法"><a href="#PrintWriter的重载方法" class="headerlink" title="PrintWriter的重载方法"></a>PrintWriter的重载方法</h3><p>使用PrintWriter写出字符时我们通常不使用Writer提供的writer()相关方法，而是使用print和println等方法，</p><ul><li>PrintWriter提供的重载方法有：<ol><li>void print(int i); 打印整数</li><li>void print(char c); 打印字符</li><li>void print(boolean b); 打印boolean值</li><li>void print(char[] c); 打印字符数组</li><li>void print(double d); 打印double值</li><li>void print(float f); 打印float值</li><li>void print(long l); 打印long值</li><li>void prnit (String str); 打印字符串</li></ol></li></ul><div class="note warning flat"><p>这些方法还有类似的println方法，参数与上面相同。</p></div><h3 id="使用pw输出字符数据"><a href="#使用pw输出字符数据" class="headerlink" title="使用pw输出字符数据"></a>使用pw输出字符数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//创建带有自动刷新的pw</span></span><br><span class="line"><span class="comment">//PrintWriter(OutputStream boolean auto)</span></span><br><span class="line"><span class="comment">//为true时，覆盖原有内容</span></span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(osw,<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">&quot;你好啊!&quot;</span>);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure><h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><h3 id="构建BufferedReader对象"><a href="#构建BufferedReader对象" class="headerlink" title="构建BufferedReader对象"></a>构建BufferedReader对象</h3><p>BufferedReader是<strong>缓冲字符输入流</strong>，其内部提供了缓冲区，可以提高读取效率。</p><ul><li><p>BufferedReader的常用构造方法：</p><p><code>BufferedReader(Reader reader);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//缓冲字符出入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//String readLine():连续读取一行</span></span><br><span class="line"><span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; </span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note warning flat"><p>因为BufferedReader在构造实例时需要传入一个字符流，所以当我们想基于一个字节流进行读取时，要先将字节流转换为字符流。</p></div><h3 id="使用BR读取字符串"><a href="#使用BR读取字符串" class="headerlink" title="使用BR读取字符串"></a>使用BR读取字符串</h3><p>BufferedReader提供了一个可以便于读取一行字符串的方法。</p><ul><li><p>其语法结构为：</p><p><code>String readLine()</code></p></li></ul><p>该方法连续读取一个字符串，直到读取到换行符为止，返回的字符串中不包含该换行符。若EOF则该方法返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//缓冲字符出入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//String readLine():连续读取一行</span></span><br><span class="line"><span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; </span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-O流大归纳"><a href="#I-O流大归纳" class="headerlink" title="I/O流大归纳"></a>I/O流大归纳</h1><p>==<strong>* 节点流/处理流 *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td>节点流</td><td>可以从或向一个特定的地点（节点）读写数据</td></tr><tr><td>处理流</td><td>是对一个已经存在的流的连接和封装，通过封装的功能调用实现数据读写</td></tr></tbody></table><p>==<strong>* 字节输入流/字节输出流 *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th></tr></thead><tbody><tr><td>InputStream</td><td>所有字节输入流的父类，==外部–&gt;程序==</td><td><code>int read()</code></td></tr><tr><td>OutputStream</td><td>所有字节输出流的父类，==程序–&gt;外部==</td><td><code>void write()</code></td></tr></tbody></table><p>==<strong>* 文件的字节输入流/输出流  *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th><th>模式</th></tr></thead><tbody><tr><td>（fis）FileInputStream</td><td>以字节为单位读取文件内容</td><td><code>int read()</code></td><td><code>int read(byte[] d)</code></td></tr><tr><td>（fos）FileOutputStream</td><td>以字节为单位输出数据内容</td><td><code>void write(int d)</code></td><td><code>void write(byte[] d)</code></td></tr></tbody></table><p>==<strong>* 缓冲字节输入/输出流 *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th><th>其他方法</th></tr></thead><tbody><tr><td>（bis）BufferedInputStream</td><td>一次性读取若干字节并存入缓冲区</td><td><code>bis.read()</code></td><td>无</td></tr><tr><td>（bos）BufferedOutputStream</td><td>一次性写入若干字节并存入缓冲区</td><td><code>bos.write(int d)</code></td><td>清空缓冲区：<code>void flash()</code>  |</td></tr></tbody></table><p>==<strong>* 对象流的序列化/反序列化 *</strong>==</p><!--该流需要实现Serializable接口，可以使用transient关键字对得到的字节序列“瘦身”--><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th></tr></thead><tbody><tr><td>（ois）ObjectInputStream</td><td>对对象进行反序列化的输入流</td><td><code>Object readObject()</code></td></tr><tr><td>（oos）ObjectOutputStream</td><td>对对象进行序列化的输出流</td><td><code>void writeObject(Object o)</code></td></tr></tbody></table><p>==<strong>* 字符输入流/输出流  *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th></tr></thead><tbody><tr><td>（isr）InputStreamReader</td><td>可以按照指定的字符集将字节数据转换并输入</td><td><code>InputStreamReader(InputStream, String charseName)</code></td></tr><tr><td>（osw）OutputStreamWriter</td><td>可以按照指定的字符集将字节数据转换并输出</td><td><code>OutputStreamWriter(OutputStream, String charseName)</code></td></tr></tbody></table><p>==<strong>* 缓冲字符输入流 *</strong>==</p><table><thead><tr><th>名称</th><th>定义</th><th>常用方法</th><th>读取一行字符串</th></tr></thead><tbody><tr><td>（br）BufferedReader</td><td>内部提供了缓冲区</td><td><code>BUfferedReader(Reader reader)</code></td><td><code>String readLine()</code></td></tr></tbody></table><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十三）文件操作-File</title>
    <link href="http://yoursite.com/2021/01/27/JAVA%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-File/"/>
    <id>http://yoursite.com/2021/01/27/JAVA%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-File/</id>
    <published>2021-01-27T03:41:25.000Z</published>
    <updated>2021-03-17T07:57:10.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件操作—File"><a href="#文件操作—File" class="headerlink" title="文件操作—File"></a>文件操作—File</h1><h2 id="File—文件"><a href="#File—文件" class="headerlink" title="File—文件"></a>File—文件</h2><p>java.io.File用于表示文件（目录），可以通过File类在程序上操作硬盘上的文件和目录。</p><p>File类只用于表示文件（目录）的信息（名称、大小），换句话说只能访问文件或目录的相关属性，不能对文件的内容进行访问。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="File-pathname"><a href="#File-pathname" class="headerlink" title="File(pathname)"></a>File(pathname)</h4><ul><li>File提供了较多的构造方法来创建实例，其中之一就是：<code>File(String pathname);</code></li></ul><p>通过将给定路径名字符串转换成抽象路径名来创建一个新File实例。</p><div class="note warning flat"><p>提示：抽象路径应尽量使用相对路径，并且目录的层级分隔符不要直接写“/”或“\”，因为不同的系统用的分隔符不一样应当使用File.separator这个常量表示，以避免不同系统带来的差异。</p></div><h4 id="File-parent-child"><a href="#File-parent-child" class="headerlink" title="File(parent, child)"></a>File(parent, child)</h4><ul><li>File的另一个构造方法：<code>File(File parent, String child);</code></li></ul><p>根据parent抽象路径名和child路径名字符串创建一个新的实例。</p><h3 id="isFile-方法"><a href="#isFile-方法" class="headerlink" title="isFile()方法"></a>isFile()方法</h3><p>File的isFile()方法用于判断当前File对象所表示的是否为一个文件</p><ul><li>其语法结构为：<code>boolean isFile();</code></li></ul><p>返回值为boolean类型</p><h3 id="length-方法"><a href="#length-方法" class="headerlink" title="length() 方法"></a>length() 方法</h3><p>File的isFile方法用于判断当前File对象表示的是否为一个文件。</p><ul><li>其语法结构为：<code>long length();</code></li></ul><p>该方法返回的long值表示该文件所占有的字节量。</p><h3 id="exists方法"><a href="#exists方法" class="headerlink" title="exists方法"></a>exists方法</h3><p>File的exists方法用于判断此抽象路径名表示的文件或目录是否存在。</p><ul><li>其语法结构为：<code>boolean exists();</code></li></ul><p>返回值为boolean类型。</p><p>若该File表示的文件或目录存在则返回true，否则返回false。</p><h3 id="createNewFile方法"><a href="#createNewFile方法" class="headerlink" title="createNewFile方法"></a>createNewFile方法</h3><p>File的createNewFile方法用于当且仅当不存在具有此抽象路径名指定的名称的文件时，原地创建一个新文件。</p><ul><li>其语法结构为：<code>boolean createNewFile();</code></li></ul><p>返回值：若果指定的文件不存在并成功的创建，则返回true；如果指定的文件已经存在，则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test15</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">//判断文件是否存在，若不存在则创建</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h3><p>File的delete方法用于删除此抽象路径名表示的文件或目录。</p><ul><li>其语法结构为：<code>boolean delete();</code></li></ul><p>返回值：当且仅当成功删除文件或目录时，返回true；否则返回false。</p><div class="note warning flat"><p>若此File对象所表示的是一个目录时，在删除时需要保证此为空目录才可以成功删除（目录中不能含有任何子项）。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">//判断该文件是否不存在，若文件不存在则创建它</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将该文件删除</span></span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File—目录"><a href="#File—目录" class="headerlink" title="File—目录"></a>File—目录</h2><h3 id="isDirectory-方法"><a href="#isDirectory-方法" class="headerlink" title="isDirectory()方法"></a>isDirectory()方法</h3><p>File的isDirectory方法用于判断当前File对象表示的是否为一个目录。</p><ul><li>其语法结构为：<code>boolean isDirectory();</code></li></ul><p>返回值：若File对象表示的是一个目录，则返回true。</p><h3 id="mkdir方法"><a href="#mkdir方法" class="headerlink" title="mkdir方法"></a>mkdir方法</h3><p>File的mkdir方法用于创建此抽象路径名指定的目录。</p><ul><li>其语法结构为：<code>boolean mkdir();</code></li></ul><p>返回值：当且仅当以创建目录时，返回true；否则返回false。</p><h3 id="mkdirs方法"><a href="#mkdirs方法" class="headerlink" title="mkdirs方法"></a>mkdirs方法</h3><p>File的mkdirs方法用于创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</p><div class="note warning flat"><p>此操作失败时也可能已经成功创建了一部分必需的父目录。</p></div><ul><li>其语法结构为：<code>boolean mkdirs;</code></li></ul><p>返回值：当且仅当已创建目录及所有必需的父目录时，返回true；否则返回false。</p><h3 id="listFile方法"><a href="#listFile方法" class="headerlink" title="listFile方法"></a>listFile方法</h3><p>File的listFile方法用于返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</p><ul><li>其语法结构为：<code>File[] listFiles();</code></li></ul><p>返回值：抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果抽象路径名不表示一个目录，或发生I/O错误，则返回null。</p><h3 id="FileFiter方法"><a href="#FileFiter方法" class="headerlink" title="FileFiter方法"></a>FileFiter方法</h3><p>该方法用于抽象路径名的过滤器，此接口的实例可传递给File类的listFile(FileFiter)方法，用于返回满足该过滤器要求的子项。</p><p>通过listFile方法可以获取一个目录下的所有子项，有时候只希望获取部分特定的子项，这时可以使用File的重载方法：</p><p><code>File[] listFiles(FileFiter fifter)</code></p><p>该重载方法要求传入一个参数。类型时FileFiter，FileFiter是用于抽象路径名的过滤器，相当于定义一个规则来过滤文件。FileFiter是一个接口，所以定义规则时，可以定义一个类来实现这个接口，而此接口的实例可传递给File类的listFile(FileFiter)方法。案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">File[] subs = dir.listFiles();</span><br><span class="line"><span class="comment">//File[] subs = dir.listFiles(new FileFiter()&#123;</span></span><br><span class="line"><span class="comment">//public boolean accept(File file) &#123;</span></span><br><span class="line"><span class="comment">//return file.getName().endsWith(&quot;.txt&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line">System.out.println(Arrays.toString(subs));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(File sub : subs) &#123;</span><br><span class="line">System.out.println(sub);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的参数FileFiter实例的accept方法进行过滤，listFile方法会将所有accept方法返回的true的子项保留并返回。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">deletefile(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于删除一个File对象(文件/目录)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deletefile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line"><span class="comment">//将目录中文件返回一个数组</span></span><br><span class="line">File[] sub = file.listFiles();</span><br><span class="line"><span class="comment">//增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(File a : sub) &#123;</span><br><span class="line">a.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java（十二）集合</title>
    <link href="http://yoursite.com/2021/01/25/Java%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2021/01/25/Java%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%9B%86%E5%90%88/</id>
    <published>2021-01-25T06:58:27.000Z</published>
    <updated>2021-03-17T02:01:11.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li>Java提供了一种可以存放一组数据的数据结果，称之为集合</li><li>Collection是一个父接口， 其定义了集合的相关功能</li></ul><h3 id="List-Set"><a href="#List-Set" class="headerlink" title="List / Set"></a>List / Set</h3><ul><li>Collection派生类两个字接口，一个List，另一个是Set</li><li>List是可重复集，该集合允许存放重复元素，所谓的重复并非是同一个元素，而是指equals方法比较为true的元素</li><li>Set是不可重复集，该集合中不能将相同的元素存入集合两次</li></ul><h3 id="集合持有对象的引用"><a href="#集合持有对象的引用" class="headerlink" title="集合持有对象的引用"></a>集合持有对象的引用</h3><ul><li>集合中存储的都是引用类型元素，引用类型变量实际上存储的是对象的地址信息，所以实际上集合只存储了元素对象在堆中的地址，并不是将对象本身存入了集合</li></ul><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><ul><li>Collection定义add方法用于向集合中添加新元素</li><li><code>boolean add(E e)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义String类型的集合</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//向集合中添加新元素</span></span><br><span class="line">c.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h3><ul><li><p><code>boolean contains(Object o)</code></p><p>用于判断给定的元素是否被包含在集合中，若包含则返回true，不包含返回false</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection&lt;Cell&gt; c = <span class="keyword">new</span> ArrayList&lt;Cell&gt;();</span><br><span class="line">c.add(<span class="keyword">new</span> Cell(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">c.add(<span class="keyword">new</span> Cell(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">c.add(<span class="keyword">new</span> Cell(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">c.add(<span class="keyword">new</span> Cell(<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">c.add(<span class="keyword">new</span> Cell(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">Cell a = <span class="keyword">new</span> Cell(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//判断给定的元素是否被包含在集合中，若包含则返回true，不包含返回false</span></span><br><span class="line"><span class="keyword">boolean</span> flag = c.contains(a);</span><br><span class="line">System.out.println(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size-clear-isEmpty"><a href="#size-clear-isEmpty" class="headerlink" title="size / clear / isEmpty"></a>size / clear / isEmpty</h3><ul><li><code>int size();</code> 获取当前集合中元素的总和</li><li><code>void clear();</code> 清空集合</li><li><code>boolean isEmpty();</code> 判断当前集合是否不包含元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  c.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> s =c.size();</span><br><span class="line">  System.out.println(s);</span><br><span class="line">  c.clear();</span><br><span class="line">  c.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">  System.out.println(c);</span><br><span class="line">  <span class="keyword">boolean</span> i = c.isEmpty();</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h2><h3 id="addAll和containall方法"><a href="#addAll和containall方法" class="headerlink" title="addAll和containall方法"></a>addAll和containall方法</h3><ul><li><p><code>boolean addAll(Collection c)</code></p><p>用于将给定的集合中所有元素添加到当前集合中</p></li><li><p><code>boolean conatinAll(Collection c)</code></p><p>用于判断当前集合是否包含给定集合中的所有元素</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Collection&lt;String&gt; c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c1.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">c2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">c2.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//判断给定的元素是否被包含在集合中，若包含则返回true，不包含返回false</span></span><br><span class="line">System.out.println(c1.containsAll(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>Iterator()方法用于返回一个实现了iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。 </p><ul><li>Collection提供了一个遍历集合的通用方法，迭代器</li><li><code>Iterator iterator()</code> 迭代器是一个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">  c.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">  <span class="comment">//Iterator iterator()迭代器是一个接口</span></span><br><span class="line">  Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">  <span class="comment">//判断集合是否还有元素可以遍历</span></span><br><span class="line">  <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    String str = it.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hasNext和next方法"><a href="#hasNext和next方法" class="headerlink" title="hasNext和next方法"></a>hasNext和next方法</h3><p>通过反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾。next方法将抛出一个NoSuchElementExpection。因此，需要在调用next之前调用hasNext方法。如果迭代器对象还有很对个供访问的元素，这个方法就返回true。如果想要查看集合中的所有元素，就请求一个迭代器，并在hasNext返回true时返回调用next方法。</p><ul><li><code>boolean hasNext();</code> 判断集合是否含有元素可以遍历</li><li><code>E next()</code> 返回迭代的下一个元素</li><li>迭代器遵循“<strong>先问后取</strong>”的方式。当确定hasNext方法的返回值为true时，再通过next方法取元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">  c.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">  c.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">  System.out.println(c);</span><br><span class="line">  <span class="comment">//Iterator iterator()迭代器是一个接口</span></span><br><span class="line">  Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    String str = it.next();</span><br><span class="line">    <span class="keyword">if</span>(str.indexOf(<span class="string">&quot;c&quot;</span>) != -<span class="number">1</span>) &#123;  <span class="comment">//检索字母c</span></span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(c);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而，如果想要删除这个位置上的元素，仍然需要越过这个元素。</p><p>对next方法和remove方法的调用具有互相依赖性。如果调用remove之前没有调用next将是不合法的。如果这样做，将会抛出一个IllegalStateExpection异常。</p><ul><li><p><code>void remove()</code></p><p>用于删除迭代器当次从集合中获取的元素</p></li></ul><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><ul><li><p>Java5.0之后推出新特性，增强for循环，也称之为新循环。该循环不通用于传统循环的工作，只用于遍历集合或数组</p></li><li><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 e:集合或数组名)&#123;</span><br><span class="line">  循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新循环并非新语法，而是在编译过程中，编译器会将新循环转换为迭代器模式，所以新循环本质上是迭代器</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Collection&lt;Integer&gt; c = <span class="keyword">new</span> HashSet&lt;Integer&gt;(); </span><br><span class="line">  c.add(<span class="number">123</span>);</span><br><span class="line">  c.add(<span class="number">234</span>);</span><br><span class="line">  c.add(<span class="number">345</span>);</span><br><span class="line">  c.add(<span class="number">456</span>);</span><br><span class="line">  c.add(<span class="number">567</span>);</span><br><span class="line">  <span class="comment">//增强for循环</span></span><br><span class="line">  <span class="keyword">for</span>(Integer a : c) &#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="泛型机制"><a href="#泛型机制" class="headerlink" title="泛型机制"></a>泛型机制</h2><h3 id="泛型在集合中的应用"><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h3><p>泛型是Java SE 5.0引入的特性，泛型的本质是参数化类型。在类、接口和方法的定义过程中，所操控的数据类型被传入的参数指定。</p><ul><li><p>Java泛型机制广泛应用在集合框架中。所有的集合类型都带有泛型参数，这样在创建集合时可以指定放入集合中的对象类型。Java编译器可以据此进行类型检查。</p></li><li><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如ArrayList，其定义时是这样的：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    … … …                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;…&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;…&#125;;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由此我们可以看出，再声明ArrayList时，类名的右侧有一个&lt;E&gt;。“&lt;&gt;”表示泛型，而其中可以使用数字字母下划线（数字不能时第一个字符）来表示泛型的名字。（通常我们使用一个大写字母来表示）这时，在类中声明的方法的参数，返回值类型可以被定义为泛型。这样创建对象可以将类型最为参数传递，此时，类定义所有的E将被替换成传入的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//泛型E在这里被指定为String类型</span></span><br><span class="line">list.add(<span class="string">&quot;One&quot;</span>);<span class="comment">//那么add方法的参数就被替换为String类型</span></span><br><span class="line">list.add(<span class="number">100</span>);<span class="comment">//这里就会出现编译错误，因为这里的参数应为String类型。</span></span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;</p><h1 id="集合操作——线性表"><a href="#集合操作——线性表" class="headerlink" title="集合操作——线性表"></a>集合操作——线性表</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口是Collection的子接口，用于定义线性表数据结构；可以将List理解为存放对象的数组，只不过其元素可以动态的增加或减少，并且<strong>List是可重复集</strong>。</p><h3 id="ArrayList-LinkedList"><a href="#ArrayList-LinkedList" class="headerlink" title="ArrayList / LinkedList"></a>ArrayList / LinkedList</h3><p>List接口的两个常见的实现类ArrayList和LinkedList，分别用动态数组和链表实现类接口</p><p>可以认为ArrayList和LinkedList的方法在逻辑上完全一样。只是在性能上有一定的差别。ArrayList更适用于随机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。</p><h3 id="set与get方法"><a href="#set与get方法" class="headerlink" title="set与get方法"></a>set与get方法</h3><p>List除了继承Collection定义的方法外，还根据其线性表的数据结构定义了一系列方法，其中最常用的就是<strong>基于下标的get和set方法</strong>。</p><ul><li><p><code>E get(int index);</code></p><p>获取集合中指定下标对应的元素，下标从0开始。</p></li><li><p><code>E set(int index, E element);</code></p><p>将给定的元素存入给定的位置，并将原位置的元素返回。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">   <span class="comment">//get方法遍历List</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line">String value = list.set(<span class="number">1</span>,<span class="string">&quot;F&quot;</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//b</span></span><br><span class="line">System.out.println(list);<span class="comment">//[a, F, c, d, e]</span></span><br><span class="line">   <span class="comment">//交换位置1和3上的元素</span></span><br><span class="line">   list.set(<span class="number">1</span>, list.set(<span class="number">3</span>, list.get(<span class="number">1</span>)));</span><br><span class="line">System.out.println(list);<span class="comment">//[a, d, c, F, e]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>List根据<strong>下标</strong>的操作还支持插入与删除操作：</p><ul><li><p><code>Void add(int index,E element);</code></p><p>将给定的元素插入到指定位置，原位置及后续元素顺序向后移动</p></li><li><p><code>E remove (int index);</code></p><p>删除给定位置的元素，并将被删除的元素返回。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//将下标为1的元素替换为指定元素</span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">System.out.println(list);<span class="comment">//[a, D, b, c]</span></span><br><span class="line"><span class="comment">//将下标为2的元素删除</span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line">System.out.println(list);<span class="comment">//[a, D, c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="subList方法"><a href="#subList方法" class="headerlink" title="subList方法"></a>subList方法</h3><p>List的subList方法用于获取子List。</p><p>需要注意的是，subList获取的List与原List<strong>占有相同的储存空间</strong>，对子List的操作会影响原List。</p><ul><li><code>List&lt;E&gt; subList(int formIndex,int toindex);</code>            <strong>含头不含尾</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//向list中添加数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);<span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">//找出指定范围的元素，含头不含尾</span></span><br><span class="line"><span class="comment">//subList获取的List和原List占有相同的数据空间</span></span><br><span class="line">List&lt;Integer&gt; sublist = list.subList(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//将提取出来的子表每位*10</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sublist.size(); i++) &#123;</span><br><span class="line">sublist.set(i, sublist.get(i)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sublist);<span class="comment">//[30, 40, 50, 60, 70]</span></span><br><span class="line">System.out.println(list);<span class="comment">//[0, 1, 2, 30, 40, 50, 60, 70, 8, 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List转换为数组"><a href="#List转换为数组" class="headerlink" title="List转换为数组"></a>List转换为数组</h3><p>List和toArray方法用于将集合转换为数组。但实际上该方法是在Collection中定义的，所以所有的集合都具备这个功能。</p><ul><li>其有两个方法：<ol><li><code>Object[] toArray();</code></li><li><code>T[] toArray(T[] a);</code></li></ol></li></ul><p>其中第二个是比较常用的，我们可以传入一个指定类型的数组，该数组的元素类型应与集合的元素类型保持一致。返回值则是转换后的数组，该数组会保存集合的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//将list表通过toArray()方法转换为数组</span></span><br><span class="line"><span class="comment">//传入的数组不需要指定长度</span></span><br><span class="line">String[] arr = list.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">System.out.println(arr.toString());</span><br><span class="line"><span class="comment">//重写toString</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组转换为List"><a href="#数组转换为List" class="headerlink" title="数组转换为List"></a>数组转换为List</h3><p>Arrays类中提供了一个静态方法asList，使用该方法我们将一个数组转换为对应的List集合。</p><ul><li><p>其定义方法为：</p><p><code>Static List&lt;T&gt; asList(T...a);</code></p></li></ul><p>返回的List的集合元素类型由传入的数组的元素类型决定。</p><div class="note warning flat"><p>返回的集合我们不能对其增删元素，否则会抛出异常。并且对集合的元素进行的修改会影响数组对应的元素。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//将数组arr通过Arrays.asList()方法转换为list表</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);<span class="comment">//抛出异常：UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java.utilArray$ArrayList</span></span><br><span class="line"><span class="comment">//得到list表的类和名字</span></span><br><span class="line">System.out.println(list.getClass().getName());</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list2.addAll(list);</span><br><span class="line">System.out.println(list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h2><h3 id="Collections-sort方法实现排序"><a href="#Collections-sort方法实现排序" class="headerlink" title="Collections.sort方法实现排序"></a>Collections.sort方法实现排序</h3><p>Collections是集合的工具类，它提供了很多便于我们操作集合的方法。</p><ul><li><p>该方法的定义为：</p><p><code>void sort(List&lt;T&gt; list);</code></p><p>其作用是对集合元素进行自然排序（小至大）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="comment">//随机生成数</span></span><br><span class="line">  Random r = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    list.add(r.nextInt(<span class="number">100</span>));<span class="comment">//nextInt(100):获得100以内的随机数</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(list);<span class="comment">//[76, 98, 24, 13, 44, 16, 50, 57, 20, 21]</span></span><br><span class="line">  Collections.sort(list);</span><br><span class="line">  <span class="comment">//升序排序</span></span><br><span class="line">  System.out.println(list);<span class="comment">//[13, 16, 20, 21, 24, 44, 50, 57, 76, 98]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>若想对某个集合的元素集合自然排序，该集合的元素有一个要求，就是这些元素必须是Comparable的子类</p><ul><li><p>Comparable是一个接口，用于定义其子类是可比较的，因为该接口有一个抽象方法：</p><p><code>int comparableTo(T t);</code></p></li></ul><p>所有子类都需要重写该方法来定义对象间的比较规律，该方法要求返回一个整数，这个整数不关心具体的值，而是关注取值范围。</p><ol><li>当返回值&gt;0时，表示当前对象比参数给定的对象大</li><li>当返回值&lt;0时，表示当前对象比参数给定的对象小</li><li>当返回值=0时，表示当前对象和参数给定的对象相等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cell</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cell</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.row = row;</span><br><span class="line"><span class="keyword">this</span>.col = col;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cell c)</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据row比较大小</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.row - c.row;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么Collections的sort在进行排序时就会根据集合中元素的compareTo方法的返回值来判断大小从而进行自然排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Cell&gt; cell = <span class="keyword">new</span> ArrayList&lt;Cell&gt;();</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">Collections.sort(cell);</span><br><span class="line">System.out.println(cell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="comparator"><a href="#comparator" class="headerlink" title="comparator"></a>comparator</h3><p>一旦Java类实现了Comparable，其比较逻辑就已经确定；如果希望在排序的操作中临时指定比较规定，可以采用Comparator接口回调的方式。</p><ul><li><p>该接口要求实现类必须重写其定义的方法：</p><p><code>int compare(T o1, T o2);</code></p></li></ul><p>该方法的返回值要求，o1&gt;o2则返回值应&gt;0，若o1&lt;o2则返回值应&lt;0，若o1=o2则返回值应为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Cell&gt; cell = <span class="keyword">new</span> ArrayList&lt;Cell&gt;();</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">4</span>,<span class="number">3</span>));</span><br><span class="line">cell.add(<span class="keyword">new</span> Cell(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">//Comparator为接口</span></span><br><span class="line"><span class="comment">//按照col值的大小排序</span></span><br><span class="line">Collections.sort(cell, <span class="keyword">new</span> Comparator&lt;Cell&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cell o1, Cell o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.col-o2.col;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(cell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列（Queue）时常用的数据结构，可以将队列看成特殊的线性表，队列限制了对线性表的访问方式：只能从线性表的一端添加（offer）元素，另一端取出（poll）元素。</p><p>队列遵循“先进先出”原则。</p><p>JDK中提供了Queue接口，同时使得LinkedList实现了该接口（选择LinkedList实现Queue的原因在于Queue经常要惊醒插入和删除的操作，而LinkedList在这方面效率较高）。</p><ul><li><p>Queue提供了操作队列的相关方法，其主要方法如下：</p><ol><li><p><code>Boolean oft(E e);</code></p><p>将元素添加到队列的末尾，若添加成功返回true</p></li><li><p><code>E poll();</code></p><p>从队首删除并返回该元素</p></li><li><p><code>E peek();</code></p><p>返回队首元素，但不删除</p></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">//使用offer() 方法将元素添加到队列中</span></span><br><span class="line">queue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(queue);</span><br><span class="line"><span class="comment">//返回队列首元素打不删除</span></span><br><span class="line">String str = queue.peek();</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">//从队首删除并返回该元素</span></span><br><span class="line">String s = queue.poll(); </span><br><span class="line">System.out.println(s);</span><br><span class="line">System.out.println(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>Deque是Queue的子接口，定义了所谓“双端队列”即从队列的两端分别可以入队（offer）和出队（poll），LinkedList实现了该接口。</p><p>如果将Deque限制为只能从一端入队和出队，则可以实现“栈（stack）”的数据结构，对于栈而言，入栈称之为push，出栈称之为pop。</p><p>栈遵循“先进后出”的原则。</p><ul><li><p>Deque提供了操作栈的相关方法，其主要方法如下：</p><ol><li><p><code>void push(E e);</code></p><p>将给定元素“压入”栈汇总，存入的元素会在栈首。即：栈的第一个元素。</p></li><li><p><code>E pop();</code></p><p>将栈首元素删除并返回。</p></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">//void push(E e)将给定的元素&quot;压入&quot;栈中</span></span><br><span class="line">stack.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(stack);</span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Java提供了一组可以以键值对（key-value）的形式存储数据的数据结构，这种结构称之为Map。可以Map看成一个多行两列的表格，其中第一列存储key，第二列存储value，而每一行就相当于一组key-value对，表示一组数据结构。</p><p>Map对存入的元素只有一个要求，就是key不能重复，所谓的不能重复指的是Map中不能包含两个equals为true的key。</p><p>Map对于key、value的类型没有严格要求，只要是引用类型均可。但是为了保证在使用时不会造成数据混乱，通常我们会使用泛型去约束key与value的类型。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ul><li>Map提供了一个方法：<code>V put(K k,V v);</code></li></ul><p>该方法的作用是将key-value对存入Map中，因为Map中不允许出现重复的key，所以若当次存入的key已经在Map中存在，则是替换value，而返回值则为被替换的元素。若key不存在，那么返回值就为null。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ul><li>Map提供了一个方法：<code>V get(Object key);</code></li></ul><p>该方法的作用是根据给定的key去查找Map中对应的value并返回，若当前Map汇总不包含给定的key，那么返回值为null。</p><h3 id="containKey方法"><a href="#containKey方法" class="headerlink" title="containKey方法"></a>containKey方法</h3><ul><li>其方法定义如下：<code>boolean containsKey(Object key);</code></li></ul><p>若当前Map中包含给定的key（这里检查是否包含是根据key的equals比较结果为依据的）则返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String,Integer&gt;();</span><br><span class="line"><span class="comment">//使用put方法将一组键值对存入map中</span></span><br><span class="line">map.put(<span class="string">&quot;城市一&quot;</span>, <span class="number">232</span>);</span><br><span class="line">map.put(<span class="string">&quot;城市二&quot;</span>, <span class="number">346</span>);</span><br><span class="line">map.put(<span class="string">&quot;城市三&quot;</span>, <span class="number">421</span>);</span><br><span class="line">map.put(<span class="string">&quot;城市四&quot;</span>, <span class="number">295</span>);</span><br><span class="line"><span class="comment">//获取给定的key获取value并返回</span></span><br><span class="line">Integer str1 = map.get(<span class="string">&quot;城市二&quot;</span>);</span><br><span class="line">System.out.println(str1);</span><br><span class="line"><span class="comment">//判断给定的key是否已经存在</span></span><br><span class="line"><span class="keyword">boolean</span> str2 = map.containsKey(<span class="string">&quot;城市二&quot;</span>);</span><br><span class="line">System.out.println(str2);</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//封装为entry实例</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; e: entry) &#123;</span><br><span class="line">System.out.println(e.getKey()+<span class="string">&quot;:&quot;</span>+e.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="hash表原理"><a href="#hash表原理" class="headerlink" title="hash表原理"></a>hash表原理</h3><p>HashMap是Map的一个常用的子类实现，其实使用散列算法实现的。</p><p>HashMap内部维护着一个散列数组（就是一个存放元素的数组）称之为散列桶，而当我们向HashMap中存入一组键值对时，HashMap首先获取key这个对象的hashcode()方法的返回值，然后使用该值进行散列算法，得出一个数字，这个数字就是这组键值对要存入散列数组的中的下标位置。</p><p>得到了这个下标位置后，HashMap还会查看散列数组当前位置是否包含该元素。（这里要注意的是，散列数组中每个元素并非是直接存储键值对的，而是存入了一个链表，这个链表中的每个节点才是真实保存这组键值对的）检查是否包含该元素时根据当前要存入的key在当前位散列数组对应位置中的链表里是否已经包含这个key，若不包含则将这组键值对存入链表，否则就替换value。</p><p>那么在获取元素时，HashMap同样先根据hashcode值进行散列算法，找到它在散列数组中的位置，然后进行遍历该位置的链表，找到该key所对应的value之后返回。</p><p>链表中只能存入一个元素，所以实际上，HashMap在放入一组键值对之前，会对这组键值对封装为一个Entry的实例，然后将该实例存入链表。</p><h3 id="hashcode-方法"><a href="#hashcode-方法" class="headerlink" title="hashcode()方法"></a>hashcode()方法</h3><p>HashMap的存取是依赖于key的hashcode方法的返回值的，而hashcode方法实际上是在Object中定义的。</p><ul><li><p>其定义如下：int hashCode();</p></li><li><p>重写一个类的hashcode()方法有以下注意事项：</p><ol><li>若一个类重写了equals方法，那就应当重写hashcode()方法。</li><li>若两个对象equals方法比较为true，那么他们就应当具有相同的hashcode值。</li><li>对于同一个对象而言，在内容没有发生改变的情况下，多次调用hashcode()方法应当总是返回相同的值。</li><li>对于两个对象equals比较为false的，并不要求hashcode值一定不同，但是应尽量保证不同，这样可以提高散列表性能。</li></ol></li></ul><h3 id="装载因子及HashMap优化"><a href="#装载因子及HashMap优化" class="headerlink" title="装载因子及HashMap优化"></a>装载因子及HashMap优化</h3><ul><li>在散列表中有以下名次需要了解：<ol><li>Capacity：容量。hash表里bucket（桶）的数量，也就是散列表的大小</li><li>Initial capacity：初始容量。创建hash表的初始bucket的容量，默认构建容量时16，也可以使用特定容量。</li><li>Size：大小。当前散列表中存储数据的容量</li><li>Load factor：加载因子。默认值0.75（就是75%），向散列表增加数据时如果size/capacity的值大于Local factory则发生扩容并且重新散列（rehash）。</li></ol></li></ul><p>那么加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量，0.75的性能和空间相对平衡的结果，在创建散列表时指定合理容量，从而可以减少rehash提高性能。</p><h3 id="有序Map"><a href="#有序Map" class="headerlink" title="有序Map"></a>有序Map</h3><p>Map接口的哈希表和链表实现，具有可预知的迭代顺序。此实现与HashMap的不同在于LinkedHashMap维护着一个双向循环链表。此链表迭代顺序通常就是存放元素的顺序。</p><div class="note warning flat"><p>如果Map中重新存入已有的key，那么key的位置不会发生改变，只是将value值替换。</p></div><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java（十一）日期操作</title>
    <link href="http://yoursite.com/2021/01/25/Java%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2021/01/25/Java%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C/</id>
    <published>2021-01-25T06:33:25.000Z</published>
    <updated>2021-01-26T00:02:16.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h1><h3 id="Java中的时间"><a href="#Java中的时间" class="headerlink" title="Java中的时间"></a>Java中的时间</h3><ul><li>Java中的时间使用标准类库Date类表示，是用距离一个固定时间点的毫秒数，表达一个特定的时间点</li></ul><h3 id="Date类的介绍"><a href="#Date类的介绍" class="headerlink" title="Date类的介绍"></a>Date类的介绍</h3><ul><li>java.util.Date类封装日期及时间</li><li>Date类的大多数用于进行时间分量计算方法已经由Calendar取代</li></ul><h3 id="setTime-getTime"><a href="#setTime-getTime" class="headerlink" title="setTime / getTime"></a>setTime / getTime</h3><ul><li><p><code>void setTime(Long time)</code></p><p>用于为一个Date对象设置其需要表示的时间</p></li><li><p><code>Long getTime()</code></p><p>获取一个Date对象表示的时间点，1970.1.1 00:00:00距离此时的毫秒数</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="keyword">long</span> time = date.getTime();</span><br><span class="line">System.out.println(time);</span><br><span class="line">time += <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">1000</span>;</span><br><span class="line">date.setTime(time);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Date重写toString"><a href="#Date重写toString" class="headerlink" title="Date重写toString"></a>Date重写toString</h3><ul><li>Date重写同 String方法，用一个字符串来描述当前Date对象所表示的是时间</li></ul><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><ul><li>是一个以与语言环境有关的方式来格式化解析日期的类</li></ul><h3 id="日期模式匹配字符串"><a href="#日期模式匹配字符串" class="headerlink" title="日期模式匹配字符串"></a>日期模式匹配字符串</h3><table><thead><tr><th>字符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>y</td><td>年</td><td>yyyy年</td></tr><tr><td>M</td><td>月</td><td>MM月</td></tr><tr><td>d</td><td>日</td><td>dd日</td></tr><tr><td>E</td><td>星期</td><td></td></tr><tr><td>a</td><td>上下午</td><td>am上午、pm下午</td></tr><tr><td>H</td><td>24小时制</td><td>HH点</td></tr><tr><td>h</td><td>12小时制</td><td>hh点</td></tr><tr><td>m</td><td>分</td><td>mm分</td></tr><tr><td>s</td><td>秒</td><td>ss秒</td></tr></tbody></table><h3 id="Date与String转化"><a href="#Date与String转化" class="headerlink" title="Date与String转化"></a>Date与String转化</h3><ul><li><p>将Date格式转化为String</p><p><code>String format(Date)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//设定输出格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">String str = sdf.format(date);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>将String格式转化为Date</p><p><code>Date parse(String str)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;2021年1月25日 11:39:39&quot;</span>;</span><br><span class="line"><span class="comment">//将中式格式改为国际标准格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//抛出异常  throws ParseException</span></span><br><span class="line">Date date = sdf.parse(str);</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><h3 id="Calendar简介"><a href="#Calendar简介" class="headerlink" title="Calendar简介"></a>Calendar简介</h3><ul><li>java.util.Calendar类用于封装日历信息，其主要作用在于时间分量的计算</li><li>Calendar是抽象类。本身不能被实例化</li></ul><h3 id="getInstance方法"><a href="#getInstance方法" class="headerlink" title="getInstance方法"></a>getInstance方法</h3><ul><li><p><code>Calendar getInstance()</code></p><p>该方法根据当前系统所在的区域获取一个适当的Calendar</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Calendar c = Calendar.getInstance();</span><br><span class="line">  System.out.println(c.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置日期及时间分量"><a href="#设置日期及时间分量" class="headerlink" title="设置日期及时间分量"></a>设置日期及时间分量</h3><ul><li><p><code>void set(int fidel, int value)</code></p><p>可通过对不同的时间分量设置不同的值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(Calendar.YEAR, <span class="number">2021</span>);</span><br><span class="line">c.set(Calendar.MONTH, <span class="number">01</span>);</span><br><span class="line">c.set(Calendar.DATE, <span class="number">25</span>);</span><br><span class="line">System.out.println(c.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取时间分量对应的值"><a href="#获取时间分量对应的值" class="headerlink" title="获取时间分量对应的值"></a>获取时间分量对应的值</h3><ul><li><p><code>int get(int field)</code></p><p>可以通过对不同的时间分量获取相应的值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH);</span><br><span class="line">System.out.println(year);</span><br><span class="line">System.out.println(month);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getActualMaximum"><a href="#getActualMaximum" class="headerlink" title="getActualMaximum()"></a>getActualMaximum()</h3><ul><li>用于获取给定时间分量所允许的最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">//获取给定时间分量所允许的最大值</span></span><br><span class="line"><span class="keyword">int</span> max = c.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(max);</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li><code>void add(int field, int ammount)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.add(Calendar.DAY_OF_MONTH,<span class="number">7</span>);</span><br><span class="line">System.out.println(c.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（十）包装类</title>
    <link href="http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E5%8D%81%EF%BC%89%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E5%8D%81%EF%BC%89%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2021-01-22T06:17:57.000Z</published>
    <updated>2021-02-02T12:25:30.975Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h3 id="包装类概述"><a href="#包装类概述" class="headerlink" title="包装类概述"></a>包装类概述</h3><ul><li>Java的8种基本数据类型是以值的形式存在于内存中，而不是对象，不是Object的子类，不能参与面向对象的开发。</li></ul><h3 id="基本类型的包装类"><a href="#基本类型的包装类" class="headerlink" title="基本类型的包装类"></a>基本类型的包装类</h3><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>char</td><td>java.lang.Character</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td></tr></tbody></table><ul><li>其中除了Character和Boolean的父类是Object之外，其余的首饰继承java.lang.Number</li></ul><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><ul><li><p>这些包装类都有一个共性，描述的都是数字</p><p>Number是一个抽象类</p><p>例如：abstract double doubleValue() 以double形式返回指定的数值</p></li></ul><h3 id="Integer常用功能"><a href="#Integer常用功能" class="headerlink" title="Integer常用功能"></a>Integer常用功能</h3><ul><li><p>Java.lang.Integer 是int的包装类，其每一个实例用于描述一个基本int的值</p></li><li><p>Integer 有一个静态方法</p><p>Static int parseInt(String s)</p><p>该方法的作用：将一个描述整数的字符串解析为该整数</p></li></ul><h3 id="Double常用功能"><a href="#Double常用功能" class="headerlink" title="Double常用功能"></a>Double常用功能</h3><ul><li><p>java.lang.Double是double的包装类，其每一个实例用于描述一个基本double的值</p></li><li><p>Double又一个静态方法</p><p>Static double praseDouble(String s)</p><p>该方法的作用：将一个描述浮点数的字符串解析为该整数</p><p>例如：</p><p>String a = “789.99”;</p><p>Double.praseDouble(a)        —&gt;789.99</p></li></ul><h3 id="自动装箱和拆箱操作"><a href="#自动装箱和拆箱操作" class="headerlink" title="自动装箱和拆箱操作"></a>自动装箱和拆箱操作</h3><ul><li><p>当我们需要将一个基本类型转化为包装类型，可以调用包装类的一个静态方法valueOf()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">Integer ac = Integer.valueOf(a);<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">double</span> z = <span class="number">9.9</span>;</span><br><span class="line">Double d = Double.valueOf(z);</span><br></pre></td></tr></table></figure></li><li><p>当我们需要将包装类型转换为基本类，可以调用包装类的xxxValue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> n = i.intValue();</span><br><span class="line">Double a = <span class="keyword">new</span> Double(<span class="number">12.34</span>);</span><br><span class="line"><span class="keyword">double</span> x = a.doubleValue();<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure></li><li><p>Java5.0新特性，引入自动拆装箱操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">123</span>;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">123</span>);<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（九）Object</title>
    <link href="http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E4%B9%9D%EF%BC%89Object/"/>
    <id>http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E4%B9%9D%EF%BC%89Object/</id>
    <published>2021-01-22T05:53:38.000Z</published>
    <updated>2021-03-15T08:45:16.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bbject"><a href="#Bbject" class="headerlink" title="Bbject"></a>Bbject</h1><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li>Object类是Java中所有类的顶级父类，如果一个类没有显式的使用extends继承某个类是，默认就是继承自Object类</li></ul><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><ul><li><p>Object类实现的toString方法不具备什么实际意义，所以若我们需要在子类中使用该方法是通常我们会重写它</p></li><li><p>重写toString方法的意义：</p><p>用一个字符串描述当前对象</p></li></ul><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ul><li>重写equals应遵循几个原则<ol><li>任何对象与null比较都返回false</li><li>两个对象不属于同于个类是应返回false</li><li>同一个对象equals比较应当恒等于true</li><li>其他可以采用自己定义</li></ol></li></ul><h3 id="equals与“-”的区别"><a href="#equals与“-”的区别" class="headerlink" title="equals与“==”的区别"></a>equals与“==”的区别</h3><ul><li><p>“==”是值比较</p><p>对于引用类型变量而言，该变量保存的是对象地址，所以使用“==”比较时，意思为两个变量的地址是否相同，可以理解为两个引用的是否为用一个地址</p></li><li><p>equals时内容比较</p><p>对于两个引用变量而言，是比较两个变量所引用的对象是否相同</p></li><li><p>“==”判断是否为同一个，而“equals”是判断像不像</p></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（八）字符串的基本操作</title>
    <link href="http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E5%85%AB%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2021/01/22/JAVA%EF%BC%88%E5%85%AB%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-01-22T00:54:24.000Z</published>
    <updated>2021-02-03T12:01:19.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串的基本操作"><a href="#字符串的基本操作" class="headerlink" title="字符串的基本操作"></a>字符串的基本操作</h1><h3 id="String及常见API"><a href="#String及常见API" class="headerlink" title="String及常见API"></a>String及常见API</h3><h3 id="String是不可变对象"><a href="#String是不可变对象" class="headerlink" title="String是不可变对象"></a>String是不可变对象</h3><ul><li>Java定义String对象为不可变对象，一旦在内存中创建，内容不能发生改变，若要对字符串改变，那么就会创建新的对象。这样做的目的是可以最大程度上重用相同内容的字符串以减少系统资源开销。</li></ul><h3 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h3><ul><li>给一个字符串做初始化时，JVM首先会从字符串的常量池中查询用来保存该字符串的对象是否已经存在，若存在直接引用，若不存在则创建该字符串的对象并存入常量池，然后引用它</li></ul><h3 id="内存编码及长度"><a href="#内存编码及长度" class="headerlink" title="内存编码及长度"></a>内存编码及长度</h3><ul><li>Java存储每一个字符均使用两个字节，都是使用的是 Unicode编码，并且任何一个字符（无论是中文还是英文）每个字符的长度都是1，所以字符串的长度就是该字符串所有的字符个数</li><li><code>int length();</code> 返回当前字符串的长度</li></ul><h3 id="使用-indexOf实现检索"><a href="#使用-indexOf实现检索" class="headerlink" title="使用 indexOf实现检索"></a>使用 indexOf实现检索</h3><ul><li><p><code>int indexOf(int ch)</code></p><p>用来检索给定的一个字符在当前字符串中第一次出现的下标位置</p></li></ul><h3 id="使用-subString-获取字符串"><a href="#使用-subString-获取字符串" class="headerlink" title="使用 subString 获取字符串"></a>使用 subString 获取字符串</h3><ul><li><p><code>String subString(int begin, int end)</code></p><p>用来截取当前字符部分内容以获取这个子字符串。begin代表从哪里开始，end代表是从哪里结束（含头不含尾）</p></li></ul><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><ul><li><p><code>String trim()</code></p><p>将字符串两边的空白去掉</p></li></ul><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><ul><li><p><code>char charAt(int index)</code></p><p>用于给定一个下标位置，来获取该字符串中这个位置的字符串</p></li></ul><h3 id="startsWith-和-endsWith"><a href="#startsWith-和-endsWith" class="headerlink" title="startsWith 和 endsWith"></a>startsWith 和 endsWith</h3><ul><li><p><code>boolean startWith(String suffix)</code></p><p>用来判断当前字符串是否是以给定的字符串开始的</p></li><li><p><code>boolean endsWith(String suffix)</code></p><p>用来判断当前字符串是否是以给定的字符串结尾的</p></li></ul><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><ul><li><p><code>String toUpperCase()</code></p><p>用来将当前字符串中的英文部分全部转换为大写</p></li><li><p><code>String toLowerCase()</code></p><p>用来将当前字符串中的英文部分全部转换为小写</p></li></ul><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><ul><li><p>字符串提供了很多重载的valueOf方法，可以将其他基本类型的值以字符串形式描述</p></li><li><p><code>static String valueOf(int i)</code> 返回int参数的字符串表示形式</p></li></ul><h3 id="StringBuilder封装可变字符串"><a href="#StringBuilder封装可变字符串" class="headerlink" title="StringBuilder封装可变字符串"></a>StringBuilder封装可变字符串</h3><ul><li>该类封装了可变的字符串，当我们需要改变字符串内容时，并不会和创建新的对象，而是在原有的基础上修改，从而减少了内存开销</li><li>常用方法：<ol><li><code>append(String Str);</code>        —&gt; 追加字符串</li><li><code>insert(int disOffset, String s);</code>    –&gt; 插入字符串</li><li><code>delete(int start, int end);</code>        —&gt; 删除字符串</li><li><code>replace(int start, int end, String str)</code></li></ol></li></ul><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul><li>StringBuilder是可变字符串，StringBuffer也是可变字符串</li><li>区别<ol><li>StringBuffer是线程安全，同步处理的，性能稍慢</li><li>StringBuilder是非线程安全的，并发处理的，性能稍快</li></ol></li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA （七）抽象类 / 接口 / 多态</title>
    <link href="http://yoursite.com/2021/01/21/JAVA-%EF%BC%88%E4%B8%83%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%20:%20%E6%8E%A5%E5%8F%A3%20:%20%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2021/01/21/JAVA-%EF%BC%88%E4%B8%83%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%20:%20%E6%8E%A5%E5%8F%A3%20:%20%E5%A4%9A%E6%80%81/</id>
    <published>2021-01-21T07:03:34.000Z</published>
    <updated>2021-02-02T11:59:24.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h3 id="使用抽象类"><a href="#使用抽象类" class="headerlink" title="使用抽象类"></a>使用抽象类</h3><ul><li><p>抽象方法和抽象类</p><p>由<code>abstract</code>修饰的方法为抽象方法，抽象方法即只有方法的定义，没有方法的实现，由一个分号结尾。即方法五要素缺少了一个（方法体），可以将抽象方法理解为不完整的方法</p></li><li><p>若抽象方法包含在类中，则该类以为抽象类，该类也不完整，抽象类由<code>abstract</code>修饰</p></li><li><p>抽象类是不能实例化对象，而一个类不能被实例化湿没有任何意义的，所以，需要定义类来继承他。而一个类继承了抽象类，则应该重写其抽象方法。</p></li></ul><h3 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h3><ul><li>定义抽象类的意义在于：<ol><li>为其子类提供一个公共的类型</li><li>让其子类继承之后完成具体的实现</li></ol></li></ul><p>&nbsp;</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ul><li>接口可以堪称是特殊的抽象类，即指包含抽象方法的常量的抽象类通过<code>interface</code>关键字来定义接口</li></ul><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><ul><li>与继承不同，一个类可以实现多个接口，实现的接口之间用逗号分隔。当然，该类需要实现这些接口中定义的所有方法</li><li>一个类可以通过<code>implements</code>关键字“实现接口”</li></ul><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><ul><li><p>接口间可以存在继承关系，一个接口可以过<code>extends</code>关键字继承另外一个接口，子接口继承了父接口定义的所有方法</p></li><li><p>如果在一个类中需要同时继承一个类实现一个或者多个接口时，继承（extends）要写在实现（implements）的前面</p><p>语法：<code>class 类名 extends 父类 implement 接口1，接口2...</code></p></li><li><p>接口可继承多个父接口（即：接口是多继承的）;abstract若没写，系统会自动加上</p><p>语法<code>[修饰符] (abstract) interface 接口名[extends 父接口1,父接口2...]</code></p></li></ul><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>一个类只能继承一个抽象类，但可以实现多个接口</li><li>抽象类中可以包含抽象方法和非抽象方法，而接口中所有的方法都是抽象的</li><li>子类继承抽象类应该完成抽象类中所有的抽象方法，否则子类也必须是抽象类；子类实现接口则必须完成其所有的抽象方法</li></ul><p>&nbsp;</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态</li><li>一个类型的引用在指向不同的对象是会有不同的实现</li><li>同一个对象，造型成不同的类型时，会有不同的功能</li></ul><h3 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h3><ul><li>父类的引用指向子类的对象</li></ul><h3 id="强制转型（向下造型）"><a href="#强制转型（向下造型）" class="headerlink" title="强制转型（向下造型）"></a>强制转型（向下造型）</h3><ul><li>在强制转型中，必须满足两个条件之一，即前后两者必须时继承关系或实现关系。</li><li>使用<code>instanceof</code>关键字实现强制转型，返回true或false</li></ul><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（六）static / final</title>
    <link href="http://yoursite.com/2021/01/21/JAVA%EF%BC%88%E5%85%AD%EF%BC%89static%20:%20final/"/>
    <id>http://yoursite.com/2021/01/21/JAVA%EF%BC%88%E5%85%AD%EF%BC%89static%20:%20final/</id>
    <published>2021-01-21T01:06:23.000Z</published>
    <updated>2021-03-15T05:20:46.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h3 id="static修饰成员变量"><a href="#static修饰成员变量" class="headerlink" title="static修饰成员变量"></a>static修饰成员变量</h3><ul><li>static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员</li><li>当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一样一起存储在方法区中</li><li>一个类的static成员变量中有“一份”（存储在方法区）无论该类创建了多少个对象</li></ul><h3 id="static修饰属性"><a href="#static修饰属性" class="headerlink" title="static修饰属性"></a>static修饰属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当加载类时就会优先初始化t变量，所以是在运行期前初始化空间。</span></span><br><span class="line">    <span class="comment">//在此之后使用Test.t = &quot;test2&quot;这样的语句，可以修改成功。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static修饰方法"><a href="#static修饰方法" class="headerlink" title="static修饰方法"></a>static修饰方法</h3><ul><li>static修饰的方法称之为静态方法，而静态方法不会涉及具体的某一个对象，只是当前完成了一件共有的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过Test.main()来进行调用。也是在加载字节码时初始化。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static块（静态块）"><a href="#static块（静态块）" class="headerlink" title="static块（静态块）"></a>static块（静态块）</h3><ul><li>static块属于类的代码块，在类的加载期间执行的，只执行一次。可以用来在软件中加载静态资源（图像、音频等）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><ul><li>final关键字修饰的变量，意为不可改变。final可以修饰成员变量，也可以修饰局部变量。</li></ul><h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><ul><li>final关键字修饰的方法不可以被重写。</li></ul><h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><ul><li>final修饰的类不可以被继承</li></ul><h3 id="final修饰变量-1"><a href="#final修饰变量-1" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><ul><li>final修饰的变量不能被改变</li></ul><h2 id="static-final-常量"><a href="#static-final-常量" class="headerlink" title="static final 常量"></a>static final 常量</h2><ul><li>static final 修饰的成员变量称为常量，必须声明同时初始化，并且不可被改变，常量建议所有字母大写</li></ul><div class="note warning flat"><p>static final和final static没什么区别，一般static写在前面。</p></div><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>工具类的使用</title>
    <link href="http://yoursite.com/2021/01/20/JAVA%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2021/01/20/JAVA%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-20T14:46:58.000Z</published>
    <updated>2021-01-21T00:21:19.295Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Arrays类的使用"><a href="#Arrays类的使用" class="headerlink" title="Arrays类的使用"></a>Arrays类的使用</h1><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><ul><li><p><strong>toString：</strong>对数组进行遍历查看，返回的是一个字符串，这个比字符串好看。</p><p>包含：<code>boolean[] a</code>、<code>byte[] a</code>、<code>char[] a</code>、<code>double[] a</code>、<code>float[] a</code>、<code>int[] a</code>、<code>long[] a</code>、<code>short[] a</code>、<code>Object[] a</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">62</span>,<span class="number">57</span>,<span class="number">35</span>,<span class="number">76</span>,<span class="number">25</span>,<span class="number">35</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><ul><li><strong>sort：</strong>对数组升序排列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">62</span>,<span class="number">57</span>,<span class="number">35</span>,<span class="number">76</span>,<span class="number">25</span>,<span class="number">35</span>&#125;;</span><br><span class="line">    <span class="comment">//排序---&gt;sort:升序</span></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h3><ul><li><p><strong>binarySearch：</strong>二分法查找</p><p> 找出指定数组中的指定元素对应 的索引</p></li><li><p>前提：只能查看有序数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">System.out.println(Arrays.binarySearch(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="copeOf"><a href="#copeOf" class="headerlink" title="copeOf"></a>copeOf</h3><ul><li><p><strong>copeOf：</strong>完成数组的复制</p><p><strong>(arr,int)：</strong>(数组名,复制的长度)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(arr,<span class="number">4</span>); </span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="copeOfRange"><a href="#copeOfRange" class="headerlink" title="copeOfRange"></a>copeOfRange</h3><ul><li><p><strong>copeOfRange：</strong>区间复制</p><p><strong>(arr,1,4)：</strong>(数组名,开始位置,终止位置)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">4</span>); <span class="comment">//---[1,4):左包含，右不包含 </span></span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><ul><li><strong>equals：</strong>比较两个数组的值是否一样，若一样则返回true，否则返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] arr2 = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Arrays.equals(arr1,arr2);<span class="comment">//true: 比较左右两侧的数值是否相等</span></span><br><span class="line">System.out.println(arr1 == arr2);<span class="comment">//false: ==比较左右两侧的地址 值是否相等</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><ul><li><p><strong>fill：</strong> 进行数组的填充</p><p><strong>(arr, int)：</strong>(数组名,填充的数据)</p><p>(arr,int,int,int)：（数组名,起始位置,终止位置,填充的数据）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Arrays.fill(arr, <span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">    Arrays.fill(arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA（五）访问控制</title>
    <link href="http://yoursite.com/2021/01/20/JAVA%EF%BC%88%E4%BA%94%EF%BC%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2021/01/20/JAVA%EF%BC%88%E4%BA%94%EF%BC%89%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</id>
    <published>2021-01-20T07:35:36.000Z</published>
    <updated>2021-02-04T04:44:56.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h3><p>包的概念，定义类时需要指定类的名称，但是如果仅仅将类名作为类的唯一标识，则不可避免会出现冲突的问题。在Java语句中命名冲突问题可以用包名来解决。</p><p>在定义一个类时，除了定义类的名称一般还要指定一个包名。</p><p>类的全名称：<code>包名.类名</code></p><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>访问一个类时需要使用该类的全名，但这样书写过于麻烦，可以过import语句对类的全程进行声明。通过import语句声明类类的全程后，可以直接使用类名。</p><p>引用依赖，导包</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对外提供可调用的、稳定的功能。</p><p>封装容易变化的、具体的细节，外界不可访问，这样的意义在于：</p><ol><li>降低代码出错的可能性，便于维护</li><li>当内部的实现细节改变时，只要保证对外的功能定义不变，其他的模块就不会因此收到牵连。</li></ol><h3 id="public和private"><a href="#public和private" class="headerlink" title="public和private"></a>public和private</h3><p>public和private是最常用的两个修饰符</p><p>private修饰的成员变量和方法只能在本类中访问</p><p>public修饰的成员变量和方法可以在任何地方调用</p><p>public修饰的内容是对外提供可以被调用 的功能，需要相对稳定</p><p>private修饰的内容是对内实现的封装，如果“公开”会增加维护成本</p><h3 id="protected和默认"><a href="#protected和默认" class="headerlink" title="protected和默认"></a>protected和默认</h3><p>protected修饰的成员变量和方法可以被子类及同包类使用</p><p>默认访问控制即不写任何访问控制符，默认修饰的成员变量和方法可以被同一个包中的类调用。</p><h3 id="访问控制符修饰类"><a href="#访问控制符修饰类" class="headerlink" title="访问控制符修饰类"></a>访问控制符修饰类</h3><p>public和默认修饰符可以修饰类</p><p>protected和private不能修饰类（可以用于修饰内部类）</p><h3 id="四者修饰的“成员”"><a href="#四者修饰的“成员”" class="headerlink" title="四者修饰的“成员”"></a>四者修饰的“成员”</h3><table><thead><tr><th>修饰符</th><th>本类</th><th>同包类</th><th>子类</th><th>其他类</th></tr></thead><tbody><tr><td>public</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td>可以访问</td></tr><tr><td>protected</td><td>可以访问</td><td>可以访问</td><td>可以访问</td><td>不可以</td></tr><tr><td>默认</td><td>可以访问</td><td>可以访问</td><td>不可以</td><td>不可以</td></tr><tr><td>private</td><td>可以访问</td><td>不可以</td><td>不可以</td><td>不可以</td></tr></tbody></table><p>&nbsp;</p><hr><div align="center">❤️&nbspEND&nbsp❤️</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
